<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>package org.cpsolver.coursett.constraint;<a name="line.1"></a>
<span class="sourceLineNo">002</span><a name="line.2"></a>
<span class="sourceLineNo">003</span>import java.util.ArrayList;<a name="line.3"></a>
<span class="sourceLineNo">004</span>import java.util.BitSet;<a name="line.4"></a>
<span class="sourceLineNo">005</span>import java.util.Enumeration;<a name="line.5"></a>
<span class="sourceLineNo">006</span>import java.util.HashSet;<a name="line.6"></a>
<span class="sourceLineNo">007</span>import java.util.HashMap;<a name="line.7"></a>
<span class="sourceLineNo">008</span>import java.util.Iterator;<a name="line.8"></a>
<span class="sourceLineNo">009</span>import java.util.List;<a name="line.9"></a>
<span class="sourceLineNo">010</span>import java.util.Set;<a name="line.10"></a>
<span class="sourceLineNo">011</span>import java.util.regex.Matcher;<a name="line.11"></a>
<span class="sourceLineNo">012</span>import java.util.regex.Pattern;<a name="line.12"></a>
<span class="sourceLineNo">013</span><a name="line.13"></a>
<span class="sourceLineNo">014</span>import org.cpsolver.coursett.Constants;<a name="line.14"></a>
<span class="sourceLineNo">015</span>import org.cpsolver.coursett.criteria.DistributionPreferences;<a name="line.15"></a>
<span class="sourceLineNo">016</span>import org.cpsolver.coursett.criteria.StudentConflict;<a name="line.16"></a>
<span class="sourceLineNo">017</span>import org.cpsolver.coursett.model.Lecture;<a name="line.17"></a>
<span class="sourceLineNo">018</span>import org.cpsolver.coursett.model.Placement;<a name="line.18"></a>
<span class="sourceLineNo">019</span>import org.cpsolver.coursett.model.RoomLocation;<a name="line.19"></a>
<span class="sourceLineNo">020</span>import org.cpsolver.coursett.model.TimeLocation;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import org.cpsolver.coursett.model.TimeLocation.IntEnumeration;<a name="line.21"></a>
<span class="sourceLineNo">022</span>import org.cpsolver.coursett.model.TimetableModel;<a name="line.22"></a>
<span class="sourceLineNo">023</span>import org.cpsolver.ifs.assignment.Assignment;<a name="line.23"></a>
<span class="sourceLineNo">024</span>import org.cpsolver.ifs.assignment.context.AssignmentConstraintContext;<a name="line.24"></a>
<span class="sourceLineNo">025</span>import org.cpsolver.ifs.assignment.context.ConstraintWithContext;<a name="line.25"></a>
<span class="sourceLineNo">026</span>import org.cpsolver.ifs.model.Constraint;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import org.cpsolver.ifs.model.GlobalConstraint;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import org.cpsolver.ifs.model.Model;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import org.cpsolver.ifs.model.WeakeningConstraint;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import org.cpsolver.ifs.util.DataProperties;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import org.cpsolver.ifs.util.DistanceMetric;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import org.cpsolver.ifs.util.ToolBox;<a name="line.32"></a>
<span class="sourceLineNo">033</span><a name="line.33"></a>
<span class="sourceLineNo">034</span><a name="line.34"></a>
<span class="sourceLineNo">035</span>/**<a name="line.35"></a>
<span class="sourceLineNo">036</span> * Group constraint. &lt;br&gt;<a name="line.36"></a>
<span class="sourceLineNo">037</span> * This constraint expresses relations between several classes, e.g., that two<a name="line.37"></a>
<span class="sourceLineNo">038</span> * sections of the same lecture can not be taught at the same time, or that some<a name="line.38"></a>
<span class="sourceLineNo">039</span> * classes have to be taught one immediately after another. It can be either<a name="line.39"></a>
<span class="sourceLineNo">040</span> * hard or soft. &lt;br&gt;<a name="line.40"></a>
<span class="sourceLineNo">041</span> * &lt;br&gt;<a name="line.41"></a>
<span class="sourceLineNo">042</span> * Following constraints are now supported:<a name="line.42"></a>
<span class="sourceLineNo">043</span> * &lt;table border='1'&gt;&lt;caption&gt;Related Solver Parameters&lt;/caption&gt;<a name="line.43"></a>
<span class="sourceLineNo">044</span> * &lt;tr&gt;<a name="line.44"></a>
<span class="sourceLineNo">045</span> * &lt;th&gt;Constraint&lt;/th&gt;<a name="line.45"></a>
<span class="sourceLineNo">046</span> * &lt;th&gt;Comment&lt;/th&gt;<a name="line.46"></a>
<span class="sourceLineNo">047</span> * &lt;/tr&gt;<a name="line.47"></a>
<span class="sourceLineNo">048</span> * &lt;tr&gt;<a name="line.48"></a>
<span class="sourceLineNo">049</span> * &lt;td&gt;SAME_TIME&lt;/td&gt;<a name="line.49"></a>
<span class="sourceLineNo">050</span> * &lt;td&gt;Same time: given classes have to be taught in the same hours. If the<a name="line.50"></a>
<span class="sourceLineNo">051</span> * classes are of different length, the smaller one cannot start before the<a name="line.51"></a>
<span class="sourceLineNo">052</span> * longer one and it cannot end after the longer one.&lt;/td&gt;<a name="line.52"></a>
<span class="sourceLineNo">053</span> * &lt;/tr&gt;<a name="line.53"></a>
<span class="sourceLineNo">054</span> * &lt;tr&gt;<a name="line.54"></a>
<span class="sourceLineNo">055</span> * &lt;td&gt;SAME_DAYS&lt;/td&gt;<a name="line.55"></a>
<span class="sourceLineNo">056</span> * &lt;td&gt;Same days: given classes have to be taught in the same day. If the<a name="line.56"></a>
<span class="sourceLineNo">057</span> * classes are of different time patterns, the days of one class have to form a<a name="line.57"></a>
<span class="sourceLineNo">058</span> * subset of the days of the other class.&lt;/td&gt;<a name="line.58"></a>
<span class="sourceLineNo">059</span> * &lt;/tr&gt;<a name="line.59"></a>
<span class="sourceLineNo">060</span> * &lt;tr&gt;<a name="line.60"></a>
<span class="sourceLineNo">061</span> * &lt;td&gt;BTB&lt;/td&gt;<a name="line.61"></a>
<span class="sourceLineNo">062</span> * &lt;td&gt;Back-to-back constraint: given classes have to be taught in the same room<a name="line.62"></a>
<span class="sourceLineNo">063</span> * and they have to follow one strictly after another.&lt;/td&gt;<a name="line.63"></a>
<span class="sourceLineNo">064</span> * &lt;/tr&gt;<a name="line.64"></a>
<span class="sourceLineNo">065</span> * &lt;tr&gt;<a name="line.65"></a>
<span class="sourceLineNo">066</span> * &lt;td&gt;BTB_TIME&lt;/td&gt;<a name="line.66"></a>
<span class="sourceLineNo">067</span> * &lt;td&gt;Back-to-back constraint: given classes have to follow one strictly after<a name="line.67"></a>
<span class="sourceLineNo">068</span> * another, but they can be taught in different rooms.&lt;/td&gt;<a name="line.68"></a>
<span class="sourceLineNo">069</span> * &lt;/tr&gt;<a name="line.69"></a>
<span class="sourceLineNo">070</span> * &lt;tr&gt;<a name="line.70"></a>
<span class="sourceLineNo">071</span> * &lt;td&gt;DIFF_TIME&lt;/td&gt;<a name="line.71"></a>
<span class="sourceLineNo">072</span> * &lt;td&gt;Different time: given classes cannot overlap in time.&lt;/td&gt;<a name="line.72"></a>
<span class="sourceLineNo">073</span> * &lt;/tr&gt;<a name="line.73"></a>
<span class="sourceLineNo">074</span> * &lt;tr&gt;<a name="line.74"></a>
<span class="sourceLineNo">075</span> * &lt;td&gt;NHB(1), NHB(1.5), NHB(2), ... NHB(8)&lt;/td&gt;<a name="line.75"></a>
<span class="sourceLineNo">076</span> * &lt;td&gt;Number of hours between: between the given classes, the exact number of<a name="line.76"></a>
<span class="sourceLineNo">077</span> * hours have to be kept.&lt;/td&gt;<a name="line.77"></a>
<span class="sourceLineNo">078</span> * &lt;/tr&gt;<a name="line.78"></a>
<span class="sourceLineNo">079</span> * &lt;tr&gt;<a name="line.79"></a>
<span class="sourceLineNo">080</span> * &lt;td&gt;SAME_START&lt;/td&gt;<a name="line.80"></a>
<span class="sourceLineNo">081</span> * &lt;td&gt;Same starting hour: given classes have to start in the same hour.&lt;/td&gt;<a name="line.81"></a>
<span class="sourceLineNo">082</span> * &lt;/tr&gt;<a name="line.82"></a>
<span class="sourceLineNo">083</span> * &lt;tr&gt;<a name="line.83"></a>
<span class="sourceLineNo">084</span> * &lt;td&gt;SAME_ROOM&lt;/td&gt;<a name="line.84"></a>
<span class="sourceLineNo">085</span> * &lt;td&gt;Same room: given classes have to be placed in the same room.&lt;/td&gt;<a name="line.85"></a>
<span class="sourceLineNo">086</span> * &lt;/tr&gt;<a name="line.86"></a>
<span class="sourceLineNo">087</span> * &lt;tr&gt;<a name="line.87"></a>
<span class="sourceLineNo">088</span> * &lt;td&gt;NHB_GTE(1)&lt;/td&gt;<a name="line.88"></a>
<span class="sourceLineNo">089</span> * &lt;td&gt;Greater than or equal to 1 hour between: between the given classes, the<a name="line.89"></a>
<span class="sourceLineNo">090</span> * number of hours have to be one or more.&lt;/td&gt;<a name="line.90"></a>
<span class="sourceLineNo">091</span> * &lt;/tr&gt;<a name="line.91"></a>
<span class="sourceLineNo">092</span> * &lt;tr&gt;<a name="line.92"></a>
<span class="sourceLineNo">093</span> * &lt;td&gt;NHB_LT(6)&lt;/td&gt;<a name="line.93"></a>
<span class="sourceLineNo">094</span> * &lt;td&gt;Less than 6 hours between: between the given classes, the number of hours<a name="line.94"></a>
<span class="sourceLineNo">095</span> * have to be less than six.&lt;/td&gt;<a name="line.95"></a>
<span class="sourceLineNo">096</span> * &lt;/tr&gt;<a name="line.96"></a>
<span class="sourceLineNo">097</span> * &lt;/table&gt;<a name="line.97"></a>
<span class="sourceLineNo">098</span> * <a name="line.98"></a>
<span class="sourceLineNo">099</span> * @author  Tom&#225;&#353; M&#252;ller<a name="line.99"></a>
<span class="sourceLineNo">100</span> * @version CourseTT 1.3 (University Course Timetabling)&lt;br&gt;<a name="line.100"></a>
<span class="sourceLineNo">101</span> *          Copyright (C) 2006 - 2014 Tom&#225;&#353; M&#252;ller&lt;br&gt;<a name="line.101"></a>
<span class="sourceLineNo">102</span> *          &lt;a href="mailto:muller@unitime.org"&gt;muller@unitime.org&lt;/a&gt;&lt;br&gt;<a name="line.102"></a>
<span class="sourceLineNo">103</span> *          &lt;a href="http://muller.unitime.org"&gt;http://muller.unitime.org&lt;/a&gt;&lt;br&gt;<a name="line.103"></a>
<span class="sourceLineNo">104</span> * &lt;br&gt;<a name="line.104"></a>
<span class="sourceLineNo">105</span> *          This library is free software; you can redistribute it and/or modify<a name="line.105"></a>
<span class="sourceLineNo">106</span> *          it under the terms of the GNU Lesser General Public License as<a name="line.106"></a>
<span class="sourceLineNo">107</span> *          published by the Free Software Foundation; either version 3 of the<a name="line.107"></a>
<span class="sourceLineNo">108</span> *          License, or (at your option) any later version. &lt;br&gt;<a name="line.108"></a>
<span class="sourceLineNo">109</span> * &lt;br&gt;<a name="line.109"></a>
<span class="sourceLineNo">110</span> *          This library is distributed in the hope that it will be useful, but<a name="line.110"></a>
<span class="sourceLineNo">111</span> *          WITHOUT ANY WARRANTY; without even the implied warranty of<a name="line.111"></a>
<span class="sourceLineNo">112</span> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU<a name="line.112"></a>
<span class="sourceLineNo">113</span> *          Lesser General Public License for more details. &lt;br&gt;<a name="line.113"></a>
<span class="sourceLineNo">114</span> * &lt;br&gt;<a name="line.114"></a>
<span class="sourceLineNo">115</span> *          You should have received a copy of the GNU Lesser General Public<a name="line.115"></a>
<span class="sourceLineNo">116</span> *          License along with this library; if not see<a name="line.116"></a>
<span class="sourceLineNo">117</span> *          &lt;a href='http://www.gnu.org/licenses/'&gt;http://www.gnu.org/licenses/&lt;/a&gt;.<a name="line.117"></a>
<span class="sourceLineNo">118</span> */<a name="line.118"></a>
<span class="sourceLineNo">119</span>public class GroupConstraint extends ConstraintWithContext&lt;Lecture, Placement, GroupConstraint.GroupConstraintContext&gt; {<a name="line.119"></a>
<span class="sourceLineNo">120</span>    private Long iConstraintId;<a name="line.120"></a>
<span class="sourceLineNo">121</span>    private int iPreference;<a name="line.121"></a>
<span class="sourceLineNo">122</span>    private ConstraintTypeInterface iType;<a name="line.122"></a>
<span class="sourceLineNo">123</span>    private boolean iIsRequired;<a name="line.123"></a>
<span class="sourceLineNo">124</span>    private boolean iIsProhibited;<a name="line.124"></a>
<span class="sourceLineNo">125</span>    private int iDayOfWeekOffset = 0;<a name="line.125"></a>
<span class="sourceLineNo">126</span>    private boolean iPrecedenceConsiderDatePatterns = true;<a name="line.126"></a>
<span class="sourceLineNo">127</span>    private boolean iPrecedenceSkipSameDatePatternCheck = true;<a name="line.127"></a>
<span class="sourceLineNo">128</span>    private boolean iMaxNHoursADayConsiderDatePatterns = true;<a name="line.128"></a>
<span class="sourceLineNo">129</span>    private boolean iMaxNHoursADayPrecideComputation = false;<a name="line.129"></a>
<span class="sourceLineNo">130</span>    private int iForwardCheckMaxDepth = 2;<a name="line.130"></a>
<span class="sourceLineNo">131</span>    private int iForwardCheckMaxDomainSize = 1000;<a name="line.131"></a>
<span class="sourceLineNo">132</span>    private int iNrWorkDays = 5;<a name="line.132"></a>
<span class="sourceLineNo">133</span>    private int iFirstWorkDay = 0;<a name="line.133"></a>
<span class="sourceLineNo">134</span>    private String iOnlineRoom = null;<a name="line.134"></a>
<span class="sourceLineNo">135</span>    <a name="line.135"></a>
<span class="sourceLineNo">136</span>    /**<a name="line.136"></a>
<span class="sourceLineNo">137</span>     * Group constraints that can be checked on pairs of classes (e.g., same room means any two classes are in the same room),<a name="line.137"></a>
<span class="sourceLineNo">138</span>     * only need to implement this interface.<a name="line.138"></a>
<span class="sourceLineNo">139</span>     */<a name="line.139"></a>
<span class="sourceLineNo">140</span>    public static interface PairCheck {<a name="line.140"></a>
<span class="sourceLineNo">141</span>        /**<a name="line.141"></a>
<span class="sourceLineNo">142</span>         * Check whether the constraint is satisfied for the given two assignments (required / preferred case)<a name="line.142"></a>
<span class="sourceLineNo">143</span>         * @param gc Calling group constraint <a name="line.143"></a>
<span class="sourceLineNo">144</span>         * @param plc1 First placement<a name="line.144"></a>
<span class="sourceLineNo">145</span>         * @param plc2 Second placement<a name="line.145"></a>
<span class="sourceLineNo">146</span>         * @return true if constraint is satisfied<a name="line.146"></a>
<span class="sourceLineNo">147</span>         */<a name="line.147"></a>
<span class="sourceLineNo">148</span>        public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.148"></a>
<span class="sourceLineNo">149</span>        /**<a name="line.149"></a>
<span class="sourceLineNo">150</span>         * Check whether the constraint is satisfied for the given two assignments (prohibited / discouraged case)<a name="line.150"></a>
<span class="sourceLineNo">151</span>         * @param gc Calling group constraint <a name="line.151"></a>
<span class="sourceLineNo">152</span>         * @param plc1 First placement<a name="line.152"></a>
<span class="sourceLineNo">153</span>         * @param plc2 Second placement<a name="line.153"></a>
<span class="sourceLineNo">154</span>         * @return true if constraint is satisfied<a name="line.154"></a>
<span class="sourceLineNo">155</span>         */<a name="line.155"></a>
<span class="sourceLineNo">156</span>        public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.156"></a>
<span class="sourceLineNo">157</span>    }<a name="line.157"></a>
<span class="sourceLineNo">158</span>    <a name="line.158"></a>
<span class="sourceLineNo">159</span>    /**<a name="line.159"></a>
<span class="sourceLineNo">160</span>     * Group constraints that can be checked on pairs of classes (e.g., same room means any two classes are in the same room),<a name="line.160"></a>
<span class="sourceLineNo">161</span>     * only need to implement this interface. Unlike {@link PairCheck}, this check is also given current assignment.<a name="line.161"></a>
<span class="sourceLineNo">162</span>     */<a name="line.162"></a>
<span class="sourceLineNo">163</span>    public static interface AssignmentPairCheck {<a name="line.163"></a>
<span class="sourceLineNo">164</span>        /**<a name="line.164"></a>
<span class="sourceLineNo">165</span>         * Check whether the constraint is satisfied for the given two assignments (required / preferred case)<a name="line.165"></a>
<span class="sourceLineNo">166</span>         * @param assignment current assignment<a name="line.166"></a>
<span class="sourceLineNo">167</span>         * @param gc Calling group constraint <a name="line.167"></a>
<span class="sourceLineNo">168</span>         * @param plc1 First placement<a name="line.168"></a>
<span class="sourceLineNo">169</span>         * @param plc2 Second placement<a name="line.169"></a>
<span class="sourceLineNo">170</span>         * @return true if constraint is satisfied<a name="line.170"></a>
<span class="sourceLineNo">171</span>         */<a name="line.171"></a>
<span class="sourceLineNo">172</span>        public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.172"></a>
<span class="sourceLineNo">173</span>        /**<a name="line.173"></a>
<span class="sourceLineNo">174</span>         * Check whether the constraint is satisfied for the given two assignments (prohibited / discouraged case)<a name="line.174"></a>
<span class="sourceLineNo">175</span>         * @param assignment current assignment<a name="line.175"></a>
<span class="sourceLineNo">176</span>         * @param gc Calling group constraint <a name="line.176"></a>
<span class="sourceLineNo">177</span>         * @param plc1 First placement<a name="line.177"></a>
<span class="sourceLineNo">178</span>         * @param plc2 Second placement<a name="line.178"></a>
<span class="sourceLineNo">179</span>         * @return true if constraint is satisfied<a name="line.179"></a>
<span class="sourceLineNo">180</span>         */<a name="line.180"></a>
<span class="sourceLineNo">181</span>        public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.181"></a>
<span class="sourceLineNo">182</span>    }<a name="line.182"></a>
<span class="sourceLineNo">183</span>    <a name="line.183"></a>
<span class="sourceLineNo">184</span>    /**<a name="line.184"></a>
<span class="sourceLineNo">185</span>     * Group constraints that can have parameters need to implement this interface instead of {@link AssignmentPairCheck} or {@link PairCheck}.<a name="line.185"></a>
<span class="sourceLineNo">186</span>     */<a name="line.186"></a>
<span class="sourceLineNo">187</span>    public static interface AssignmentParameterPairCheck&lt;P&gt; {<a name="line.187"></a>
<span class="sourceLineNo">188</span>        /**<a name="line.188"></a>
<span class="sourceLineNo">189</span>         * Check whether the constraint is satisfied for the given two assignments (required / preferred case)<a name="line.189"></a>
<span class="sourceLineNo">190</span>         * @param assignment current assignment<a name="line.190"></a>
<span class="sourceLineNo">191</span>         * @param parameter constraint dependent parameter(s)<a name="line.191"></a>
<span class="sourceLineNo">192</span>         * @param gc Calling group constraint <a name="line.192"></a>
<span class="sourceLineNo">193</span>         * @param plc1 First placement<a name="line.193"></a>
<span class="sourceLineNo">194</span>         * @param plc2 Second placement<a name="line.194"></a>
<span class="sourceLineNo">195</span>         * @return true if constraint is satisfied<a name="line.195"></a>
<span class="sourceLineNo">196</span>         */<a name="line.196"></a>
<span class="sourceLineNo">197</span>        public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, P parameter, GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.197"></a>
<span class="sourceLineNo">198</span>        /**<a name="line.198"></a>
<span class="sourceLineNo">199</span>         * Check whether the constraint is satisfied for the given two assignments (prohibited / discouraged case)<a name="line.199"></a>
<span class="sourceLineNo">200</span>         * @param assignment current assignment<a name="line.200"></a>
<span class="sourceLineNo">201</span>         * @param parameter constraint dependent parameter(s)<a name="line.201"></a>
<span class="sourceLineNo">202</span>         * @param gc Calling group constraint <a name="line.202"></a>
<span class="sourceLineNo">203</span>         * @param plc1 First placement<a name="line.203"></a>
<span class="sourceLineNo">204</span>         * @param plc2 Second placement<a name="line.204"></a>
<span class="sourceLineNo">205</span>         * @return true if constraint is satisfied<a name="line.205"></a>
<span class="sourceLineNo">206</span>         */<a name="line.206"></a>
<span class="sourceLineNo">207</span>        public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, P parameter, GroupConstraint gc, Placement plc1, Placement plc2);<a name="line.207"></a>
<span class="sourceLineNo">208</span>        <a name="line.208"></a>
<span class="sourceLineNo">209</span>        /**<a name="line.209"></a>
<span class="sourceLineNo">210</span>         * Create constraint type with the parameters taken from the provided reference<a name="line.210"></a>
<span class="sourceLineNo">211</span>         * @param reference constraint reference, including parameter(s)<a name="line.211"></a>
<span class="sourceLineNo">212</span>         * @param referenceRegExp reference regular expression defined on the constraint type<a name="line.212"></a>
<span class="sourceLineNo">213</span>         * @return constraint type with the parameter<a name="line.213"></a>
<span class="sourceLineNo">214</span>         */<a name="line.214"></a>
<span class="sourceLineNo">215</span>        public ParametrizedConstraintType&lt;P&gt; create(String reference, String referenceRegExp);<a name="line.215"></a>
<span class="sourceLineNo">216</span>    }<a name="line.216"></a>
<span class="sourceLineNo">217</span>    <a name="line.217"></a>
<span class="sourceLineNo">218</span>    /**<a name="line.218"></a>
<span class="sourceLineNo">219</span>     * Group constraint building blocks (individual constraints that need more than {@link PairCheck})<a name="line.219"></a>
<span class="sourceLineNo">220</span>     */<a name="line.220"></a>
<span class="sourceLineNo">221</span>    public static enum Flag {<a name="line.221"></a>
<span class="sourceLineNo">222</span>        /** Back-to-back constraint (sequence check) */<a name="line.222"></a>
<span class="sourceLineNo">223</span>        BACK_TO_BACK,<a name="line.223"></a>
<span class="sourceLineNo">224</span>        /** Can share room flag */<a name="line.224"></a>
<span class="sourceLineNo">225</span>        CAN_SHARE_ROOM,<a name="line.225"></a>
<span class="sourceLineNo">226</span>        /** Maximum hours a day (number of slots a day check) */<a name="line.226"></a>
<span class="sourceLineNo">227</span>        MAX_HRS_DAY,<a name="line.227"></a>
<span class="sourceLineNo">228</span>        /** Children cannot overlap */<a name="line.228"></a>
<span class="sourceLineNo">229</span>        CH_NOTOVERLAP,<a name="line.229"></a>
<span class="sourceLineNo">230</span>        /** Ignore student conflicts */<a name="line.230"></a>
<span class="sourceLineNo">231</span>        IGNORE_STUDENTS,<a name="line.231"></a>
<span class="sourceLineNo">232</span>        ;<a name="line.232"></a>
<span class="sourceLineNo">233</span>        /** Bit number (to combine flags) */<a name="line.233"></a>
<span class="sourceLineNo">234</span>        int flag() { return 1 &lt;&lt; ordinal(); }<a name="line.234"></a>
<span class="sourceLineNo">235</span>    }<a name="line.235"></a>
<span class="sourceLineNo">236</span>    <a name="line.236"></a>
<span class="sourceLineNo">237</span>    /**<a name="line.237"></a>
<span class="sourceLineNo">238</span>     * Constraint type interface<a name="line.238"></a>
<span class="sourceLineNo">239</span>     */<a name="line.239"></a>
<span class="sourceLineNo">240</span>    public static interface ConstraintTypeInterface extends AssignmentPairCheck {<a name="line.240"></a>
<span class="sourceLineNo">241</span>        /** Constraint type<a name="line.241"></a>
<span class="sourceLineNo">242</span>         * @return constraint type<a name="line.242"></a>
<span class="sourceLineNo">243</span>         */<a name="line.243"></a>
<span class="sourceLineNo">244</span>        public ConstraintType type();<a name="line.244"></a>
<span class="sourceLineNo">245</span>        <a name="line.245"></a>
<span class="sourceLineNo">246</span>        /** Constraint reference<a name="line.246"></a>
<span class="sourceLineNo">247</span>         * @return constraint reference<a name="line.247"></a>
<span class="sourceLineNo">248</span>         **/<a name="line.248"></a>
<span class="sourceLineNo">249</span>        public String reference();<a name="line.249"></a>
<span class="sourceLineNo">250</span>        <a name="line.250"></a>
<span class="sourceLineNo">251</span>        /** Constraint name<a name="line.251"></a>
<span class="sourceLineNo">252</span>         * @return constraint name<a name="line.252"></a>
<span class="sourceLineNo">253</span>         **/<a name="line.253"></a>
<span class="sourceLineNo">254</span>        public String getName();<a name="line.254"></a>
<span class="sourceLineNo">255</span>        <a name="line.255"></a>
<span class="sourceLineNo">256</span>        /** Minimum (gap) parameter<a name="line.256"></a>
<span class="sourceLineNo">257</span>         * @return minimum gap (first constraint parameter)<a name="line.257"></a>
<span class="sourceLineNo">258</span>         **/<a name="line.258"></a>
<span class="sourceLineNo">259</span>        public int getMin();<a name="line.259"></a>
<span class="sourceLineNo">260</span>        <a name="line.260"></a>
<span class="sourceLineNo">261</span>        /** Maximum (gap, hours a day) parameter <a name="line.261"></a>
<span class="sourceLineNo">262</span>         * @return maximum gap (second constraint parameter) <a name="line.262"></a>
<span class="sourceLineNo">263</span>         **/<a name="line.263"></a>
<span class="sourceLineNo">264</span>        public int getMax();<a name="line.264"></a>
<span class="sourceLineNo">265</span>        <a name="line.265"></a>
<span class="sourceLineNo">266</span>        /** Flag check (true if contains given flag) <a name="line.266"></a>
<span class="sourceLineNo">267</span>         * @param f a flag to check<a name="line.267"></a>
<span class="sourceLineNo">268</span>         * @return true if present<a name="line.268"></a>
<span class="sourceLineNo">269</span>         **/<a name="line.269"></a>
<span class="sourceLineNo">270</span>        public boolean is(Flag f);<a name="line.270"></a>
<span class="sourceLineNo">271</span>    }<a name="line.271"></a>
<span class="sourceLineNo">272</span>    <a name="line.272"></a>
<span class="sourceLineNo">273</span>    /**<a name="line.273"></a>
<span class="sourceLineNo">274</span>     * Constraint type with a parameter<a name="line.274"></a>
<span class="sourceLineNo">275</span>     */<a name="line.275"></a>
<span class="sourceLineNo">276</span>    public static class ParametrizedConstraintType&lt;P&gt; implements ConstraintTypeInterface {<a name="line.276"></a>
<span class="sourceLineNo">277</span>        private String iReference;<a name="line.277"></a>
<span class="sourceLineNo">278</span>        private ConstraintType iType;<a name="line.278"></a>
<span class="sourceLineNo">279</span>        private Integer iMin = null, iMax = null;<a name="line.279"></a>
<span class="sourceLineNo">280</span>        private String iName = null;<a name="line.280"></a>
<span class="sourceLineNo">281</span>        private P iParameter;<a name="line.281"></a>
<span class="sourceLineNo">282</span>        <a name="line.282"></a>
<span class="sourceLineNo">283</span>        /**<a name="line.283"></a>
<span class="sourceLineNo">284</span>         * Constructor<a name="line.284"></a>
<span class="sourceLineNo">285</span>         * @param type constraint type<a name="line.285"></a>
<span class="sourceLineNo">286</span>         * @param parameter parameter parsed from the reference using {@link AssignmentParameterPairCheck#create(String, String)}<a name="line.286"></a>
<span class="sourceLineNo">287</span>         * @param reference constraint reference with parameters<a name="line.287"></a>
<span class="sourceLineNo">288</span>         */<a name="line.288"></a>
<span class="sourceLineNo">289</span>        public ParametrizedConstraintType(ConstraintType type, P parameter, String reference) {<a name="line.289"></a>
<span class="sourceLineNo">290</span>            iType = type; iParameter = parameter; iReference = reference;<a name="line.290"></a>
<span class="sourceLineNo">291</span>        }<a name="line.291"></a>
<span class="sourceLineNo">292</span><a name="line.292"></a>
<span class="sourceLineNo">293</span>        @Override<a name="line.293"></a>
<span class="sourceLineNo">294</span>        @SuppressWarnings("unchecked")<a name="line.294"></a>
<span class="sourceLineNo">295</span>        public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.295"></a>
<span class="sourceLineNo">296</span>            return ((AssignmentParameterPairCheck&lt;P&gt;)iType.iAssignmentPairCheck).isSatisfied(assignment, iParameter, gc, plc1, plc2);<a name="line.296"></a>
<span class="sourceLineNo">297</span>        }<a name="line.297"></a>
<span class="sourceLineNo">298</span><a name="line.298"></a>
<span class="sourceLineNo">299</span>        @Override<a name="line.299"></a>
<span class="sourceLineNo">300</span>        @SuppressWarnings("unchecked")<a name="line.300"></a>
<span class="sourceLineNo">301</span>        public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.301"></a>
<span class="sourceLineNo">302</span>            return ((AssignmentParameterPairCheck&lt;P&gt;)iType.iAssignmentPairCheck).isViolated(assignment, iParameter, gc, plc1, plc2);<a name="line.302"></a>
<span class="sourceLineNo">303</span>        }<a name="line.303"></a>
<span class="sourceLineNo">304</span><a name="line.304"></a>
<span class="sourceLineNo">305</span>        /**<a name="line.305"></a>
<span class="sourceLineNo">306</span>         * Return constraint's parameter<a name="line.306"></a>
<span class="sourceLineNo">307</span>         * @return constraint's parameter<a name="line.307"></a>
<span class="sourceLineNo">308</span>         */<a name="line.308"></a>
<span class="sourceLineNo">309</span>        public P getParameter() { return iParameter; }<a name="line.309"></a>
<span class="sourceLineNo">310</span>        @Override<a name="line.310"></a>
<span class="sourceLineNo">311</span>        public ConstraintType type() { return iType; }<a name="line.311"></a>
<span class="sourceLineNo">312</span>        @Override<a name="line.312"></a>
<span class="sourceLineNo">313</span>        public String reference() { return iReference; }<a name="line.313"></a>
<span class="sourceLineNo">314</span>        @Override<a name="line.314"></a>
<span class="sourceLineNo">315</span>        public String getName() { return (iName == null ? iType.getName() : iName); }<a name="line.315"></a>
<span class="sourceLineNo">316</span>        @Override<a name="line.316"></a>
<span class="sourceLineNo">317</span>        public int getMin() { return (iMin == null ? iType.getMin() : iMin); }<a name="line.317"></a>
<span class="sourceLineNo">318</span>        @Override<a name="line.318"></a>
<span class="sourceLineNo">319</span>        public int getMax() { return (iMax == null ? iType.getMax() : iMax); }<a name="line.319"></a>
<span class="sourceLineNo">320</span>        @Override<a name="line.320"></a>
<span class="sourceLineNo">321</span>        public boolean is(Flag f) { return iType.is(f); }<a name="line.321"></a>
<span class="sourceLineNo">322</span>        public ParametrizedConstraintType&lt;P&gt; setMin(int min) { iMin = min; return this; }<a name="line.322"></a>
<span class="sourceLineNo">323</span>        public ParametrizedConstraintType&lt;P&gt; setMax(int max) { iMax = max; return this; }<a name="line.323"></a>
<span class="sourceLineNo">324</span>        public ParametrizedConstraintType&lt;P&gt; setName(String name) { iName = name; return this; }<a name="line.324"></a>
<span class="sourceLineNo">325</span>    }<a name="line.325"></a>
<span class="sourceLineNo">326</span>    <a name="line.326"></a>
<span class="sourceLineNo">327</span>    /**<a name="line.327"></a>
<span class="sourceLineNo">328</span>     * Group constraint type.<a name="line.328"></a>
<span class="sourceLineNo">329</span>     */<a name="line.329"></a>
<span class="sourceLineNo">330</span>    public static enum ConstraintType implements ConstraintTypeInterface {<a name="line.330"></a>
<span class="sourceLineNo">331</span>        /**<a name="line.331"></a>
<span class="sourceLineNo">332</span>         * Same Time: Given classes must be taught at the same time of day (independent of the actual day the classes meet).<a name="line.332"></a>
<span class="sourceLineNo">333</span>         * For the classes of the same length, this is the same constraint as same start. For classes of different length,<a name="line.333"></a>
<span class="sourceLineNo">334</span>         * the shorter one cannot start before, nor end after, the longer one.&lt;BR&gt;<a name="line.334"></a>
<span class="sourceLineNo">335</span>         * When prohibited or (strongly) discouraged: one class may not meet on any day at a time of day that overlaps with<a name="line.335"></a>
<span class="sourceLineNo">336</span>         * that of the other. For example, one class can not meet M 7:30 while the other meets F 7:30. Note the difference<a name="line.336"></a>
<span class="sourceLineNo">337</span>         * here from the different time constraint that only prohibits the actual class meetings from overlapping.<a name="line.337"></a>
<span class="sourceLineNo">338</span>         */<a name="line.338"></a>
<span class="sourceLineNo">339</span>        SAME_TIME("SAME_TIME", "Same Time", new PairCheck() {<a name="line.339"></a>
<span class="sourceLineNo">340</span>            @Override<a name="line.340"></a>
<span class="sourceLineNo">341</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.341"></a>
<span class="sourceLineNo">342</span>                return sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(),<a name="line.342"></a>
<span class="sourceLineNo">343</span>                        plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength());<a name="line.343"></a>
<span class="sourceLineNo">344</span>            }<a name="line.344"></a>
<span class="sourceLineNo">345</span>            @Override<a name="line.345"></a>
<span class="sourceLineNo">346</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.346"></a>
<span class="sourceLineNo">347</span>                return !(plc1.getTimeLocation().shareHours(plc2.getTimeLocation()));<a name="line.347"></a>
<span class="sourceLineNo">348</span>            }}),<a name="line.348"></a>
<span class="sourceLineNo">349</span>        /**<a name="line.349"></a>
<span class="sourceLineNo">350</span>         * Same Days: Given classes must be taught on the same days. In case of classes of different time patterns, a class<a name="line.350"></a>
<span class="sourceLineNo">351</span>         * with fewer meetings must meet on a subset of the days used by the class with more meetings. For example, if one<a name="line.351"></a>
<span class="sourceLineNo">352</span>         * class pattern is 3x50, all others given in the constraint can only be taught on Monday, Wednesday, or Friday.<a name="line.352"></a>
<span class="sourceLineNo">353</span>         * For a 2x100 class MW, MF, WF is allowed but TTh is prohibited.&lt;BR&gt;<a name="line.353"></a>
<span class="sourceLineNo">354</span>         * When prohibited or (strongly) discouraged: any pair of classes classes cannot be taught on the same days (cannot<a name="line.354"></a>
<span class="sourceLineNo">355</span>         *  overlap in days). For instance, if one class is MFW, the second has to be TTh.<a name="line.355"></a>
<span class="sourceLineNo">356</span>         */<a name="line.356"></a>
<span class="sourceLineNo">357</span>        SAME_DAYS("SAME_DAYS", "Same Days", new PairCheck() {<a name="line.357"></a>
<span class="sourceLineNo">358</span>            @Override<a name="line.358"></a>
<span class="sourceLineNo">359</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.359"></a>
<span class="sourceLineNo">360</span>                return sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.360"></a>
<span class="sourceLineNo">361</span>            }<a name="line.361"></a>
<span class="sourceLineNo">362</span>            @Override<a name="line.362"></a>
<span class="sourceLineNo">363</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.363"></a>
<span class="sourceLineNo">364</span>                return !plc1.getTimeLocation().shareDays(plc2.getTimeLocation());<a name="line.364"></a>
<span class="sourceLineNo">365</span>            }}),<a name="line.365"></a>
<span class="sourceLineNo">366</span>        /**<a name="line.366"></a>
<span class="sourceLineNo">367</span>         * Back-To-Back &amp;amp; Same Room: Classes must be offered in adjacent time segments and must be placed in the same room.<a name="line.367"></a>
<span class="sourceLineNo">368</span>         * Given classes must also be taught on the same days.&lt;BR&gt;<a name="line.368"></a>
<span class="sourceLineNo">369</span>         * When prohibited or (strongly) discouraged: classes cannot be back-to-back. There must be at least half-hour<a name="line.369"></a>
<span class="sourceLineNo">370</span>         * between these classes, and they must be taught on the same days and in the same room.<a name="line.370"></a>
<span class="sourceLineNo">371</span>         */<a name="line.371"></a>
<span class="sourceLineNo">372</span>        BTB("BTB", "Back-To-Back &amp; Same Room", new PairCheck() {<a name="line.372"></a>
<span class="sourceLineNo">373</span>            @Override<a name="line.373"></a>
<span class="sourceLineNo">374</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.374"></a>
<span class="sourceLineNo">375</span>                return<a name="line.375"></a>
<span class="sourceLineNo">376</span>                    plc1.sameRooms(plc2) &amp;&amp;<a name="line.376"></a>
<span class="sourceLineNo">377</span>                    sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.377"></a>
<span class="sourceLineNo">378</span>            }<a name="line.378"></a>
<span class="sourceLineNo">379</span>            @Override<a name="line.379"></a>
<span class="sourceLineNo">380</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.380"></a>
<span class="sourceLineNo">381</span>                return<a name="line.381"></a>
<span class="sourceLineNo">382</span>                    plc1.sameRooms(plc2) &amp;&amp;<a name="line.382"></a>
<span class="sourceLineNo">383</span>                    sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.383"></a>
<span class="sourceLineNo">384</span>            }}, Flag.BACK_TO_BACK),<a name="line.384"></a>
<span class="sourceLineNo">385</span>        /**<a name="line.385"></a>
<span class="sourceLineNo">386</span>         * Back-To-Back: Classes must be offered in adjacent time segments but may be placed in different rooms. Given classes<a name="line.386"></a>
<span class="sourceLineNo">387</span>         * must also be taught on the same days.&lt;BR&gt;<a name="line.387"></a>
<span class="sourceLineNo">388</span>         * When prohibited or (strongly) discouraged: no pair of classes can be taught back-to-back. They may not overlap in time,<a name="line.388"></a>
<span class="sourceLineNo">389</span>         * but must be taught on the same days. This means that there must be at least half-hour between these classes. <a name="line.389"></a>
<span class="sourceLineNo">390</span>         */<a name="line.390"></a>
<span class="sourceLineNo">391</span>        BTB_TIME("BTB_TIME", "Back-To-Back", new PairCheck() {<a name="line.391"></a>
<span class="sourceLineNo">392</span>            @Override<a name="line.392"></a>
<span class="sourceLineNo">393</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.393"></a>
<span class="sourceLineNo">394</span>                return sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.394"></a>
<span class="sourceLineNo">395</span>            }<a name="line.395"></a>
<span class="sourceLineNo">396</span>            @Override<a name="line.396"></a>
<span class="sourceLineNo">397</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.397"></a>
<span class="sourceLineNo">398</span>                return sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.398"></a>
<span class="sourceLineNo">399</span>            }}, Flag.BACK_TO_BACK),<a name="line.399"></a>
<span class="sourceLineNo">400</span>        /**<a name="line.400"></a>
<span class="sourceLineNo">401</span>         * Different Time: Given classes cannot overlap in time. They may be taught at the same time of day if they are on<a name="line.401"></a>
<span class="sourceLineNo">402</span>         * different days. For instance, MF 7:30 is compatible with TTh 7:30.&lt;BR&gt;<a name="line.402"></a>
<span class="sourceLineNo">403</span>         * When prohibited or (strongly) discouraged: every pair of classes in the constraint must overlap in time. <a name="line.403"></a>
<span class="sourceLineNo">404</span>         */<a name="line.404"></a>
<span class="sourceLineNo">405</span>        DIFF_TIME("DIFF_TIME", "Different Time", new PairCheck() {<a name="line.405"></a>
<span class="sourceLineNo">406</span>            @Override<a name="line.406"></a>
<span class="sourceLineNo">407</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.407"></a>
<span class="sourceLineNo">408</span>                return !plc1.getTimeLocation().hasIntersection(plc2.getTimeLocation());<a name="line.408"></a>
<span class="sourceLineNo">409</span>            }<a name="line.409"></a>
<span class="sourceLineNo">410</span>            @Override<a name="line.410"></a>
<span class="sourceLineNo">411</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.411"></a>
<span class="sourceLineNo">412</span>                return plc1.getTimeLocation().hasIntersection(plc2.getTimeLocation());<a name="line.412"></a>
<span class="sourceLineNo">413</span>            }}),<a name="line.413"></a>
<span class="sourceLineNo">414</span>        /**<a name="line.414"></a>
<span class="sourceLineNo">415</span>         * 1 Hour Between: Given classes must have exactly 1 hour in between the end of one and the beginning of another.<a name="line.415"></a>
<span class="sourceLineNo">416</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.416"></a>
<span class="sourceLineNo">417</span>         * When prohibited or (strongly) discouraged: classes can not have 1 hour in between. They may not overlap in time<a name="line.417"></a>
<span class="sourceLineNo">418</span>         * but must be taught on the same days.<a name="line.418"></a>
<span class="sourceLineNo">419</span>         */<a name="line.419"></a>
<span class="sourceLineNo">420</span>        NHB_1("NHB(1)", "1 Hour Between", 10, 12, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.420"></a>
<span class="sourceLineNo">421</span>        /**<a name="line.421"></a>
<span class="sourceLineNo">422</span>         * 2 Hours Between: Given classes must have exactly 2 hours in between the end of one and the beginning of another.<a name="line.422"></a>
<span class="sourceLineNo">423</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.423"></a>
<span class="sourceLineNo">424</span>         * When prohibited or (strongly) discouraged: classes can not have 2 hours in between. They may not overlap in time<a name="line.424"></a>
<span class="sourceLineNo">425</span>         * but must be taught on the same days.<a name="line.425"></a>
<span class="sourceLineNo">426</span>         */<a name="line.426"></a>
<span class="sourceLineNo">427</span>        NHB_2("NHB(2)", "2 Hours Between", 20, 24, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.427"></a>
<span class="sourceLineNo">428</span>        /**<a name="line.428"></a>
<span class="sourceLineNo">429</span>         * 3 Hours Between: Given classes must have exactly 3 hours in between the end of one and the beginning of another.<a name="line.429"></a>
<span class="sourceLineNo">430</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.430"></a>
<span class="sourceLineNo">431</span>         * When prohibited or (strongly) discouraged: classes can not have 3 hours in between. They may not overlap in time<a name="line.431"></a>
<span class="sourceLineNo">432</span>         * but must be taught on the same days.<a name="line.432"></a>
<span class="sourceLineNo">433</span>         */<a name="line.433"></a>
<span class="sourceLineNo">434</span>        NHB_3("NHB(3)", "3 Hours Between", 30, 36, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.434"></a>
<span class="sourceLineNo">435</span>        /**<a name="line.435"></a>
<span class="sourceLineNo">436</span>         * 4 Hours Between: Given classes must have exactly 4 hours in between the end of one and the beginning of another.<a name="line.436"></a>
<span class="sourceLineNo">437</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.437"></a>
<span class="sourceLineNo">438</span>         * When prohibited or (strongly) discouraged: classes can not have 4 hours in between. They may not overlap in time<a name="line.438"></a>
<span class="sourceLineNo">439</span>         * but must be taught on the same days.<a name="line.439"></a>
<span class="sourceLineNo">440</span>         */<a name="line.440"></a>
<span class="sourceLineNo">441</span>        NHB_4("NHB(4)", "4 Hours Between", 40, 48, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.441"></a>
<span class="sourceLineNo">442</span>        /**<a name="line.442"></a>
<span class="sourceLineNo">443</span>         * 5 Hours Between: Given classes must have exactly 5 hours in between the end of one and the beginning of another.<a name="line.443"></a>
<span class="sourceLineNo">444</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.444"></a>
<span class="sourceLineNo">445</span>         * When prohibited or (strongly) discouraged: classes can not have 5 hours in between. They may not overlap in time<a name="line.445"></a>
<span class="sourceLineNo">446</span>         * but must be taught on the same days.<a name="line.446"></a>
<span class="sourceLineNo">447</span>         */<a name="line.447"></a>
<span class="sourceLineNo">448</span>        NHB_5("NHB(5)", "5 Hours Between", 50, 60, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.448"></a>
<span class="sourceLineNo">449</span>        /**<a name="line.449"></a>
<span class="sourceLineNo">450</span>         * 6 Hours Between: Given classes must have exactly 6 hours in between the end of one and the beginning of another.<a name="line.450"></a>
<span class="sourceLineNo">451</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.451"></a>
<span class="sourceLineNo">452</span>         * When prohibited or (strongly) discouraged: classes can not have 6 hours in between. They may not overlap in time<a name="line.452"></a>
<span class="sourceLineNo">453</span>         * but must be taught on the same days.<a name="line.453"></a>
<span class="sourceLineNo">454</span>         */<a name="line.454"></a>
<span class="sourceLineNo">455</span>        NHB_6("NHB(6)", "6 Hours Between", 60, 72, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.455"></a>
<span class="sourceLineNo">456</span>        /**<a name="line.456"></a>
<span class="sourceLineNo">457</span>         * 7 Hours Between: Given classes must have exactly 7 hours in between the end of one and the beginning of another.<a name="line.457"></a>
<span class="sourceLineNo">458</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.458"></a>
<span class="sourceLineNo">459</span>         * When prohibited or (strongly) discouraged: classes can not have 7 hours in between. They may not overlap in time<a name="line.459"></a>
<span class="sourceLineNo">460</span>         * but must be taught on the same days.<a name="line.460"></a>
<span class="sourceLineNo">461</span>         */<a name="line.461"></a>
<span class="sourceLineNo">462</span>        NHB_7("NHB(7)", "7 Hours Between", 70, 84, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.462"></a>
<span class="sourceLineNo">463</span>        /**<a name="line.463"></a>
<span class="sourceLineNo">464</span>         * 8 Hours Between: Given classes must have exactly 8 hours in between the end of one and the beginning of another.<a name="line.464"></a>
<span class="sourceLineNo">465</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.465"></a>
<span class="sourceLineNo">466</span>         * When prohibited or (strongly) discouraged: classes can not have 8 hours in between. They may not overlap in time<a name="line.466"></a>
<span class="sourceLineNo">467</span>         * but must be taught on the same days.<a name="line.467"></a>
<span class="sourceLineNo">468</span>         */<a name="line.468"></a>
<span class="sourceLineNo">469</span>        NHB_8("NHB(8)", "8 Hours Between", 80, 96, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.469"></a>
<span class="sourceLineNo">470</span>        /**<a name="line.470"></a>
<span class="sourceLineNo">471</span>         * Same Start Time: Given classes must start during the same half-hour period of a day (independent of the actual<a name="line.471"></a>
<span class="sourceLineNo">472</span>         * day the classes meet). For instance, MW 7:30 is compatible with TTh 7:30 but not with MWF 8:00.&lt;BR&gt;<a name="line.472"></a>
<span class="sourceLineNo">473</span>         * When prohibited or (strongly) discouraged: any pair of classes in the given constraint cannot start during the<a name="line.473"></a>
<span class="sourceLineNo">474</span>         * same half-hour period of any day of the week.<a name="line.474"></a>
<span class="sourceLineNo">475</span>         */<a name="line.475"></a>
<span class="sourceLineNo">476</span>        SAME_START("SAME_START", "Same Start Time", new PairCheck() {<a name="line.476"></a>
<span class="sourceLineNo">477</span>            @Override<a name="line.477"></a>
<span class="sourceLineNo">478</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.478"></a>
<span class="sourceLineNo">479</span>                return<a name="line.479"></a>
<span class="sourceLineNo">480</span>                    (plc1.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY) == <a name="line.480"></a>
<span class="sourceLineNo">481</span>                    (plc2.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY);<a name="line.481"></a>
<span class="sourceLineNo">482</span>            }<a name="line.482"></a>
<span class="sourceLineNo">483</span>            @Override<a name="line.483"></a>
<span class="sourceLineNo">484</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.484"></a>
<span class="sourceLineNo">485</span>                return<a name="line.485"></a>
<span class="sourceLineNo">486</span>                    (plc1.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY) != <a name="line.486"></a>
<span class="sourceLineNo">487</span>                    (plc2.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY);<a name="line.487"></a>
<span class="sourceLineNo">488</span>            }}),<a name="line.488"></a>
<span class="sourceLineNo">489</span>        /**<a name="line.489"></a>
<span class="sourceLineNo">490</span>         * Same Room: Given classes must be taught in the same room.&lt;BR&gt;<a name="line.490"></a>
<span class="sourceLineNo">491</span>         * When prohibited or (strongly) discouraged: any pair of classes in the constraint cannot be taught in the same room.<a name="line.491"></a>
<span class="sourceLineNo">492</span>         */<a name="line.492"></a>
<span class="sourceLineNo">493</span>        SAME_ROOM("SAME_ROOM", "Same Room", new PairCheck() {<a name="line.493"></a>
<span class="sourceLineNo">494</span>            @Override<a name="line.494"></a>
<span class="sourceLineNo">495</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.495"></a>
<span class="sourceLineNo">496</span>                return plc1.sameRooms(plc2);<a name="line.496"></a>
<span class="sourceLineNo">497</span>            }<a name="line.497"></a>
<span class="sourceLineNo">498</span>            @Override<a name="line.498"></a>
<span class="sourceLineNo">499</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.499"></a>
<span class="sourceLineNo">500</span>                return !plc1.sameRooms(plc2);<a name="line.500"></a>
<span class="sourceLineNo">501</span>            }}),<a name="line.501"></a>
<span class="sourceLineNo">502</span>        /**<a name="line.502"></a>
<span class="sourceLineNo">503</span>         * At Least 1 Hour Between: Given classes have to have 1 hour or more in between.&lt;BR&gt;<a name="line.503"></a>
<span class="sourceLineNo">504</span>         * When prohibited or (strongly) discouraged: given classes have to have less than 1 hour in between.<a name="line.504"></a>
<span class="sourceLineNo">505</span>         */<a name="line.505"></a>
<span class="sourceLineNo">506</span>        NHB_GTE_1("NHB_GTE(1)", "At Least 1 Hour Between", 6, 288, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.506"></a>
<span class="sourceLineNo">507</span>        /**<a name="line.507"></a>
<span class="sourceLineNo">508</span>         * Less Than 6 Hours Between: Given classes must have less than 6 hours from end of first class to the beginning of<a name="line.508"></a>
<span class="sourceLineNo">509</span>         * the next. Given classes must also be taught on the same days.&lt;BR&gt;<a name="line.509"></a>
<span class="sourceLineNo">510</span>         * When prohibited or (strongly) discouraged: given classes must have 6 or more hours between. This constraint does<a name="line.510"></a>
<span class="sourceLineNo">511</span>         * not carry over from classes taught at the end of one day to the beginning of the next.<a name="line.511"></a>
<span class="sourceLineNo">512</span>         */<a name="line.512"></a>
<span class="sourceLineNo">513</span>        NHB_LT_6("NHB_LT(6)", "Less Than 6 Hours Between", 0, 72, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.513"></a>
<span class="sourceLineNo">514</span>        /**<a name="line.514"></a>
<span class="sourceLineNo">515</span>         * 1.5 Hour Between: Given classes must have exactly 90 minutes in between the end of one and the beginning of another.<a name="line.515"></a>
<span class="sourceLineNo">516</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.516"></a>
<span class="sourceLineNo">517</span>         * When prohibited or (strongly) discouraged: classes can not have 90 minutes in between. They may not overlap in time<a name="line.517"></a>
<span class="sourceLineNo">518</span>         * but must be taught on the same days.<a name="line.518"></a>
<span class="sourceLineNo">519</span>         */<a name="line.519"></a>
<span class="sourceLineNo">520</span>        NHB_1_5("NHB(1.5)", "1.5 Hour Between", 15, 18, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.520"></a>
<span class="sourceLineNo">521</span>        /**<a name="line.521"></a>
<span class="sourceLineNo">522</span>         * 4.5 Hours Between: Given classes must have exactly 4.5 hours in between the end of one and the beginning of another.<a name="line.522"></a>
<span class="sourceLineNo">523</span>         * As with the &lt;i&gt;back-to-back time&lt;/i&gt; constraint, given classes must be taught on the same days.&lt;BR&gt;<a name="line.523"></a>
<span class="sourceLineNo">524</span>         * When prohibited or (strongly) discouraged: classes can not have 4.5 hours in between. They may not overlap in time<a name="line.524"></a>
<span class="sourceLineNo">525</span>         * but must be taught on the same days.<a name="line.525"></a>
<span class="sourceLineNo">526</span>         */<a name="line.526"></a>
<span class="sourceLineNo">527</span>        NHB_4_5("NHB(4.5)", "4.5 Hours Between", 45, 54, BTB_TIME.check(), Flag.BACK_TO_BACK),<a name="line.527"></a>
<span class="sourceLineNo">528</span>        /**<a name="line.528"></a>
<span class="sourceLineNo">529</span>         * Same Students: Given classes are treated as they are attended by the same students, i.e., they cannot overlap in time<a name="line.529"></a>
<span class="sourceLineNo">530</span>         * and if they are back-to-back the assigned rooms cannot be too far (student limit is used).<a name="line.530"></a>
<span class="sourceLineNo">531</span>         */<a name="line.531"></a>
<span class="sourceLineNo">532</span>        SAME_STUDENTS("SAME_STUDENTS", "Same Students", new PairCheck() {<a name="line.532"></a>
<span class="sourceLineNo">533</span>            @Override<a name="line.533"></a>
<span class="sourceLineNo">534</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.534"></a>
<span class="sourceLineNo">535</span>                return !JenrlConstraint.isInConflict(plc1, plc2, ((TimetableModel)gc.getModel()).getDistanceMetric(), ((TimetableModel)gc.getModel()).getStudentWorkDayLimit());<a name="line.535"></a>
<span class="sourceLineNo">536</span>            }<a name="line.536"></a>
<span class="sourceLineNo">537</span>            @Override<a name="line.537"></a>
<span class="sourceLineNo">538</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.538"></a>
<span class="sourceLineNo">539</span>                return true;<a name="line.539"></a>
<span class="sourceLineNo">540</span>            }}),<a name="line.540"></a>
<span class="sourceLineNo">541</span>        /**<a name="line.541"></a>
<span class="sourceLineNo">542</span>         * Same Instructor: Given classes are treated as they are taught by the same instructor, i.e., they cannot overlap in time<a name="line.542"></a>
<span class="sourceLineNo">543</span>         * and if they are back-to-back the assigned rooms cannot be too far (instructor limit is used).&lt;BR&gt;<a name="line.543"></a>
<span class="sourceLineNo">544</span>         * If the constraint is required and the classes are back-to-back, discouraged and strongly discouraged distances between<a name="line.544"></a>
<span class="sourceLineNo">545</span>         * assigned rooms are also considered.<a name="line.545"></a>
<span class="sourceLineNo">546</span>         */<a name="line.546"></a>
<span class="sourceLineNo">547</span>        SAME_INSTR("SAME_INSTR", "Same Instructor", new PairCheck() {<a name="line.547"></a>
<span class="sourceLineNo">548</span>            @Override<a name="line.548"></a>
<span class="sourceLineNo">549</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.549"></a>
<span class="sourceLineNo">550</span>                TimeLocation t1 = plc1.getTimeLocation(), t2 = plc2.getTimeLocation();<a name="line.550"></a>
<span class="sourceLineNo">551</span>                if (t1.shareDays(t2) &amp;&amp; t1.shareWeeks(t2)) {<a name="line.551"></a>
<span class="sourceLineNo">552</span>                    if (t1.shareHours(t2)) return false; // overlap<a name="line.552"></a>
<span class="sourceLineNo">553</span>                    DistanceMetric m = ((TimetableModel)gc.getModel()).getDistanceMetric();<a name="line.553"></a>
<span class="sourceLineNo">554</span>                    if ((t1.getStartSlot() + t1.getLength() == t2.getStartSlot() || t2.getStartSlot() + t2.getLength() == t1.getStartSlot())) {<a name="line.554"></a>
<span class="sourceLineNo">555</span>                        if (Placement.getDistanceInMeters(m, plc1, plc2) &gt; m.getInstructorProhibitedLimit())<a name="line.555"></a>
<span class="sourceLineNo">556</span>                            return false;<a name="line.556"></a>
<span class="sourceLineNo">557</span>                    } else if (m.doComputeDistanceConflictsBetweenNonBTBClasses()) {<a name="line.557"></a>
<span class="sourceLineNo">558</span>                        if (t1.getStartSlot() + t1.getLength() &lt; t2.getStartSlot() &amp;&amp; <a name="line.558"></a>
<span class="sourceLineNo">559</span>                            Placement.getDistanceInMinutes(m, plc1, plc2) &gt; t1.getBreakTime() + Constants.SLOT_LENGTH_MIN * (t2.getStartSlot() - t1.getStartSlot() - t1.getLength()))<a name="line.559"></a>
<span class="sourceLineNo">560</span>                            return false;<a name="line.560"></a>
<span class="sourceLineNo">561</span>                        if (t2.getStartSlot() + t2.getLength() &lt; t1.getStartSlot() &amp;&amp;<a name="line.561"></a>
<span class="sourceLineNo">562</span>                            Placement.getDistanceInMinutes(m, plc1, plc2) &gt; t2.getBreakTime() + Constants.SLOT_LENGTH_MIN * (t1.getStartSlot() - t2.getStartSlot() - t2.getLength()))<a name="line.562"></a>
<span class="sourceLineNo">563</span>                            return false;<a name="line.563"></a>
<span class="sourceLineNo">564</span>                    }<a name="line.564"></a>
<span class="sourceLineNo">565</span>                }<a name="line.565"></a>
<span class="sourceLineNo">566</span>                return true;<a name="line.566"></a>
<span class="sourceLineNo">567</span>            }<a name="line.567"></a>
<span class="sourceLineNo">568</span>            @Override<a name="line.568"></a>
<span class="sourceLineNo">569</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.569"></a>
<span class="sourceLineNo">570</span>                return true;<a name="line.570"></a>
<span class="sourceLineNo">571</span>            }}),<a name="line.571"></a>
<span class="sourceLineNo">572</span>        /**<a name="line.572"></a>
<span class="sourceLineNo">573</span>         * Can Share Room: Given classes can share the room (use the room in the same time) if the room is big enough.<a name="line.573"></a>
<span class="sourceLineNo">574</span>         */<a name="line.574"></a>
<span class="sourceLineNo">575</span>        CAN_SHARE_ROOM("CAN_SHARE_ROOM", "Can Share Room", Flag.CAN_SHARE_ROOM),<a name="line.575"></a>
<span class="sourceLineNo">576</span>        /**<a name="line.576"></a>
<span class="sourceLineNo">577</span>         * Precedence: Given classes have to be taught in the given order (the first meeting of the first class has to end before<a name="line.577"></a>
<span class="sourceLineNo">578</span>         * the first meeting of the second class etc.)&lt;BR&gt;<a name="line.578"></a>
<span class="sourceLineNo">579</span>         * When prohibited or (strongly) discouraged: classes have to be taught in the order reverse to the given one.<a name="line.579"></a>
<span class="sourceLineNo">580</span>         */<a name="line.580"></a>
<span class="sourceLineNo">581</span>        PRECEDENCE("PRECEDENCE", "Precedence", new PairCheck() {<a name="line.581"></a>
<span class="sourceLineNo">582</span>            @Override<a name="line.582"></a>
<span class="sourceLineNo">583</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.583"></a>
<span class="sourceLineNo">584</span>                return gc.isPrecedence(plc1, plc2, true, true);<a name="line.584"></a>
<span class="sourceLineNo">585</span>            }<a name="line.585"></a>
<span class="sourceLineNo">586</span>            @Override<a name="line.586"></a>
<span class="sourceLineNo">587</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.587"></a>
<span class="sourceLineNo">588</span>                return gc.isPrecedence(plc1, plc2, false, true);<a name="line.588"></a>
<span class="sourceLineNo">589</span>            }}),<a name="line.589"></a>
<span class="sourceLineNo">590</span>        /**<a name="line.590"></a>
<span class="sourceLineNo">591</span>         * Back-To-Back Day: Classes must be offered on adjacent days and may be placed in different rooms.&lt;BR&gt;<a name="line.591"></a>
<span class="sourceLineNo">592</span>         * When prohibited or (strongly) discouraged: classes can not be taught on adjacent days. They also can not be taught<a name="line.592"></a>
<span class="sourceLineNo">593</span>         * on the same days. This means that there must be at least one day between these classes.<a name="line.593"></a>
<span class="sourceLineNo">594</span>         */<a name="line.594"></a>
<span class="sourceLineNo">595</span>        BTB_DAY("BTB_DAY", "Back-To-Back Day", new PairCheck() {<a name="line.595"></a>
<span class="sourceLineNo">596</span>            @Override<a name="line.596"></a>
<span class="sourceLineNo">597</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.597"></a>
<span class="sourceLineNo">598</span>                return<a name="line.598"></a>
<span class="sourceLineNo">599</span>                    !sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.599"></a>
<span class="sourceLineNo">600</span>                    gc.isBackToBackDays(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.600"></a>
<span class="sourceLineNo">601</span>            }<a name="line.601"></a>
<span class="sourceLineNo">602</span>            @Override<a name="line.602"></a>
<span class="sourceLineNo">603</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.603"></a>
<span class="sourceLineNo">604</span>                return<a name="line.604"></a>
<span class="sourceLineNo">605</span>                    !sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.605"></a>
<span class="sourceLineNo">606</span>                    !gc.isBackToBackDays(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.606"></a>
<span class="sourceLineNo">607</span>            }}),<a name="line.607"></a>
<span class="sourceLineNo">608</span>        /**<a name="line.608"></a>
<span class="sourceLineNo">609</span>         * Meet Together: Given classes are meeting together (same as if the given classes require constraints Can Share Room,<a name="line.609"></a>
<span class="sourceLineNo">610</span>         * Same Room, Same Time and Same Days all together).<a name="line.610"></a>
<span class="sourceLineNo">611</span>         */<a name="line.611"></a>
<span class="sourceLineNo">612</span>        MEET_WITH("MEET_WITH", "Meet Together", new PairCheck() {<a name="line.612"></a>
<span class="sourceLineNo">613</span>            @Override<a name="line.613"></a>
<span class="sourceLineNo">614</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.614"></a>
<span class="sourceLineNo">615</span>                return<a name="line.615"></a>
<span class="sourceLineNo">616</span>                        plc1.sameRooms(plc2) &amp;&amp;<a name="line.616"></a>
<span class="sourceLineNo">617</span>                        sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(),<a name="line.617"></a>
<span class="sourceLineNo">618</span>                                plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength()) &amp;&amp;<a name="line.618"></a>
<span class="sourceLineNo">619</span>                        sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.619"></a>
<span class="sourceLineNo">620</span>                        <a name="line.620"></a>
<span class="sourceLineNo">621</span>            }<a name="line.621"></a>
<span class="sourceLineNo">622</span>            @Override<a name="line.622"></a>
<span class="sourceLineNo">623</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.623"></a>
<span class="sourceLineNo">624</span>                return true;<a name="line.624"></a>
<span class="sourceLineNo">625</span>            }}, Flag.CAN_SHARE_ROOM),<a name="line.625"></a>
<span class="sourceLineNo">626</span>        /**<a name="line.626"></a>
<span class="sourceLineNo">627</span>         * More Than 1 Day Between: Given classes must have two or more days in between.&lt;br&gt;<a name="line.627"></a>
<span class="sourceLineNo">628</span>         * When prohibited or (strongly) discouraged: given classes must be offered on adjacent days or with at most one day in between.<a name="line.628"></a>
<span class="sourceLineNo">629</span>         */<a name="line.629"></a>
<span class="sourceLineNo">630</span>        NDB_GT_1("NDB_GT_1", "More Than 1 Day Between", new PairCheck() {<a name="line.630"></a>
<span class="sourceLineNo">631</span>            @Override<a name="line.631"></a>
<span class="sourceLineNo">632</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.632"></a>
<span class="sourceLineNo">633</span>                return<a name="line.633"></a>
<span class="sourceLineNo">634</span>                    !sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.634"></a>
<span class="sourceLineNo">635</span>                    gc.isNrDaysBetweenGreaterThanOne(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.635"></a>
<span class="sourceLineNo">636</span>            }<a name="line.636"></a>
<span class="sourceLineNo">637</span>            @Override<a name="line.637"></a>
<span class="sourceLineNo">638</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.638"></a>
<span class="sourceLineNo">639</span>                return<a name="line.639"></a>
<span class="sourceLineNo">640</span>                    !sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.640"></a>
<span class="sourceLineNo">641</span>                    !gc.isNrDaysBetweenGreaterThanOne(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.641"></a>
<span class="sourceLineNo">642</span>            }}),<a name="line.642"></a>
<span class="sourceLineNo">643</span>        /**<a name="line.643"></a>
<span class="sourceLineNo">644</span>         * Children Cannot Overlap: If parent classes do not overlap in time, children classes can not overlap in time as well.&lt;BR&gt;<a name="line.644"></a>
<span class="sourceLineNo">645</span>         * Note: This constraint only needs to be put on the parent classes. Preferred configurations are Required All Classes<a name="line.645"></a>
<span class="sourceLineNo">646</span>         * or Pairwise (Strongly) Preferred.<a name="line.646"></a>
<span class="sourceLineNo">647</span>         */<a name="line.647"></a>
<span class="sourceLineNo">648</span>        CH_NOTOVERLAP("CH_NOTOVERLAP", "Children Cannot Overlap", new AssignmentPairCheck() {<a name="line.648"></a>
<span class="sourceLineNo">649</span>            @Override<a name="line.649"></a>
<span class="sourceLineNo">650</span>            public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.650"></a>
<span class="sourceLineNo">651</span>                return gc.isChildrenNotOverlap(assignment, plc1.variable(), plc1, plc2.variable(), plc2);<a name="line.651"></a>
<span class="sourceLineNo">652</span>            }<a name="line.652"></a>
<span class="sourceLineNo">653</span>            @Override<a name="line.653"></a>
<span class="sourceLineNo">654</span>            public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.654"></a>
<span class="sourceLineNo">655</span>                return true;<a name="line.655"></a>
<span class="sourceLineNo">656</span>            }}),<a name="line.656"></a>
<span class="sourceLineNo">657</span>        /**<a name="line.657"></a>
<span class="sourceLineNo">658</span>         * Next Day: The second class has to be placed on the following day of the first class (if the first class is on Friday,<a name="line.658"></a>
<span class="sourceLineNo">659</span>         * second class have to be on Monday).&lt;br&gt;<a name="line.659"></a>
<span class="sourceLineNo">660</span>         * When prohibited or (strongly) discouraged: The second class has to be placed on the previous day of the first class<a name="line.660"></a>
<span class="sourceLineNo">661</span>         * (if the first class is on Monday, second class have to be on Friday).&lt;br&gt;<a name="line.661"></a>
<span class="sourceLineNo">662</span>         * Note: This constraint works only between pairs of classes.<a name="line.662"></a>
<span class="sourceLineNo">663</span>         */<a name="line.663"></a>
<span class="sourceLineNo">664</span>        FOLLOWING_DAY("FOLLOWING_DAY", "Next Day", new PairCheck() {<a name="line.664"></a>
<span class="sourceLineNo">665</span>            @Override<a name="line.665"></a>
<span class="sourceLineNo">666</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.666"></a>
<span class="sourceLineNo">667</span>                return gc.isFollowingDay(plc1, plc2, true);<a name="line.667"></a>
<span class="sourceLineNo">668</span>            }<a name="line.668"></a>
<span class="sourceLineNo">669</span>            @Override<a name="line.669"></a>
<span class="sourceLineNo">670</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.670"></a>
<span class="sourceLineNo">671</span>                return gc.isFollowingDay(plc1, plc2, false);<a name="line.671"></a>
<span class="sourceLineNo">672</span>            }}),<a name="line.672"></a>
<span class="sourceLineNo">673</span>        /**<a name="line.673"></a>
<span class="sourceLineNo">674</span>         * Two Days After: The second class has to be placed two days after the first class (Monday &amp;rarr; Wednesday, Tuesday &amp;rarr; <a name="line.674"></a>
<span class="sourceLineNo">675</span>         * Thurday, Wednesday &amp;rarr; Friday, Thursday &amp;rarr; Monday, Friday &amp;rarr; Tuesday).&lt;br&gt;<a name="line.675"></a>
<span class="sourceLineNo">676</span>         * When prohibited or (strongly) discouraged: The second class has to be placed two days before the first class (Monday &amp;rarr;<a name="line.676"></a>
<span class="sourceLineNo">677</span>         * Thursday, Tuesday &amp;rarr; Friday, Wednesday &amp;rarr; Monday, Thursday &amp;rarr; Tuesday, Friday &amp;rarr; Wednesday).&lt;br&gt;<a name="line.677"></a>
<span class="sourceLineNo">678</span>         * Note: This constraint works only between pairs of classes.<a name="line.678"></a>
<span class="sourceLineNo">679</span>         */<a name="line.679"></a>
<span class="sourceLineNo">680</span>        EVERY_OTHER_DAY("EVERY_OTHER_DAY", "Two Days After", new PairCheck() {<a name="line.680"></a>
<span class="sourceLineNo">681</span>            @Override<a name="line.681"></a>
<span class="sourceLineNo">682</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.682"></a>
<span class="sourceLineNo">683</span>                return gc.isEveryOtherDay(plc1, plc2, true);<a name="line.683"></a>
<span class="sourceLineNo">684</span>            }<a name="line.684"></a>
<span class="sourceLineNo">685</span>            @Override<a name="line.685"></a>
<span class="sourceLineNo">686</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.686"></a>
<span class="sourceLineNo">687</span>                return gc.isEveryOtherDay(plc1, plc2, false);<a name="line.687"></a>
<span class="sourceLineNo">688</span>            }}),<a name="line.688"></a>
<span class="sourceLineNo">689</span>        /**<a name="line.689"></a>
<span class="sourceLineNo">690</span>         * At Most 3 Hours A Day: Classes are to be placed in a way that there is no more than three hours in any day.<a name="line.690"></a>
<span class="sourceLineNo">691</span>         */<a name="line.691"></a>
<span class="sourceLineNo">692</span>       MAX_HRS_DAY_3("MAX_HRS_DAY(3)", "At Most 3 Hours A Day", 36, null, Flag.MAX_HRS_DAY),        <a name="line.692"></a>
<span class="sourceLineNo">693</span>       /**<a name="line.693"></a>
<span class="sourceLineNo">694</span>        * At Most 4 Hours A Day: Classes are to be placed in a way that there is no more than four hours in any day.<a name="line.694"></a>
<span class="sourceLineNo">695</span>        */<a name="line.695"></a>
<span class="sourceLineNo">696</span>       MAX_HRS_DAY_4("MAX_HRS_DAY(4)", "At Most 4 Hours A Day", 48, null, Flag.MAX_HRS_DAY),        <a name="line.696"></a>
<span class="sourceLineNo">697</span>       /**<a name="line.697"></a>
<span class="sourceLineNo">698</span>         * At Most 5 Hours A Day: Classes are to be placed in a way that there is no more than five hours in any day.<a name="line.698"></a>
<span class="sourceLineNo">699</span>         */<a name="line.699"></a>
<span class="sourceLineNo">700</span>       MAX_HRS_DAY_5("MAX_HRS_DAY(5)", "At Most 5 Hours A Day", 60, null, Flag.MAX_HRS_DAY),        <a name="line.700"></a>
<span class="sourceLineNo">701</span>       /**<a name="line.701"></a>
<span class="sourceLineNo">702</span>        * At Most 6 Hours A Day: Classes are to be placed in a way that there is no more than six hours in any day.<a name="line.702"></a>
<span class="sourceLineNo">703</span>        */<a name="line.703"></a>
<span class="sourceLineNo">704</span>       MAX_HRS_DAY_6("MAX_HRS_DAY(6)", "At Most 6 Hours A Day", 72, null, Flag.MAX_HRS_DAY),<a name="line.704"></a>
<span class="sourceLineNo">705</span>       /**<a name="line.705"></a>
<span class="sourceLineNo">706</span>        * At Most 7 Hours A Day: Classes are to be placed in a way that there is no more than seven hours in any day.<a name="line.706"></a>
<span class="sourceLineNo">707</span>        */<a name="line.707"></a>
<span class="sourceLineNo">708</span>       MAX_HRS_DAY_7("MAX_HRS_DAY(7)", "At Most 7 Hours A Day", 84, null, Flag.MAX_HRS_DAY),<a name="line.708"></a>
<span class="sourceLineNo">709</span>       /**<a name="line.709"></a>
<span class="sourceLineNo">710</span>        * At Most 8 Hours A Day: Classes are to be placed in a way that there is no more than eight hours in any day.<a name="line.710"></a>
<span class="sourceLineNo">711</span>        */<a name="line.711"></a>
<span class="sourceLineNo">712</span>       MAX_HRS_DAY_8("MAX_HRS_DAY(8)", "At Most 8 Hours A Day", 96, null, Flag.MAX_HRS_DAY),<a name="line.712"></a>
<span class="sourceLineNo">713</span>       /**<a name="line.713"></a>
<span class="sourceLineNo">714</span>        * At Most 9 Hours A Day: Classes are to be placed in a way that there is no more than nine hours in any day.<a name="line.714"></a>
<span class="sourceLineNo">715</span>        */<a name="line.715"></a>
<span class="sourceLineNo">716</span>       MAX_HRS_DAY_9("MAX_HRS_DAY(9)", "At Most 9 Hours A Day", 108, null, Flag.MAX_HRS_DAY),<a name="line.716"></a>
<span class="sourceLineNo">717</span>       /**<a name="line.717"></a>
<span class="sourceLineNo">718</span>        * At Most 10 Hours A Day: Classes are to be placed in a way that there is no more than ten hours in any day.<a name="line.718"></a>
<span class="sourceLineNo">719</span>        */<a name="line.719"></a>
<span class="sourceLineNo">720</span>       MAX_HRS_DAY_10("MAX_HRS_DAY(10)", "At Most 10 Hours A Day", 120, null, Flag.MAX_HRS_DAY),<a name="line.720"></a>
<span class="sourceLineNo">721</span>        /**<a name="line.721"></a>
<span class="sourceLineNo">722</span>         * At Most X Hours A Day: Classes are to be placed in a way that there is no more than given number of hours in any day.<a name="line.722"></a>
<span class="sourceLineNo">723</span>         */<a name="line.723"></a>
<span class="sourceLineNo">724</span>        MAX_HRS_DAY("MAX_HRS_DAY\\(([0-9\\.]+)\\)", "At Most N Hours A Day", new AssignmentParameterPairCheck&lt;Integer&gt;() {<a name="line.724"></a>
<span class="sourceLineNo">725</span>            @Override<a name="line.725"></a>
<span class="sourceLineNo">726</span>            public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.726"></a>
<span class="sourceLineNo">727</span>                return true;<a name="line.727"></a>
<span class="sourceLineNo">728</span>            }<a name="line.728"></a>
<span class="sourceLineNo">729</span>            @Override<a name="line.729"></a>
<span class="sourceLineNo">730</span>            public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.730"></a>
<span class="sourceLineNo">731</span>                return true;<a name="line.731"></a>
<span class="sourceLineNo">732</span>            }<a name="line.732"></a>
<span class="sourceLineNo">733</span>            @Override<a name="line.733"></a>
<span class="sourceLineNo">734</span>            public ParametrizedConstraintType&lt;Integer&gt; create(String reference, String regexp) {<a name="line.734"></a>
<span class="sourceLineNo">735</span>                Matcher matcher = Pattern.compile(regexp).matcher(reference);<a name="line.735"></a>
<span class="sourceLineNo">736</span>                if (matcher.find()) {<a name="line.736"></a>
<span class="sourceLineNo">737</span>                    double hours = Double.parseDouble(matcher.group(1));<a name="line.737"></a>
<span class="sourceLineNo">738</span>                    int slots = (int)Math.round(12.0 * hours);<a name="line.738"></a>
<span class="sourceLineNo">739</span>                    return new ParametrizedConstraintType&lt;Integer&gt;(ConstraintType.MAX_HRS_DAY, slots, reference)<a name="line.739"></a>
<span class="sourceLineNo">740</span>                            .setName("At Most " + matcher.group(1) + " Hours A Day")<a name="line.740"></a>
<span class="sourceLineNo">741</span>                            .setMin(slots).setMax(slots);<a name="line.741"></a>
<span class="sourceLineNo">742</span>                }<a name="line.742"></a>
<span class="sourceLineNo">743</span>                return null;<a name="line.743"></a>
<span class="sourceLineNo">744</span>            }}, Flag.MAX_HRS_DAY),<a name="line.744"></a>
<span class="sourceLineNo">745</span>        /**<a name="line.745"></a>
<span class="sourceLineNo">746</span>         * Given classes must be taught during the same weeks (i.e., must have the same date pattern).&lt;br&gt;<a name="line.746"></a>
<span class="sourceLineNo">747</span>         * When prohibited or (strongly) discouraged: any two classes must have non overlapping date patterns.<a name="line.747"></a>
<span class="sourceLineNo">748</span>         */<a name="line.748"></a>
<span class="sourceLineNo">749</span>        SAME_WEEKS("SAME_WEEKS", "Same Weeks", new PairCheck() {<a name="line.749"></a>
<span class="sourceLineNo">750</span>            @Override<a name="line.750"></a>
<span class="sourceLineNo">751</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.751"></a>
<span class="sourceLineNo">752</span>                return plc1.getTimeLocation().getWeekCode().equals(plc2.getTimeLocation().getWeekCode());<a name="line.752"></a>
<span class="sourceLineNo">753</span>            }<a name="line.753"></a>
<span class="sourceLineNo">754</span>            @Override<a name="line.754"></a>
<span class="sourceLineNo">755</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.755"></a>
<span class="sourceLineNo">756</span>                return !plc1.getTimeLocation().shareWeeks(plc2.getTimeLocation());<a name="line.756"></a>
<span class="sourceLineNo">757</span>            }}),<a name="line.757"></a>
<span class="sourceLineNo">758</span>        /**<a name="line.758"></a>
<span class="sourceLineNo">759</span>         * Classes (of different courses) are to be attended by the same students. For instance,<a name="line.759"></a>
<span class="sourceLineNo">760</span>         * if class A1 (of a course A) and class B1 (of a course B) are linked, a student requesting<a name="line.760"></a>
<span class="sourceLineNo">761</span>         * both courses must attend A1 if and only if he also attends B1. This is a student sectioning<a name="line.761"></a>
<span class="sourceLineNo">762</span>         * constraint that is interpreted as Same Students constraint during course timetabling.<a name="line.762"></a>
<span class="sourceLineNo">763</span>         */<a name="line.763"></a>
<span class="sourceLineNo">764</span>        LINKED_SECTIONS("LINKED_SECTIONS", "Linked Classes", SAME_STUDENTS.check()),<a name="line.764"></a>
<span class="sourceLineNo">765</span>        /**<a name="line.765"></a>
<span class="sourceLineNo">766</span>         * Back-To-Back Precedence: Given classes have to be taught in the given order, on the same days,<a name="line.766"></a>
<span class="sourceLineNo">767</span>         * and in adjacent time segments.<a name="line.767"></a>
<span class="sourceLineNo">768</span>         * When prohibited or (strongly) discouraged: Given classes have to be taught in the given order,<a name="line.768"></a>
<span class="sourceLineNo">769</span>         * on the same days, but cannot be back-to-back.<a name="line.769"></a>
<span class="sourceLineNo">770</span>         */<a name="line.770"></a>
<span class="sourceLineNo">771</span>        BTB_PRECEDENCE("BTB_PRECEDENCE", "Back-To-Back Precedence", new PairCheck() {<a name="line.771"></a>
<span class="sourceLineNo">772</span>            @Override<a name="line.772"></a>
<span class="sourceLineNo">773</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.773"></a>
<span class="sourceLineNo">774</span>                return gc.isPrecedence(plc1, plc2, true, false) &amp;&amp; sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.774"></a>
<span class="sourceLineNo">775</span>            }<a name="line.775"></a>
<span class="sourceLineNo">776</span>            @Override<a name="line.776"></a>
<span class="sourceLineNo">777</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.777"></a>
<span class="sourceLineNo">778</span>                return gc.isPrecedence(plc1, plc2, true, false) &amp;&amp; sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.778"></a>
<span class="sourceLineNo">779</span>            }}, Flag.BACK_TO_BACK),   <a name="line.779"></a>
<span class="sourceLineNo">780</span>            <a name="line.780"></a>
<span class="sourceLineNo">781</span>        /**<a name="line.781"></a>
<span class="sourceLineNo">782</span>         * Same Days-Time: Given classes must be taught at the same time of day and on the same days.<a name="line.782"></a>
<span class="sourceLineNo">783</span>         * It is the combination of Same Days and Same Time distribution preferences.     <a name="line.783"></a>
<span class="sourceLineNo">784</span>         * When prohibited or (strongly) discouraged: Any pair of classes classes cannot be taught on the same days<a name="line.784"></a>
<span class="sourceLineNo">785</span>         * during the same time.<a name="line.785"></a>
<span class="sourceLineNo">786</span>         */             <a name="line.786"></a>
<span class="sourceLineNo">787</span>        SAME_DAYS_TIME("SAME_D_T", "Same Days-Time", new PairCheck() {<a name="line.787"></a>
<span class="sourceLineNo">788</span>            @Override<a name="line.788"></a>
<span class="sourceLineNo">789</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.789"></a>
<span class="sourceLineNo">790</span>                return sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(),<a name="line.790"></a>
<span class="sourceLineNo">791</span>                        plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength()) &amp;&amp;<a name="line.791"></a>
<span class="sourceLineNo">792</span>                        sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray());<a name="line.792"></a>
<span class="sourceLineNo">793</span>            }<a name="line.793"></a>
<span class="sourceLineNo">794</span>            @Override<a name="line.794"></a>
<span class="sourceLineNo">795</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.795"></a>
<span class="sourceLineNo">796</span>                return !plc1.getTimeLocation().shareHours(plc2.getTimeLocation()) ||<a name="line.796"></a>
<span class="sourceLineNo">797</span>                        !plc1.getTimeLocation().shareDays(plc2.getTimeLocation());<a name="line.797"></a>
<span class="sourceLineNo">798</span>            }}),<a name="line.798"></a>
<span class="sourceLineNo">799</span>        /**<a name="line.799"></a>
<span class="sourceLineNo">800</span>         * Same Days-Room-Time: Given classes must be taught at the same time of day, on the same days and in the same room.<a name="line.800"></a>
<span class="sourceLineNo">801</span>         * It is the combination of Same Days, Same Time and Same Room distribution preferences.<a name="line.801"></a>
<span class="sourceLineNo">802</span>         * Note that this constraint is the same as Meet Together constraint, except it does not allow room sharing. In other words,<a name="line.802"></a>
<span class="sourceLineNo">803</span>         * it is only useful when these classes are taught during non-overlapping date patterns.<a name="line.803"></a>
<span class="sourceLineNo">804</span>         * When prohibited or (strongly) discouraged: Any pair of classes classes cannot be taught on the same days <a name="line.804"></a>
<span class="sourceLineNo">805</span>         * during the same time in the same room.<a name="line.805"></a>
<span class="sourceLineNo">806</span>         */            <a name="line.806"></a>
<span class="sourceLineNo">807</span>        SAME_DAYS_ROOM_TIME("SAME_D_R_T", "Same Days-Room-Time", new PairCheck() {<a name="line.807"></a>
<span class="sourceLineNo">808</span>            @Override<a name="line.808"></a>
<span class="sourceLineNo">809</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.809"></a>
<span class="sourceLineNo">810</span>                return sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(),<a name="line.810"></a>
<span class="sourceLineNo">811</span>                        plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength()) &amp;&amp;<a name="line.811"></a>
<span class="sourceLineNo">812</span>                        sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.812"></a>
<span class="sourceLineNo">813</span>                        plc1.sameRooms(plc2);<a name="line.813"></a>
<span class="sourceLineNo">814</span>            }<a name="line.814"></a>
<span class="sourceLineNo">815</span>            @Override<a name="line.815"></a>
<span class="sourceLineNo">816</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.816"></a>
<span class="sourceLineNo">817</span>                return !plc1.getTimeLocation().shareHours(plc2.getTimeLocation()) ||<a name="line.817"></a>
<span class="sourceLineNo">818</span>                        !plc1.getTimeLocation().shareDays(plc2.getTimeLocation()) ||<a name="line.818"></a>
<span class="sourceLineNo">819</span>                        !plc1.sameRooms(plc2);<a name="line.819"></a>
<span class="sourceLineNo">820</span>            }}),<a name="line.820"></a>
<span class="sourceLineNo">821</span>        /**<a name="line.821"></a>
<span class="sourceLineNo">822</span>         * 6 Hour Work Day: Classes are to be placed in a way that there is no more than six hours between the start of the first class and the end of the class one on any day.<a name="line.822"></a>
<span class="sourceLineNo">823</span>         */<a name="line.823"></a>
<span class="sourceLineNo">824</span>        WORKDAY_6("WORKDAY(6)", "6 Hour Work Day", 72, new PairCheck() {<a name="line.824"></a>
<span class="sourceLineNo">825</span>            @Override<a name="line.825"></a>
<span class="sourceLineNo">826</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.826"></a>
<span class="sourceLineNo">827</span>                TimeLocation t1 = plc1.getTimeLocation(), t2 = plc2.getTimeLocation();<a name="line.827"></a>
<span class="sourceLineNo">828</span>                if (t1 == null || t2 == null || !t1.shareDays(t2) || !t1.shareWeeks(t2)) return true;<a name="line.828"></a>
<span class="sourceLineNo">829</span>                return Math.max(t1.getStartSlot() + t1.getLength(), t2.getStartSlot() + t2.getLength()) - Math.min(t1.getStartSlot(), t2.getStartSlot()) &lt;= gc.getType().getMax();<a name="line.829"></a>
<span class="sourceLineNo">830</span>            }<a name="line.830"></a>
<span class="sourceLineNo">831</span>            @Override<a name="line.831"></a>
<span class="sourceLineNo">832</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) { return true; }<a name="line.832"></a>
<span class="sourceLineNo">833</span>            }),<a name="line.833"></a>
<span class="sourceLineNo">834</span>        /**<a name="line.834"></a>
<span class="sourceLineNo">835</span>         * 7 Hour Work Day: Classes are to be placed in a way that there is no more than seven hours between the start of the first class and the end of the class one on any day.<a name="line.835"></a>
<span class="sourceLineNo">836</span>         */<a name="line.836"></a>
<span class="sourceLineNo">837</span>        WORKDAY_7("WORKDAY(7)", "7 Hour Work Day", 84, WORKDAY_6.check()),<a name="line.837"></a>
<span class="sourceLineNo">838</span>        /**<a name="line.838"></a>
<span class="sourceLineNo">839</span>         * 8 Hour Work Day: Classes are to be placed in a way that there is no more than eight hours between the start of the first class and the end of the class one on any day.<a name="line.839"></a>
<span class="sourceLineNo">840</span>         */<a name="line.840"></a>
<span class="sourceLineNo">841</span>        WORKDAY_8("WORKDAY(8)", "8 Hour Work Day", 96, WORKDAY_6.check()),<a name="line.841"></a>
<span class="sourceLineNo">842</span>        /**<a name="line.842"></a>
<span class="sourceLineNo">843</span>         * 9 Hour Work Day: Classes are to be placed in a way that there is no more than nine hours between the start of the first class and the end of the class one on any day.<a name="line.843"></a>
<span class="sourceLineNo">844</span>         */<a name="line.844"></a>
<span class="sourceLineNo">845</span>        WORKDAY_9("WORKDAY(9)", "9 Hour Work Day", 108, WORKDAY_6.check()),<a name="line.845"></a>
<span class="sourceLineNo">846</span>        /**<a name="line.846"></a>
<span class="sourceLineNo">847</span>         * 10 Hour Work Day: Classes are to be placed in a way that there is no more than ten hours between the start of the first class and the end of the class one on any day.<a name="line.847"></a>
<span class="sourceLineNo">848</span>         */<a name="line.848"></a>
<span class="sourceLineNo">849</span>        WORKDAY_10("WORKDAY(10)", "10 Hour Work Day", 120, WORKDAY_6.check()),<a name="line.849"></a>
<span class="sourceLineNo">850</span>        /**<a name="line.850"></a>
<span class="sourceLineNo">851</span>         * 11 Hour Work Day: Classes are to be placed in a way that there is no more than eleven hours between the start of the first class and the end of the class one on any day.<a name="line.851"></a>
<span class="sourceLineNo">852</span>         */<a name="line.852"></a>
<span class="sourceLineNo">853</span>        WORKDAY_11("WORKDAY(11)", "11 Hour Work Day", 132, WORKDAY_6.check()),<a name="line.853"></a>
<span class="sourceLineNo">854</span>        /**<a name="line.854"></a>
<span class="sourceLineNo">855</span>         * 12 Hour Work Day: Classes are to be placed in a way that there is no more than twelve hours between the start of the first class and the end of the class one on any day.<a name="line.855"></a>
<span class="sourceLineNo">856</span>         */<a name="line.856"></a>
<span class="sourceLineNo">857</span>        WORKDAY_12("WORKDAY(12)", "12 Hour Work Day", 144, WORKDAY_6.check()),<a name="line.857"></a>
<span class="sourceLineNo">858</span>        /**<a name="line.858"></a>
<span class="sourceLineNo">859</span>         * 4 Hour Work Day: Classes are to be placed in a way that there is no more than four hours between the start of the first class and the end of the class one on any day.<a name="line.859"></a>
<span class="sourceLineNo">860</span>         */<a name="line.860"></a>
<span class="sourceLineNo">861</span>        WORKDAY_4("WORKDAY(4)", "4 Hour Work Day", 48, WORKDAY_6.check()),<a name="line.861"></a>
<span class="sourceLineNo">862</span>        /**<a name="line.862"></a>
<span class="sourceLineNo">863</span>         * 5 Hour Work Day: Classes are to be placed in a way that there is no more than five hours between the start of the first class and the end of the class one on any day.<a name="line.863"></a>
<span class="sourceLineNo">864</span>         */<a name="line.864"></a>
<span class="sourceLineNo">865</span>        WORKDAY_5("WORKDAY(5)", "5 Hour Work Day", 60, WORKDAY_6.check()),<a name="line.865"></a>
<span class="sourceLineNo">866</span>          /**<a name="line.866"></a>
<span class="sourceLineNo">867</span>         * Work Day: Classes are to be placed in a way that there is no more than given number of hours between the start of the first class and the end of the class one on any day.<a name="line.867"></a>
<span class="sourceLineNo">868</span>         */<a name="line.868"></a>
<span class="sourceLineNo">869</span>        WORKDAY("WORKDAY\\(([0-9\\.]+)\\)", "Work Day", new AssignmentParameterPairCheck&lt;Integer&gt;() {<a name="line.869"></a>
<span class="sourceLineNo">870</span>            @Override<a name="line.870"></a>
<span class="sourceLineNo">871</span>            public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.871"></a>
<span class="sourceLineNo">872</span>                TimeLocation t1 = plc1.getTimeLocation(), t2 = plc2.getTimeLocation();<a name="line.872"></a>
<span class="sourceLineNo">873</span>                if (t1 == null || t2 == null || !t1.shareDays(t2) || !t1.shareWeeks(t2)) return true;<a name="line.873"></a>
<span class="sourceLineNo">874</span>                return Math.max(t1.getStartSlot() + t1.getLength(), t2.getStartSlot() + t2.getLength()) - Math.min(t1.getStartSlot(), t2.getStartSlot()) &lt;= parameter;<a name="line.874"></a>
<span class="sourceLineNo">875</span>            }<a name="line.875"></a>
<span class="sourceLineNo">876</span>            @Override<a name="line.876"></a>
<span class="sourceLineNo">877</span>            public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.877"></a>
<span class="sourceLineNo">878</span>                return true;<a name="line.878"></a>
<span class="sourceLineNo">879</span>            }<a name="line.879"></a>
<span class="sourceLineNo">880</span>            @Override<a name="line.880"></a>
<span class="sourceLineNo">881</span>            public ParametrizedConstraintType&lt;Integer&gt; create(String reference, String regexp) {<a name="line.881"></a>
<span class="sourceLineNo">882</span>                Matcher matcher = Pattern.compile(regexp).matcher(reference);<a name="line.882"></a>
<span class="sourceLineNo">883</span>                if (matcher.find()) {<a name="line.883"></a>
<span class="sourceLineNo">884</span>                    double hours = Double.parseDouble(matcher.group(1));<a name="line.884"></a>
<span class="sourceLineNo">885</span>                    int slots = (int)Math.round(12.0 * hours);<a name="line.885"></a>
<span class="sourceLineNo">886</span>                    return new ParametrizedConstraintType&lt;Integer&gt;(ConstraintType.WORKDAY, slots, reference)<a name="line.886"></a>
<span class="sourceLineNo">887</span>                            .setName(matcher.group(1) + " Hour Work Day").setMin(slots).setMax(slots);<a name="line.887"></a>
<span class="sourceLineNo">888</span>                }<a name="line.888"></a>
<span class="sourceLineNo">889</span>                return null;<a name="line.889"></a>
<span class="sourceLineNo">890</span>            }}),<a name="line.890"></a>
<span class="sourceLineNo">891</span>        /**<a name="line.891"></a>
<span class="sourceLineNo">892</span>         * Meet Together &amp;amp; Same Weeks: Given classes are meeting together (same as if the given classes require constraints Can Share Room,<a name="line.892"></a>
<span class="sourceLineNo">893</span>         * Same Room, Same Time, Same Days and Same Weeks all together).<a name="line.893"></a>
<span class="sourceLineNo">894</span>         */<a name="line.894"></a>
<span class="sourceLineNo">895</span>        MEET_WITH_WEEKS("MEET_WITH_WEEKS", "Meet Together &amp; Same Weeks", new PairCheck() {<a name="line.895"></a>
<span class="sourceLineNo">896</span>            @Override<a name="line.896"></a>
<span class="sourceLineNo">897</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.897"></a>
<span class="sourceLineNo">898</span>                return<a name="line.898"></a>
<span class="sourceLineNo">899</span>                        plc1.sameRooms(plc2) &amp;&amp;<a name="line.899"></a>
<span class="sourceLineNo">900</span>                        sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(), plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength()) &amp;&amp;<a name="line.900"></a>
<span class="sourceLineNo">901</span>                        sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.901"></a>
<span class="sourceLineNo">902</span>                        plc1.getTimeLocation().getWeekCode().equals(plc2.getTimeLocation().getWeekCode());<a name="line.902"></a>
<span class="sourceLineNo">903</span>            }<a name="line.903"></a>
<span class="sourceLineNo">904</span>            @Override<a name="line.904"></a>
<span class="sourceLineNo">905</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.905"></a>
<span class="sourceLineNo">906</span>                return true;<a name="line.906"></a>
<span class="sourceLineNo">907</span>            }}, Flag.CAN_SHARE_ROOM),<a name="line.907"></a>
<span class="sourceLineNo">908</span>        MIN_GAP("MIN_GAP\\(([0-9\\.]+)\\)", "Mininal Gap Between Classes", new AssignmentParameterPairCheck&lt;Integer&gt;() {<a name="line.908"></a>
<span class="sourceLineNo">909</span>            @Override<a name="line.909"></a>
<span class="sourceLineNo">910</span>            public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.910"></a>
<span class="sourceLineNo">911</span>                TimeLocation t1 = plc1.getTimeLocation(), t2 = plc2.getTimeLocation();<a name="line.911"></a>
<span class="sourceLineNo">912</span>                if (t1 == null || t2 == null || !t1.shareDays(t2) || !t1.shareWeeks(t2)) return true;<a name="line.912"></a>
<span class="sourceLineNo">913</span>                return t1.getStartSlot() + t1.getLength() + parameter &lt;= t2.getStartSlot() ||<a name="line.913"></a>
<span class="sourceLineNo">914</span>                        t2.getStartSlot() + t2.getLength() + parameter &lt;= t1.getStartSlot();<a name="line.914"></a>
<span class="sourceLineNo">915</span>            }<a name="line.915"></a>
<span class="sourceLineNo">916</span>            @Override<a name="line.916"></a>
<span class="sourceLineNo">917</span>            public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, Integer parameter, GroupConstraint gc, Placement plc1, Placement plc2) { return true; }<a name="line.917"></a>
<span class="sourceLineNo">918</span>            @Override<a name="line.918"></a>
<span class="sourceLineNo">919</span>            public ParametrizedConstraintType&lt;Integer&gt; create(String reference, String regexp) {<a name="line.919"></a>
<span class="sourceLineNo">920</span>                Matcher matcher = Pattern.compile(regexp).matcher(reference);<a name="line.920"></a>
<span class="sourceLineNo">921</span>                if (matcher.find()) {<a name="line.921"></a>
<span class="sourceLineNo">922</span>                    double hours = Double.parseDouble(matcher.group(1));<a name="line.922"></a>
<span class="sourceLineNo">923</span>                    int slots = (int)Math.round(12.0 * hours);<a name="line.923"></a>
<span class="sourceLineNo">924</span>                    return new ParametrizedConstraintType&lt;Integer&gt;(ConstraintType.MIN_GAP, slots, reference)<a name="line.924"></a>
<span class="sourceLineNo">925</span>                            .setName("At Least " + matcher.group(1) + " Hours Between Classes")<a name="line.925"></a>
<span class="sourceLineNo">926</span>                            .setMin(slots).setMax(slots);<a name="line.926"></a>
<span class="sourceLineNo">927</span>                }<a name="line.927"></a>
<span class="sourceLineNo">928</span>                return null;<a name="line.928"></a>
<span class="sourceLineNo">929</span>            }}),<a name="line.929"></a>
<span class="sourceLineNo">930</span>        /**<a name="line.930"></a>
<span class="sourceLineNo">931</span>         * Given classes must be taught on weeks that are back-to-back (the gap between the two assigned date patterns is less than a week).&lt;br&gt;<a name="line.931"></a>
<span class="sourceLineNo">932</span>         * When prohibited or (strongly) discouraged: any two classes must have at least a week gap in between.<a name="line.932"></a>
<span class="sourceLineNo">933</span>         */<a name="line.933"></a>
<span class="sourceLineNo">934</span>        BTB_WEEKS("BTB_WEEKS", "Back-To-Back Weeks", new PairCheck() {<a name="line.934"></a>
<span class="sourceLineNo">935</span>            @Override<a name="line.935"></a>
<span class="sourceLineNo">936</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.936"></a>
<span class="sourceLineNo">937</span>                if (gc.variables().size() &lt;= 2) {<a name="line.937"></a>
<span class="sourceLineNo">938</span>                    return gc.isBackToBackWeeks(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.938"></a>
<span class="sourceLineNo">939</span>                } else {<a name="line.939"></a>
<span class="sourceLineNo">940</span>                    int totalWeeks = 0;<a name="line.940"></a>
<span class="sourceLineNo">941</span>                    for (Lecture l: gc.variables())<a name="line.941"></a>
<span class="sourceLineNo">942</span>                        totalWeeks += l.getMinWeeks();<a name="line.942"></a>
<span class="sourceLineNo">943</span>                    return gc.isMaxWeekSpan(plc1.getTimeLocation(), plc2.getTimeLocation(), totalWeeks);<a name="line.943"></a>
<span class="sourceLineNo">944</span>                }<a name="line.944"></a>
<span class="sourceLineNo">945</span>            }<a name="line.945"></a>
<span class="sourceLineNo">946</span>            @Override<a name="line.946"></a>
<span class="sourceLineNo">947</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.947"></a>
<span class="sourceLineNo">948</span>                return gc.isNotBackToBackWeeks(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.948"></a>
<span class="sourceLineNo">949</span>            }}),<a name="line.949"></a>
<span class="sourceLineNo">950</span>        /**<a name="line.950"></a>
<span class="sourceLineNo">951</span>         * Given classes must be taught on weeks that are back-to-back and in the given order.&lt;br&gt;<a name="line.951"></a>
<span class="sourceLineNo">952</span>         * When prohibited or (strongly) discouraged: given classes must be taught on weeks in the given order with at least one week between any two following classes.<a name="line.952"></a>
<span class="sourceLineNo">953</span>         */<a name="line.953"></a>
<span class="sourceLineNo">954</span>        FOLLOWING_WEEKS("FOLLOWING_WEEKS", "Following Weeks", new PairCheck() {<a name="line.954"></a>
<span class="sourceLineNo">955</span>            @Override<a name="line.955"></a>
<span class="sourceLineNo">956</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.956"></a>
<span class="sourceLineNo">957</span>                return gc.isFollowingWeeksBTB(plc1, plc2, true);<a name="line.957"></a>
<span class="sourceLineNo">958</span>            }<a name="line.958"></a>
<span class="sourceLineNo">959</span>            @Override<a name="line.959"></a>
<span class="sourceLineNo">960</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.960"></a>
<span class="sourceLineNo">961</span>                return gc.isFollowingWeeksBTB(plc1, plc2, false);<a name="line.961"></a>
<span class="sourceLineNo">962</span>            }}),<a name="line.962"></a>
<span class="sourceLineNo">963</span>        /**<a name="line.963"></a>
<span class="sourceLineNo">964</span>         * Given classes must be taught on the same dates. If one of the classes meets more often, the class meeting less often can only meet on the dates when the other class is meeting.&lt;br&gt;<a name="line.964"></a>
<span class="sourceLineNo">965</span>         * When prohibited or (strongly) discouraged: given classes cannot be taught on the same days (there cannot be a date when both classes are meeting).&lt;br&gt;<a name="line.965"></a>
<span class="sourceLineNo">966</span>         * Note: unlike with the same days/weeks constraint, this constraint consider individual meeting dates of both classes.<a name="line.966"></a>
<span class="sourceLineNo">967</span>         */<a name="line.967"></a>
<span class="sourceLineNo">968</span>        SAME_DATES("SAME_DATES", "Same Dates", new PairCheck() {<a name="line.968"></a>
<span class="sourceLineNo">969</span>            @Override<a name="line.969"></a>
<span class="sourceLineNo">970</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.970"></a>
<span class="sourceLineNo">971</span>                return gc.isSameDates(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.971"></a>
<span class="sourceLineNo">972</span>            }<a name="line.972"></a>
<span class="sourceLineNo">973</span>            @Override<a name="line.973"></a>
<span class="sourceLineNo">974</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.974"></a>
<span class="sourceLineNo">975</span>                return gc.isDifferentDates(plc1.getTimeLocation(), plc2.getTimeLocation());<a name="line.975"></a>
<span class="sourceLineNo">976</span>            }}),<a name="line.976"></a>
<span class="sourceLineNo">977</span>        /**<a name="line.977"></a>
<span class="sourceLineNo">978</span>         * Same Days-Room-Start: Given classes must start at the same time of day, on the same days and in the same room.<a name="line.978"></a>
<span class="sourceLineNo">979</span>         * It is the combination of Same Days, Same Start and Same Room distribution preferences.<a name="line.979"></a>
<span class="sourceLineNo">980</span>         * When prohibited or (strongly) discouraged: Any pair of classes classes cannot be taught on the same days <a name="line.980"></a>
<span class="sourceLineNo">981</span>         * during the same time in the same room.<a name="line.981"></a>
<span class="sourceLineNo">982</span>         */<a name="line.982"></a>
<span class="sourceLineNo">983</span>        SAME_DAYS_ROOM_START("SAME_DAY_ROOM_START", "Same Days-Room-Start", new PairCheck() {<a name="line.983"></a>
<span class="sourceLineNo">984</span>            @Override<a name="line.984"></a>
<span class="sourceLineNo">985</span>            public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.985"></a>
<span class="sourceLineNo">986</span>                return (plc1.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY) == <a name="line.986"></a>
<span class="sourceLineNo">987</span>                        (plc2.getTimeLocation().getStartSlot() % Constants.SLOTS_PER_DAY) &amp;&amp;<a name="line.987"></a>
<span class="sourceLineNo">988</span>                        sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.988"></a>
<span class="sourceLineNo">989</span>                        plc1.sameRooms(plc2);<a name="line.989"></a>
<span class="sourceLineNo">990</span>            }<a name="line.990"></a>
<span class="sourceLineNo">991</span>            @Override<a name="line.991"></a>
<span class="sourceLineNo">992</span>            public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.992"></a>
<span class="sourceLineNo">993</span>                return !plc1.getTimeLocation().shareHours(plc2.getTimeLocation()) ||<a name="line.993"></a>
<span class="sourceLineNo">994</span>                        !plc1.getTimeLocation().shareDays(plc2.getTimeLocation()) ||<a name="line.994"></a>
<span class="sourceLineNo">995</span>                        !plc1.sameRooms(plc2);<a name="line.995"></a>
<span class="sourceLineNo">996</span>            }}),<a name="line.996"></a>
<span class="sourceLineNo">997</span>        /**<a name="line.997"></a>
<span class="sourceLineNo">998</span>         * Overnight: The constraint has two parameters: hours and distance in minutes. There is a problem when<a name="line.998"></a>
<span class="sourceLineNo">999</span>         * an evening class is followed by a morning class the next day and the time in between is less then the<a name="line.999"></a>
<span class="sourceLineNo">1000</span>         * given number of hours, but only when the distance in minutes between them is greater than the<a name="line.1000"></a>
<span class="sourceLineNo">1001</span>         * given number of minutes.<a name="line.1001"></a>
<span class="sourceLineNo">1002</span>         */<a name="line.1002"></a>
<span class="sourceLineNo">1003</span>        DAYBREAK("DAYBREAK\\(([0-9\\.]+),(-?[0-9]+)\\)", "Daybreak", new AssignmentParameterPairCheck&lt;Integer[]&gt;() {<a name="line.1003"></a>
<span class="sourceLineNo">1004</span>            @Override<a name="line.1004"></a>
<span class="sourceLineNo">1005</span>            public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, Integer[] param, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1005"></a>
<span class="sourceLineNo">1006</span>                TimeLocation t1 = plc1.getTimeLocation();<a name="line.1006"></a>
<span class="sourceLineNo">1007</span>                TimeLocation t2 = plc2.getTimeLocation();<a name="line.1007"></a>
<span class="sourceLineNo">1008</span>                if (288 + t2.getStartSlot() - t1.getStartSlot() - t1.getLength() &lt; gc.getType().getMin()) { // close to each other<a name="line.1008"></a>
<span class="sourceLineNo">1009</span>                    if (gc.isNextDay(t1, t2)) { // next day<a name="line.1009"></a>
<span class="sourceLineNo">1010</span>                        if (gc.getType().getMax() &lt; 0) { // no distance check<a name="line.1010"></a>
<span class="sourceLineNo">1011</span>                            return false;<a name="line.1011"></a>
<span class="sourceLineNo">1012</span>                        } else {<a name="line.1012"></a>
<span class="sourceLineNo">1013</span>                            DistanceMetric m = ((TimetableModel)gc.getModel()).getDistanceMetric();<a name="line.1013"></a>
<span class="sourceLineNo">1014</span>                            if (Placement.getDistanceInMinutes(m, plc1, plc2) &gt; gc.getType().getMax()) { // distance check<a name="line.1014"></a>
<span class="sourceLineNo">1015</span>                                return false;<a name="line.1015"></a>
<span class="sourceLineNo">1016</span>                            }<a name="line.1016"></a>
<span class="sourceLineNo">1017</span>                        }<a name="line.1017"></a>
<span class="sourceLineNo">1018</span>                    }<a name="line.1018"></a>
<span class="sourceLineNo">1019</span>                } else if (288 + t1.getStartSlot() - t2.getStartSlot() - t2.getLength() &lt; gc.getType().getMin()) { // close to each other, but the other way around<a name="line.1019"></a>
<span class="sourceLineNo">1020</span>                    if (gc.isNextDay(t2, t1)) { // next day<a name="line.1020"></a>
<span class="sourceLineNo">1021</span>                        if (gc.getType().getMax() &lt; 0) { // no distance check<a name="line.1021"></a>
<span class="sourceLineNo">1022</span>                            return false;<a name="line.1022"></a>
<span class="sourceLineNo">1023</span>                        } else {<a name="line.1023"></a>
<span class="sourceLineNo">1024</span>                            DistanceMetric m = ((TimetableModel)gc.getModel()).getDistanceMetric();<a name="line.1024"></a>
<span class="sourceLineNo">1025</span>                            if (Placement.getDistanceInMinutes(m, plc2, plc1) &gt; gc.getType().getMax()) { // distance check<a name="line.1025"></a>
<span class="sourceLineNo">1026</span>                                return false;<a name="line.1026"></a>
<span class="sourceLineNo">1027</span>                            }<a name="line.1027"></a>
<span class="sourceLineNo">1028</span>                        }<a name="line.1028"></a>
<span class="sourceLineNo">1029</span>                    }<a name="line.1029"></a>
<span class="sourceLineNo">1030</span>                }<a name="line.1030"></a>
<span class="sourceLineNo">1031</span>                return true;<a name="line.1031"></a>
<span class="sourceLineNo">1032</span>            }<a name="line.1032"></a>
<span class="sourceLineNo">1033</span>            @Override<a name="line.1033"></a>
<span class="sourceLineNo">1034</span>            public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, Integer[] parameter, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1034"></a>
<span class="sourceLineNo">1035</span>                return true;<a name="line.1035"></a>
<span class="sourceLineNo">1036</span>            }<a name="line.1036"></a>
<span class="sourceLineNo">1037</span>            @Override<a name="line.1037"></a>
<span class="sourceLineNo">1038</span>            public ParametrizedConstraintType&lt;Integer[]&gt; create(String reference, String regexp) {<a name="line.1038"></a>
<span class="sourceLineNo">1039</span>                Matcher matcher = Pattern.compile(regexp).matcher(reference);<a name="line.1039"></a>
<span class="sourceLineNo">1040</span>                if (matcher.find()) {<a name="line.1040"></a>
<span class="sourceLineNo">1041</span>                    double hours = Double.parseDouble(matcher.group(1));<a name="line.1041"></a>
<span class="sourceLineNo">1042</span>                    int distanceSlots = (int)Math.round(12.0 * hours);<a name="line.1042"></a>
<span class="sourceLineNo">1043</span>                    int distanceInMinutes = Integer.parseInt(matcher.group(2));<a name="line.1043"></a>
<span class="sourceLineNo">1044</span>                    return new ParametrizedConstraintType&lt;Integer[]&gt;(ConstraintType.DAYBREAK, <a name="line.1044"></a>
<span class="sourceLineNo">1045</span>                            new Integer[] {distanceSlots, distanceInMinutes}, reference)<a name="line.1045"></a>
<span class="sourceLineNo">1046</span>                            .setName("Daybreak of " + ( distanceSlots / 12.0) + " hours" + (distanceInMinutes &gt;= 0 ? " when over " + distanceInMinutes + " mins": ""))<a name="line.1046"></a>
<span class="sourceLineNo">1047</span>                            .setMin(distanceSlots).setMax(distanceInMinutes);<a name="line.1047"></a>
<span class="sourceLineNo">1048</span>                }<a name="line.1048"></a>
<span class="sourceLineNo">1049</span>                return null;<a name="line.1049"></a>
<span class="sourceLineNo">1050</span>            }}),<a name="line.1050"></a>
<span class="sourceLineNo">1051</span>            /**<a name="line.1051"></a>
<span class="sourceLineNo">1052</span>             * Online/Offline Room: Given classes, if scheduled on the same day, must be all in the online room or<a name="line.1052"></a>
<span class="sourceLineNo">1053</span>             * none of them can be in the online room. This means there is a conflict when two classes<a name="line.1053"></a>
<span class="sourceLineNo">1054</span>             * are placed on the same day, but one is in online room and the other is not.<a name="line.1054"></a>
<span class="sourceLineNo">1055</span>             */<a name="line.1055"></a>
<span class="sourceLineNo">1056</span>            ONLINE_ROOM("ONLINE_ROOM", "Online/Offline Room", new PairCheck() {<a name="line.1056"></a>
<span class="sourceLineNo">1057</span>                @Override<a name="line.1057"></a>
<span class="sourceLineNo">1058</span>                public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1058"></a>
<span class="sourceLineNo">1059</span>                    TimeLocation t1 = plc1.getTimeLocation();<a name="line.1059"></a>
<span class="sourceLineNo">1060</span>                    TimeLocation t2 = plc2.getTimeLocation();<a name="line.1060"></a>
<span class="sourceLineNo">1061</span>                    if (t1.shareDays(t2) &amp;&amp; t1.shareWeeks(t2)) {<a name="line.1061"></a>
<span class="sourceLineNo">1062</span>                        return gc.isOnline(plc1) == gc.isOnline(plc2);<a name="line.1062"></a>
<span class="sourceLineNo">1063</span>                    } else {<a name="line.1063"></a>
<span class="sourceLineNo">1064</span>                        // different days &gt; do not care<a name="line.1064"></a>
<span class="sourceLineNo">1065</span>                        return true;<a name="line.1065"></a>
<span class="sourceLineNo">1066</span>                    }<a name="line.1066"></a>
<span class="sourceLineNo">1067</span>                }<a name="line.1067"></a>
<span class="sourceLineNo">1068</span>                @Override<a name="line.1068"></a>
<span class="sourceLineNo">1069</span>                public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) { return true; }<a name="line.1069"></a>
<span class="sourceLineNo">1070</span>            }),<a name="line.1070"></a>
<span class="sourceLineNo">1071</span>            /**<a name="line.1071"></a>
<span class="sourceLineNo">1072</span>             * Same Days-Time-Weeks: The given classes must be taught at the same time of day, on the same days, and on the same weeks<a name="line.1072"></a>
<span class="sourceLineNo">1073</span>             * (i.e., they must follow the same date pattern).<a name="line.1073"></a>
<span class="sourceLineNo">1074</span>             * It is the combination of Same Days, Same Time, and Same Weeks distribution preferences.<a name="line.1074"></a>
<span class="sourceLineNo">1075</span>             * When prohibited or (strongly) discouraged: Any pair of classes cannot be taught on the same days<a name="line.1075"></a>
<span class="sourceLineNo">1076</span>             * during the same time and during overlapping date patterns. In other words, the given classes cannot overlap.<a name="line.1076"></a>
<span class="sourceLineNo">1077</span>             */<a name="line.1077"></a>
<span class="sourceLineNo">1078</span>            SAME_DATE_TIME_WEEKS("SAME_DTW", "Same Days-Time-Weeks", new PairCheck() {<a name="line.1078"></a>
<span class="sourceLineNo">1079</span>                @Override<a name="line.1079"></a>
<span class="sourceLineNo">1080</span>                public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1080"></a>
<span class="sourceLineNo">1081</span>                    return sameHours(plc1.getTimeLocation().getStartSlot(), plc1.getTimeLocation().getLength(),<a name="line.1081"></a>
<span class="sourceLineNo">1082</span>                            plc2.getTimeLocation().getStartSlot(), plc2.getTimeLocation().getLength()) &amp;&amp;<a name="line.1082"></a>
<span class="sourceLineNo">1083</span>                            sameDays(plc1.getTimeLocation().getDaysArray(), plc2.getTimeLocation().getDaysArray()) &amp;&amp;<a name="line.1083"></a>
<span class="sourceLineNo">1084</span>                            plc1.getTimeLocation().getWeekCode().equals(plc2.getTimeLocation().getWeekCode());<a name="line.1084"></a>
<span class="sourceLineNo">1085</span>                }<a name="line.1085"></a>
<span class="sourceLineNo">1086</span>                @Override<a name="line.1086"></a>
<span class="sourceLineNo">1087</span>                public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1087"></a>
<span class="sourceLineNo">1088</span>                    return !plc1.getTimeLocation().shareHours(plc2.getTimeLocation()) ||<a name="line.1088"></a>
<span class="sourceLineNo">1089</span>                            !plc1.getTimeLocation().shareDays(plc2.getTimeLocation()) ||<a name="line.1089"></a>
<span class="sourceLineNo">1090</span>                            !plc1.getTimeLocation().shareWeeks(plc2.getTimeLocation());<a name="line.1090"></a>
<span class="sourceLineNo">1091</span>                }}),<a name="line.1091"></a>
<span class="sourceLineNo">1092</span>            /**<a name="line.1092"></a>
<span class="sourceLineNo">1093</span>             * Same Students w/o Distance: This distribution is the same as the Same Students distribution,<a name="line.1093"></a>
<span class="sourceLineNo">1094</span>             * except there is no distance conflict checking and no work-day limit.<a name="line.1094"></a>
<span class="sourceLineNo">1095</span>             * Also, the distribution gets ignored when there is the Ignore Student Conflicts distribution between the two classes.<a name="line.1095"></a>
<span class="sourceLineNo">1096</span>             * This constraint can be used as the Same Student Constraint in the solver configuration, e.g., in the interactive mode,<a name="line.1096"></a>
<span class="sourceLineNo">1097</span>             * replacing the Different Time constraint which does not ignore cases when there is the Ignore Student Conflicts between<a name="line.1097"></a>
<span class="sourceLineNo">1098</span>             * two classes in a parent-child relation<a name="line.1098"></a>
<span class="sourceLineNo">1099</span>             */<a name="line.1099"></a>
<span class="sourceLineNo">1100</span>            SAME_STUD_NODST("SAME_STUD_NODST", "Same Students No Distance", new PairCheck() {<a name="line.1100"></a>
<span class="sourceLineNo">1101</span>                @Override<a name="line.1101"></a>
<span class="sourceLineNo">1102</span>                public boolean isSatisfied(GroupConstraint gc, Placement p1, Placement p2) {<a name="line.1102"></a>
<span class="sourceLineNo">1103</span>                    return p1 == null || p2 == null || StudentConflict.ignore(p1.variable(), p2.variable()) || !StudentConflict.overlaps(p1, p2);<a name="line.1103"></a>
<span class="sourceLineNo">1104</span>                }<a name="line.1104"></a>
<span class="sourceLineNo">1105</span>                @Override<a name="line.1105"></a>
<span class="sourceLineNo">1106</span>                public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1106"></a>
<span class="sourceLineNo">1107</span>                    return true;<a name="line.1107"></a>
<span class="sourceLineNo">1108</span>                }}),<a name="line.1108"></a>
<span class="sourceLineNo">1109</span>            /**<a name="line.1109"></a>
<span class="sourceLineNo">1110</span>             * Different Time with Ignore Student Conflicts: Combination of two constraints, Different Time and<a name="line.1110"></a>
<span class="sourceLineNo">1111</span>             * Ignore Student Conflicts. Given classes cannot overlap in time, replacing any student conflicts between<a name="line.1111"></a>
<span class="sourceLineNo">1112</span>             * these classes.<a name="line.1112"></a>
<span class="sourceLineNo">1113</span>             * When prohibited or (strongly) discouraged: every pair of classes in the constraint must overlap in time.<a name="line.1113"></a>
<span class="sourceLineNo">1114</span>             * Still, student conflicts are ignored.<a name="line.1114"></a>
<span class="sourceLineNo">1115</span>             */<a name="line.1115"></a>
<span class="sourceLineNo">1116</span>            DIFF_TIME_IGN_STUDS("DIFF_TIME_IGN_STUDS", "Different Time + Ignore Student Conflicts", new PairCheck() {<a name="line.1116"></a>
<span class="sourceLineNo">1117</span>                @Override<a name="line.1117"></a>
<span class="sourceLineNo">1118</span>                public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1118"></a>
<span class="sourceLineNo">1119</span>                    return !plc1.getTimeLocation().hasIntersection(plc2.getTimeLocation());<a name="line.1119"></a>
<span class="sourceLineNo">1120</span>                }<a name="line.1120"></a>
<span class="sourceLineNo">1121</span>                @Override<a name="line.1121"></a>
<span class="sourceLineNo">1122</span>                public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1122"></a>
<span class="sourceLineNo">1123</span>                    return plc1.getTimeLocation().hasIntersection(plc2.getTimeLocation());<a name="line.1123"></a>
<span class="sourceLineNo">1124</span>                }}, Flag.IGNORE_STUDENTS),<a name="line.1124"></a>
<span class="sourceLineNo">1125</span>            /**<a name="line.1125"></a>
<span class="sourceLineNo">1126</span>             * Given classes must be taught on dates that are back-to-back and in the given order.&lt;br&gt;<a name="line.1126"></a>
<span class="sourceLineNo">1127</span>             * When prohibited or (strongly) discouraged: given classes must be taught on dates in the given order with at least one day between any two following classes.&lt;br&gt;<a name="line.1127"></a>
<span class="sourceLineNo">1128</span>             * The primary use for this constraint are for classes that meet only once. <a name="line.1128"></a>
<span class="sourceLineNo">1129</span>             * The constraint will fail if one of the meetings falls on a holiday and the other does not.<a name="line.1129"></a>
<span class="sourceLineNo">1130</span>             */<a name="line.1130"></a>
<span class="sourceLineNo">1131</span>            FOLLOWING_DATES("FOLLOWING_DATES", "Following Dates", new PairCheck() {<a name="line.1131"></a>
<span class="sourceLineNo">1132</span>                @Override<a name="line.1132"></a>
<span class="sourceLineNo">1133</span>                public boolean isSatisfied(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1133"></a>
<span class="sourceLineNo">1134</span>                    return gc.isFollowingDates(plc1, plc2, true);<a name="line.1134"></a>
<span class="sourceLineNo">1135</span>                }<a name="line.1135"></a>
<span class="sourceLineNo">1136</span>                @Override<a name="line.1136"></a>
<span class="sourceLineNo">1137</span>                public boolean isViolated(GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1137"></a>
<span class="sourceLineNo">1138</span>                    return gc.isFollowingDates(plc1, plc2, false);<a name="line.1138"></a>
<span class="sourceLineNo">1139</span>                }}),<a name="line.1139"></a>
<span class="sourceLineNo">1140</span>        ;<a name="line.1140"></a>
<span class="sourceLineNo">1141</span>        <a name="line.1141"></a>
<span class="sourceLineNo">1142</span>        String iReference, iName;<a name="line.1142"></a>
<span class="sourceLineNo">1143</span>        int iFlag = 0;<a name="line.1143"></a>
<span class="sourceLineNo">1144</span>        Flag[] iFlags = null;<a name="line.1144"></a>
<span class="sourceLineNo">1145</span>        int iMin = 0, iMax = 0;<a name="line.1145"></a>
<span class="sourceLineNo">1146</span>        PairCheck iCheck = null;<a name="line.1146"></a>
<span class="sourceLineNo">1147</span>        AssignmentPairCheck iAssignmentCheck = null;<a name="line.1147"></a>
<span class="sourceLineNo">1148</span>        AssignmentParameterPairCheck&lt;?&gt; iAssignmentPairCheck = null;<a name="line.1148"></a>
<span class="sourceLineNo">1149</span>        ConstraintType(String reference, String name, Flag... flags) {<a name="line.1149"></a>
<span class="sourceLineNo">1150</span>            iReference = reference;<a name="line.1150"></a>
<span class="sourceLineNo">1151</span>            iName = name;<a name="line.1151"></a>
<span class="sourceLineNo">1152</span>            iFlags = flags;<a name="line.1152"></a>
<span class="sourceLineNo">1153</span>            for (Flag f: flags)<a name="line.1153"></a>
<span class="sourceLineNo">1154</span>                iFlag |= f.flag();<a name="line.1154"></a>
<span class="sourceLineNo">1155</span>        }<a name="line.1155"></a>
<span class="sourceLineNo">1156</span>        ConstraintType(String reference, String name, PairCheck check, Flag... flags) {<a name="line.1156"></a>
<span class="sourceLineNo">1157</span>            this(reference, name, flags);<a name="line.1157"></a>
<span class="sourceLineNo">1158</span>            iCheck = check;<a name="line.1158"></a>
<span class="sourceLineNo">1159</span>        }<a name="line.1159"></a>
<span class="sourceLineNo">1160</span>        ConstraintType(String reference, String name, AssignmentPairCheck check, Flag... flags) {<a name="line.1160"></a>
<span class="sourceLineNo">1161</span>            this(reference, name, flags);<a name="line.1161"></a>
<span class="sourceLineNo">1162</span>            iAssignmentCheck = check;<a name="line.1162"></a>
<span class="sourceLineNo">1163</span>        }<a name="line.1163"></a>
<span class="sourceLineNo">1164</span>        ConstraintType(String reference, String name, int limit, PairCheck check, Flag... flags) {<a name="line.1164"></a>
<span class="sourceLineNo">1165</span>            this(reference, name, check, flags);<a name="line.1165"></a>
<span class="sourceLineNo">1166</span>            iMin = iMax = limit;<a name="line.1166"></a>
<span class="sourceLineNo">1167</span>        }<a name="line.1167"></a>
<span class="sourceLineNo">1168</span>        ConstraintType(String reference, String name, int min, int max, PairCheck check, Flag... flags) {<a name="line.1168"></a>
<span class="sourceLineNo">1169</span>            this(reference, name, check, flags);<a name="line.1169"></a>
<span class="sourceLineNo">1170</span>            iMin = min;<a name="line.1170"></a>
<span class="sourceLineNo">1171</span>            iMax = max;<a name="line.1171"></a>
<span class="sourceLineNo">1172</span>        }<a name="line.1172"></a>
<span class="sourceLineNo">1173</span>        ConstraintType(String reference, String name, AssignmentParameterPairCheck&lt;?&gt; check, Flag... flags) {<a name="line.1173"></a>
<span class="sourceLineNo">1174</span>            this(reference, name, flags);<a name="line.1174"></a>
<span class="sourceLineNo">1175</span>            iAssignmentPairCheck = check;<a name="line.1175"></a>
<span class="sourceLineNo">1176</span>        }<a name="line.1176"></a>
<span class="sourceLineNo">1177</span>        <a name="line.1177"></a>
<span class="sourceLineNo">1178</span>        /**<a name="line.1178"></a>
<span class="sourceLineNo">1179</span>         * Constraint type<a name="line.1179"></a>
<span class="sourceLineNo">1180</span>         * @return constraint type<a name="line.1180"></a>
<span class="sourceLineNo">1181</span>         */<a name="line.1181"></a>
<span class="sourceLineNo">1182</span>        @Override<a name="line.1182"></a>
<span class="sourceLineNo">1183</span>        public ConstraintType type() { return this; }<a name="line.1183"></a>
<span class="sourceLineNo">1184</span><a name="line.1184"></a>
<span class="sourceLineNo">1185</span>        /** Constraint reference<a name="line.1185"></a>
<span class="sourceLineNo">1186</span>         * @return constraint reference<a name="line.1186"></a>
<span class="sourceLineNo">1187</span>         **/<a name="line.1187"></a>
<span class="sourceLineNo">1188</span>        @Override<a name="line.1188"></a>
<span class="sourceLineNo">1189</span>        public String reference() { return iReference; }<a name="line.1189"></a>
<span class="sourceLineNo">1190</span>        <a name="line.1190"></a>
<span class="sourceLineNo">1191</span>        /** Constraint name<a name="line.1191"></a>
<span class="sourceLineNo">1192</span>         * @return constraint name<a name="line.1192"></a>
<span class="sourceLineNo">1193</span>         **/<a name="line.1193"></a>
<span class="sourceLineNo">1194</span>        @Override<a name="line.1194"></a>
<span class="sourceLineNo">1195</span>        public String getName() { return iName; }<a name="line.1195"></a>
<span class="sourceLineNo">1196</span>        <a name="line.1196"></a>
<span class="sourceLineNo">1197</span>        /** Minimum (gap) parameter<a name="line.1197"></a>
<span class="sourceLineNo">1198</span>         * @return minimum gap (first constraint parameter)<a name="line.1198"></a>
<span class="sourceLineNo">1199</span>         **/<a name="line.1199"></a>
<span class="sourceLineNo">1200</span>        @Override<a name="line.1200"></a>
<span class="sourceLineNo">1201</span>        public int getMin() { return iMin; }<a name="line.1201"></a>
<span class="sourceLineNo">1202</span>        <a name="line.1202"></a>
<span class="sourceLineNo">1203</span>        /** Maximum (gap, hours a day) parameter <a name="line.1203"></a>
<span class="sourceLineNo">1204</span>         * @return maximum gap (second constraint parameter) <a name="line.1204"></a>
<span class="sourceLineNo">1205</span>         **/<a name="line.1205"></a>
<span class="sourceLineNo">1206</span>        @Override<a name="line.1206"></a>
<span class="sourceLineNo">1207</span>        public int getMax() { return iMax; }<a name="line.1207"></a>
<span class="sourceLineNo">1208</span>        <a name="line.1208"></a>
<span class="sourceLineNo">1209</span>        /** Flag check (true if contains given flag) <a name="line.1209"></a>
<span class="sourceLineNo">1210</span>         * @param f a flag to check<a name="line.1210"></a>
<span class="sourceLineNo">1211</span>         * @return true if present<a name="line.1211"></a>
<span class="sourceLineNo">1212</span>         **/<a name="line.1212"></a>
<span class="sourceLineNo">1213</span>        @Override<a name="line.1213"></a>
<span class="sourceLineNo">1214</span>        public boolean is(Flag f) { return (iFlag &amp; f.flag()) != 0; }<a name="line.1214"></a>
<span class="sourceLineNo">1215</span><a name="line.1215"></a>
<span class="sourceLineNo">1216</span>        /** Constraint type from reference <a name="line.1216"></a>
<span class="sourceLineNo">1217</span>         * @param reference constraint reference<a name="line.1217"></a>
<span class="sourceLineNo">1218</span>         * @return constraint of the reference<a name="line.1218"></a>
<span class="sourceLineNo">1219</span>         * @deprecated use {@link GroupConstraint#getConstraintType(String)} instead<a name="line.1219"></a>
<span class="sourceLineNo">1220</span>         **/<a name="line.1220"></a>
<span class="sourceLineNo">1221</span>        @Deprecated<a name="line.1221"></a>
<span class="sourceLineNo">1222</span>        public static ConstraintType get(String reference) {<a name="line.1222"></a>
<span class="sourceLineNo">1223</span>            for (ConstraintType t: ConstraintType.values())<a name="line.1223"></a>
<span class="sourceLineNo">1224</span>                if (t.reference().equals(reference)) return t;<a name="line.1224"></a>
<span class="sourceLineNo">1225</span>            return null;<a name="line.1225"></a>
<span class="sourceLineNo">1226</span>        }<a name="line.1226"></a>
<span class="sourceLineNo">1227</span>        <a name="line.1227"></a>
<span class="sourceLineNo">1228</span>        /** True if a required or preferred constraint is satisfied between a pair of placements <a name="line.1228"></a>
<span class="sourceLineNo">1229</span>         * @param assignment current assignment<a name="line.1229"></a>
<span class="sourceLineNo">1230</span>         * @param gc current constraint<a name="line.1230"></a>
<span class="sourceLineNo">1231</span>         * @param plc1 first placement<a name="line.1231"></a>
<span class="sourceLineNo">1232</span>         * @param plc2 second placement<a name="line.1232"></a>
<span class="sourceLineNo">1233</span>         * @return true if the two placements are consistent with the constraint if preferred or required <a name="line.1233"></a>
<span class="sourceLineNo">1234</span>         **/ <a name="line.1234"></a>
<span class="sourceLineNo">1235</span>        @Override<a name="line.1235"></a>
<span class="sourceLineNo">1236</span>        public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) {<a name="line.1236"></a>
<span class="sourceLineNo">1237</span>            if (iCheck != null &amp;&amp; !iCheck.isSatisfied(gc, plc1, plc2))<a name="line.1237"></a>
<span class="sourceLineNo">1238</span>                return false;<a name="line.1238"></a>
<span class="sourceLineNo">1239</span>            if (iAssignmentCheck != null &amp;&amp; assignment != null &amp;&amp; !iAssignmentCheck.isSatisfied(assignment, gc, plc1, plc2))<a name="line.1239"></a>
<span class="sourceLineNo">1240</span>                return false;<a name="line.1240"></a>
<span class="sourceLineNo">1241</span>            return true;<a name="line.1241"></a>
<span class="sourceLineNo">1242</span>        }<a name="line.1242"></a>
<span class="sourceLineNo">1243</span>        <a name="line.1243"></a>
<span class="sourceLineNo">1244</span>        /** True if a prohibited or discouraged constraint is satisfied between a pair of placements <a name="line.1244"></a>
<span class="sourceLineNo">1245</span>         * @param assignment current assignment<a name="line.1245"></a>
<span class="sourceLineNo">1246</span>         * @param gc current constraint<a name="line.1246"></a>
<span class="sourceLineNo">1247</span>         * @param plc1 first placement<a name="line.1247"></a>
<span class="sourceLineNo">1248</span>         * @param plc2 second placement<a name="line.1248"></a>
<span class="sourceLineNo">1249</span>         * @return true if the two placements are consistent with the constraint if discouraged or prohibited <a name="line.1249"></a>
<span class="sourceLineNo">1250</span>         **/ <a name="line.1250"></a>
<span class="sourceLineNo">1251</span>        @Override<a name="line.1251"></a>
<span class="sourceLineNo">1252</span>        public boolean isViolated(Assignment&lt;Lecture, Placement&gt; assignment, GroupConstraint gc, Placement plc1, Placement plc2) { <a name="line.1252"></a>
<span class="sourceLineNo">1253</span>            if (iCheck != null &amp;&amp; !iCheck.isViolated(gc, plc1, plc2))<a name="line.1253"></a>
<span class="sourceLineNo">1254</span>                return false;<a name="line.1254"></a>
<span class="sourceLineNo">1255</span>            if (iAssignmentCheck != null &amp;&amp; assignment != null &amp;&amp; !iAssignmentCheck.isViolated(assignment, gc, plc1, plc2))<a name="line.1255"></a>
<span class="sourceLineNo">1256</span>                return false;<a name="line.1256"></a>
<span class="sourceLineNo">1257</span>            return true;<a name="line.1257"></a>
<span class="sourceLineNo">1258</span>        }<a name="line.1258"></a>
<span class="sourceLineNo">1259</span>        /** Pair check */<a name="line.1259"></a>
<span class="sourceLineNo">1260</span>        private PairCheck check() { return iCheck; }<a name="line.1260"></a>
<span class="sourceLineNo">1261</span>    }<a name="line.1261"></a>
<span class="sourceLineNo">1262</span>    <a name="line.1262"></a>
<span class="sourceLineNo">1263</span>    /** Constraint type from reference <a name="line.1263"></a>
<span class="sourceLineNo">1264</span>     * @param reference constraint reference<a name="line.1264"></a>
<span class="sourceLineNo">1265</span>     * @return constraint of the reference<a name="line.1265"></a>
<span class="sourceLineNo">1266</span>     **/<a name="line.1266"></a>
<span class="sourceLineNo">1267</span>    public static ConstraintTypeInterface getConstraintType(String reference) {<a name="line.1267"></a>
<span class="sourceLineNo">1268</span>        for (ConstraintType t: ConstraintType.values()) {<a name="line.1268"></a>
<span class="sourceLineNo">1269</span>            if (t.reference().equals(reference)) return t;<a name="line.1269"></a>
<span class="sourceLineNo">1270</span>            if (t.iAssignmentPairCheck != null &amp;&amp; reference.matches(t.reference()))<a name="line.1270"></a>
<span class="sourceLineNo">1271</span>                return t.iAssignmentPairCheck.create(reference, t.reference());<a name="line.1271"></a>
<span class="sourceLineNo">1272</span>        }<a name="line.1272"></a>
<span class="sourceLineNo">1273</span>        return null;<a name="line.1273"></a>
<span class="sourceLineNo">1274</span>    }    <a name="line.1274"></a>
<span class="sourceLineNo">1275</span><a name="line.1275"></a>
<span class="sourceLineNo">1276</span>    public GroupConstraint() {<a name="line.1276"></a>
<span class="sourceLineNo">1277</span>    }<a name="line.1277"></a>
<span class="sourceLineNo">1278</span>    <a name="line.1278"></a>
<span class="sourceLineNo">1279</span>    @Override<a name="line.1279"></a>
<span class="sourceLineNo">1280</span>    public void setModel(Model&lt;Lecture, Placement&gt; model) {<a name="line.1280"></a>
<span class="sourceLineNo">1281</span>        super.setModel(model);<a name="line.1281"></a>
<span class="sourceLineNo">1282</span>        if (model != null) {<a name="line.1282"></a>
<span class="sourceLineNo">1283</span>            DataProperties config = ((TimetableModel)model).getProperties();<a name="line.1283"></a>
<span class="sourceLineNo">1284</span>            iDayOfWeekOffset = config.getPropertyInt("DatePattern.DayOfWeekOffset", 0);<a name="line.1284"></a>
<span class="sourceLineNo">1285</span>            iPrecedenceConsiderDatePatterns = config.getPropertyBoolean("Precedence.ConsiderDatePatterns", true);<a name="line.1285"></a>
<span class="sourceLineNo">1286</span>            iPrecedenceSkipSameDatePatternCheck = config.getPropertyBoolean("Precedence.SkipSameDatePatternCheck", true);<a name="line.1286"></a>
<span class="sourceLineNo">1287</span>            iForwardCheckMaxDepth = config.getPropertyInt("ForwardCheck.MaxDepth", iForwardCheckMaxDepth);<a name="line.1287"></a>
<span class="sourceLineNo">1288</span>            iForwardCheckMaxDomainSize = config.getPropertyInt("ForwardCheck.MaxDomainSize", iForwardCheckMaxDomainSize);<a name="line.1288"></a>
<span class="sourceLineNo">1289</span>            iMaxNHoursADayPrecideComputation = config.getPropertyBoolean("MaxNHoursADay.PreciseComputation", iMaxNHoursADayPrecideComputation);<a name="line.1289"></a>
<span class="sourceLineNo">1290</span>            iMaxNHoursADayConsiderDatePatterns = config.getPropertyBoolean("MaxNHoursADay.ConsiderDatePatterns", iMaxNHoursADayConsiderDatePatterns);<a name="line.1290"></a>
<span class="sourceLineNo">1291</span>            iNrWorkDays = (config.getPropertyInt("General.LastWorkDay", 4) - config.getPropertyInt("General.FirstWorkDay", 0) + 1);<a name="line.1291"></a>
<span class="sourceLineNo">1292</span>            if (iNrWorkDays &lt;= 0) iNrWorkDays += 7;<a name="line.1292"></a>
<span class="sourceLineNo">1293</span>            if (iNrWorkDays &gt; 7) iNrWorkDays -= 7;<a name="line.1293"></a>
<span class="sourceLineNo">1294</span>            iFirstWorkDay = config.getPropertyInt("General.FirstWorkDay", 0);<a name="line.1294"></a>
<span class="sourceLineNo">1295</span>            iOnlineRoom = config.getProperty("General.OnlineRoom", "(?i)ONLINE|");<a name="line.1295"></a>
<span class="sourceLineNo">1296</span>        }<a name="line.1296"></a>
<span class="sourceLineNo">1297</span>    }<a name="line.1297"></a>
<span class="sourceLineNo">1298</span><a name="line.1298"></a>
<span class="sourceLineNo">1299</span>    @Override<a name="line.1299"></a>
<span class="sourceLineNo">1300</span>    public void addVariable(Lecture lecture) {<a name="line.1300"></a>
<span class="sourceLineNo">1301</span>        if (!variables().contains(lecture))<a name="line.1301"></a>
<span class="sourceLineNo">1302</span>            super.addVariable(lecture);<a name="line.1302"></a>
<span class="sourceLineNo">1303</span>        if (getType().is(Flag.CH_NOTOVERLAP)) {<a name="line.1303"></a>
<span class="sourceLineNo">1304</span>            if (lecture.getChildrenSubpartIds() != null) {<a name="line.1304"></a>
<span class="sourceLineNo">1305</span>                for (Long subpartId: lecture.getChildrenSubpartIds()) {<a name="line.1305"></a>
<span class="sourceLineNo">1306</span>                    for (Lecture ch : lecture.getChildren(subpartId)) {<a name="line.1306"></a>
<span class="sourceLineNo">1307</span>                        if (!variables().contains(ch))<a name="line.1307"></a>
<span class="sourceLineNo">1308</span>                            super.addVariable(ch);<a name="line.1308"></a>
<span class="sourceLineNo">1309</span>                    }<a name="line.1309"></a>
<span class="sourceLineNo">1310</span>                }<a name="line.1310"></a>
<span class="sourceLineNo">1311</span>            }<a name="line.1311"></a>
<span class="sourceLineNo">1312</span>        }<a name="line.1312"></a>
<span class="sourceLineNo">1313</span>    }<a name="line.1313"></a>
<span class="sourceLineNo">1314</span><a name="line.1314"></a>
<span class="sourceLineNo">1315</span>    @Override<a name="line.1315"></a>
<span class="sourceLineNo">1316</span>    public void removeVariable(Lecture lecture) {<a name="line.1316"></a>
<span class="sourceLineNo">1317</span>        if (variables().contains(lecture))<a name="line.1317"></a>
<span class="sourceLineNo">1318</span>            super.removeVariable(lecture);<a name="line.1318"></a>
<span class="sourceLineNo">1319</span>        if (getType().is(Flag.CH_NOTOVERLAP)) {<a name="line.1319"></a>
<span class="sourceLineNo">1320</span>            if (lecture.getChildrenSubpartIds() != null) {<a name="line.1320"></a>
<span class="sourceLineNo">1321</span>                for (Long subpartId: lecture.getChildrenSubpartIds()) {<a name="line.1321"></a>
<span class="sourceLineNo">1322</span>                    for (Lecture ch : lecture.getChildren(subpartId)) {<a name="line.1322"></a>
<span class="sourceLineNo">1323</span>                        if (variables().contains(ch))<a name="line.1323"></a>
<span class="sourceLineNo">1324</span>                            super.removeVariable(ch);<a name="line.1324"></a>
<span class="sourceLineNo">1325</span>                    }<a name="line.1325"></a>
<span class="sourceLineNo">1326</span>                }<a name="line.1326"></a>
<span class="sourceLineNo">1327</span>            }<a name="line.1327"></a>
<span class="sourceLineNo">1328</span>        }<a name="line.1328"></a>
<span class="sourceLineNo">1329</span>    }<a name="line.1329"></a>
<span class="sourceLineNo">1330</span><a name="line.1330"></a>
<span class="sourceLineNo">1331</span>    /**<a name="line.1331"></a>
<span class="sourceLineNo">1332</span>     * Constructor<a name="line.1332"></a>
<span class="sourceLineNo">1333</span>     * <a name="line.1333"></a>
<span class="sourceLineNo">1334</span>     * @param id<a name="line.1334"></a>
<span class="sourceLineNo">1335</span>     *            constraint id<a name="line.1335"></a>
<span class="sourceLineNo">1336</span>     * @param type<a name="line.1336"></a>
<span class="sourceLineNo">1337</span>     *            constraString type (e.g, {@link ConstraintType#SAME_TIME})<a name="line.1337"></a>
<span class="sourceLineNo">1338</span>     * @param preference<a name="line.1338"></a>
<span class="sourceLineNo">1339</span>     *            time preference ("R" for required, "P" for prohibited, "-2",<a name="line.1339"></a>
<span class="sourceLineNo">1340</span>     *            "-1", "1", "2" for soft preference)<a name="line.1340"></a>
<span class="sourceLineNo">1341</span>     */<a name="line.1341"></a>
<span class="sourceLineNo">1342</span>    public GroupConstraint(Long id, ConstraintTypeInterface type, String preference) {<a name="line.1342"></a>
<span class="sourceLineNo">1343</span>        iConstraintId = id;<a name="line.1343"></a>
<span class="sourceLineNo">1344</span>        iType = type;<a name="line.1344"></a>
<span class="sourceLineNo">1345</span>        iIsRequired = preference.equals(Constants.sPreferenceRequired);<a name="line.1345"></a>
<span class="sourceLineNo">1346</span>        iIsProhibited = preference.equals(Constants.sPreferenceProhibited);<a name="line.1346"></a>
<span class="sourceLineNo">1347</span>        iPreference = Constants.preference2preferenceLevel(preference);<a name="line.1347"></a>
<span class="sourceLineNo">1348</span>    }<a name="line.1348"></a>
<span class="sourceLineNo">1349</span><a name="line.1349"></a>
<span class="sourceLineNo">1350</span>    /** Constraint id <a name="line.1350"></a>
<span class="sourceLineNo">1351</span>     * @return constraint unique id<a name="line.1351"></a>
<span class="sourceLineNo">1352</span>     **/<a name="line.1352"></a>
<span class="sourceLineNo">1353</span>    public Long getConstraintId() {<a name="line.1353"></a>
<span class="sourceLineNo">1354</span>        return iConstraintId;<a name="line.1354"></a>
<span class="sourceLineNo">1355</span>    }<a name="line.1355"></a>
<span class="sourceLineNo">1356</span><a name="line.1356"></a>
<span class="sourceLineNo">1357</span>    @Override<a name="line.1357"></a>
<span class="sourceLineNo">1358</span>    public long getId() {<a name="line.1358"></a>
<span class="sourceLineNo">1359</span>        return (iConstraintId == null ? -1 : iConstraintId.longValue());<a name="line.1359"></a>
<span class="sourceLineNo">1360</span>    }<a name="line.1360"></a>
<span class="sourceLineNo">1361</span>    <a name="line.1361"></a>
<span class="sourceLineNo">1362</span>    /** Generated unique id <a name="line.1362"></a>
<span class="sourceLineNo">1363</span>     * @return generated unique id<a name="line.1363"></a>
<span class="sourceLineNo">1364</span>     **/<a name="line.1364"></a>
<span class="sourceLineNo">1365</span>    protected long getGeneratedId() {<a name="line.1365"></a>
<span class="sourceLineNo">1366</span>        return iId;<a name="line.1366"></a>
<span class="sourceLineNo">1367</span>    }<a name="line.1367"></a>
<span class="sourceLineNo">1368</span><a name="line.1368"></a>
<span class="sourceLineNo">1369</span>    /** Return constraint type (e.g, {@link ConstraintType#SAME_TIME}) <a name="line.1369"></a>
<span class="sourceLineNo">1370</span>     * @return constraint type<a name="line.1370"></a>
<span class="sourceLineNo">1371</span>     **/<a name="line.1371"></a>
<span class="sourceLineNo">1372</span>    public ConstraintTypeInterface getType() {<a name="line.1372"></a>
<span class="sourceLineNo">1373</span>        return iType;<a name="line.1373"></a>
<span class="sourceLineNo">1374</span>    }<a name="line.1374"></a>
<span class="sourceLineNo">1375</span><a name="line.1375"></a>
<span class="sourceLineNo">1376</span>    /**<a name="line.1376"></a>
<span class="sourceLineNo">1377</span>     * Set constraint type<a name="line.1377"></a>
<span class="sourceLineNo">1378</span>     * @param type constraint type<a name="line.1378"></a>
<span class="sourceLineNo">1379</span>     */<a name="line.1379"></a>
<span class="sourceLineNo">1380</span>    public void setType(ConstraintType type) {<a name="line.1380"></a>
<span class="sourceLineNo">1381</span>        iType = type;<a name="line.1381"></a>
<span class="sourceLineNo">1382</span>    }<a name="line.1382"></a>
<span class="sourceLineNo">1383</span><a name="line.1383"></a>
<span class="sourceLineNo">1384</span>    /** Is constraint required <a name="line.1384"></a>
<span class="sourceLineNo">1385</span>     * @return true if required<a name="line.1385"></a>
<span class="sourceLineNo">1386</span>     **/<a name="line.1386"></a>
<span class="sourceLineNo">1387</span>    public boolean isRequired() {<a name="line.1387"></a>
<span class="sourceLineNo">1388</span>        return iIsRequired;<a name="line.1388"></a>
<span class="sourceLineNo">1389</span>    }<a name="line.1389"></a>
<span class="sourceLineNo">1390</span><a name="line.1390"></a>
<span class="sourceLineNo">1391</span>    /** Is constraint prohibited <a name="line.1391"></a>
<span class="sourceLineNo">1392</span>     * @return true if prohibited<a name="line.1392"></a>
<span class="sourceLineNo">1393</span>     **/<a name="line.1393"></a>
<span class="sourceLineNo">1394</span>    public boolean isProhibited() {<a name="line.1394"></a>
<span class="sourceLineNo">1395</span>        return iIsProhibited;<a name="line.1395"></a>
<span class="sourceLineNo">1396</span>    }<a name="line.1396"></a>
<span class="sourceLineNo">1397</span><a name="line.1397"></a>
<span class="sourceLineNo">1398</span>    /**<a name="line.1398"></a>
<span class="sourceLineNo">1399</span>     * Prolog reference: "R" for required, "P" for prohibited", "-2",.."2" for<a name="line.1399"></a>
<span class="sourceLineNo">1400</span>     * preference<a name="line.1400"></a>
<span class="sourceLineNo">1401</span>     * @return prolog preference<a name="line.1401"></a>
<span class="sourceLineNo">1402</span>     */<a name="line.1402"></a>
<span class="sourceLineNo">1403</span>    public String getPrologPreference() {<a name="line.1403"></a>
<span class="sourceLineNo">1404</span>        return Constants.preferenceLevel2preference(iPreference);<a name="line.1404"></a>
<span class="sourceLineNo">1405</span>    }<a name="line.1405"></a>
<span class="sourceLineNo">1406</span><a name="line.1406"></a>
<span class="sourceLineNo">1407</span>    @Override<a name="line.1407"></a>
<span class="sourceLineNo">1408</span>    public boolean isConsistent(Placement value1, Placement value2) {<a name="line.1408"></a>
<span class="sourceLineNo">1409</span>        if (!isHard())<a name="line.1409"></a>
<span class="sourceLineNo">1410</span>            return true;<a name="line.1410"></a>
<span class="sourceLineNo">1411</span>        if (!isSatisfiedPair(null, value1, value2))<a name="line.1411"></a>
<span class="sourceLineNo">1412</span>            return false;<a name="line.1412"></a>
<span class="sourceLineNo">1413</span>        if (getType().is(Flag.BACK_TO_BACK)) {<a name="line.1413"></a>
<span class="sourceLineNo">1414</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1414"></a>
<span class="sourceLineNo">1415</span>            assignments.put(value1.variable(), value1);<a name="line.1415"></a>
<span class="sourceLineNo">1416</span>            assignments.put(value2.variable(), value2);<a name="line.1416"></a>
<span class="sourceLineNo">1417</span>            if (!isSatisfiedSeq(null, assignments, null))<a name="line.1417"></a>
<span class="sourceLineNo">1418</span>                return false;<a name="line.1418"></a>
<span class="sourceLineNo">1419</span>        }<a name="line.1419"></a>
<span class="sourceLineNo">1420</span>        if (getType().is(Flag.MAX_HRS_DAY)) {<a name="line.1420"></a>
<span class="sourceLineNo">1421</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1421"></a>
<span class="sourceLineNo">1422</span>            assignments.put(value1.variable(), value1);<a name="line.1422"></a>
<span class="sourceLineNo">1423</span>            assignments.put(value2.variable(), value2);<a name="line.1423"></a>
<span class="sourceLineNo">1424</span>            for (int dayCode: Constants.DAY_CODES) {<a name="line.1424"></a>
<span class="sourceLineNo">1425</span>                if (iMaxNHoursADayPrecideComputation) {<a name="line.1425"></a>
<span class="sourceLineNo">1426</span>                    for (IntEnumeration dates = value1.getTimeLocation().getDates(iDayOfWeekOffset); dates.hasMoreElements(); ) {<a name="line.1426"></a>
<span class="sourceLineNo">1427</span>                        int date = dates.nextElement();<a name="line.1427"></a>
<span class="sourceLineNo">1428</span>                        if (!value2.getTimeLocation().hasDate(date, iDayOfWeekOffset)) continue;<a name="line.1428"></a>
<span class="sourceLineNo">1429</span>                        if (nrSlotsADay(null, date, assignments, null) &gt; getType().getMax()) return false;<a name="line.1429"></a>
<span class="sourceLineNo">1430</span>                    }<a name="line.1430"></a>
<span class="sourceLineNo">1431</span>                } else if (iMaxNHoursADayConsiderDatePatterns) {<a name="line.1431"></a>
<span class="sourceLineNo">1432</span>                    for (BitSet week: ((TimetableModel)getModel()).getWeeks()) {<a name="line.1432"></a>
<span class="sourceLineNo">1433</span>                        if (!value1.getTimeLocation().shareWeeks(week) &amp;&amp; !value2.getTimeLocation().shareWeeks(week)) continue;<a name="line.1433"></a>
<span class="sourceLineNo">1434</span>                        if (nrSlotsADay(null, dayCode, week, assignments, null) &gt; getType().getMax()) return false;<a name="line.1434"></a>
<span class="sourceLineNo">1435</span>                    }<a name="line.1435"></a>
<span class="sourceLineNo">1436</span>                } else {<a name="line.1436"></a>
<span class="sourceLineNo">1437</span>                    if (nrSlotsADay(null, dayCode, null, assignments, null) &gt; getType().getMax()) return false;<a name="line.1437"></a>
<span class="sourceLineNo">1438</span>                }<a name="line.1438"></a>
<span class="sourceLineNo">1439</span>            }<a name="line.1439"></a>
<span class="sourceLineNo">1440</span>        }<a name="line.1440"></a>
<span class="sourceLineNo">1441</span>        return true;<a name="line.1441"></a>
<span class="sourceLineNo">1442</span>    }<a name="line.1442"></a>
<span class="sourceLineNo">1443</span><a name="line.1443"></a>
<span class="sourceLineNo">1444</span>    @Override<a name="line.1444"></a>
<span class="sourceLineNo">1445</span>    public void computeConflicts(Assignment&lt;Lecture, Placement&gt; assignment, Placement value, Set&lt;Placement&gt; conflicts) {<a name="line.1445"></a>
<span class="sourceLineNo">1446</span>        computeConflicts(assignment, value, conflicts, true);<a name="line.1446"></a>
<span class="sourceLineNo">1447</span>    }<a name="line.1447"></a>
<span class="sourceLineNo">1448</span>    <a name="line.1448"></a>
<span class="sourceLineNo">1449</span>    @Override<a name="line.1449"></a>
<span class="sourceLineNo">1450</span>    public void computeConflictsNoForwardCheck(Assignment&lt;Lecture, Placement&gt; assignment, Placement value, Set&lt;Placement&gt; conflicts) {<a name="line.1450"></a>
<span class="sourceLineNo">1451</span>        computeConflicts(assignment, value, conflicts, false);<a name="line.1451"></a>
<span class="sourceLineNo">1452</span>    }<a name="line.1452"></a>
<span class="sourceLineNo">1453</span>    <a name="line.1453"></a>
<span class="sourceLineNo">1454</span>    public void computeConflicts(Assignment&lt;Lecture, Placement&gt; assignment, Placement value, Set&lt;Placement&gt; conflicts, boolean fwdCheck) {<a name="line.1454"></a>
<span class="sourceLineNo">1455</span>        if (!isHard())<a name="line.1455"></a>
<span class="sourceLineNo">1456</span>            return;<a name="line.1456"></a>
<span class="sourceLineNo">1457</span>        for (Lecture v : variables()) {<a name="line.1457"></a>
<span class="sourceLineNo">1458</span>            if (v.equals(value.variable()))<a name="line.1458"></a>
<span class="sourceLineNo">1459</span>                continue; // ignore this variable<a name="line.1459"></a>
<span class="sourceLineNo">1460</span>            Placement p = assignment.getValue(v);<a name="line.1460"></a>
<span class="sourceLineNo">1461</span>            if (p == null)<a name="line.1461"></a>
<span class="sourceLineNo">1462</span>                continue; // there is an unassigned variable -- great, still a chance to get violated<a name="line.1462"></a>
<span class="sourceLineNo">1463</span>            if (!isSatisfiedPair(assignment, p, value))<a name="line.1463"></a>
<span class="sourceLineNo">1464</span>                conflicts.add(p);<a name="line.1464"></a>
<span class="sourceLineNo">1465</span>        }<a name="line.1465"></a>
<span class="sourceLineNo">1466</span>        if (getType().is(Flag.BACK_TO_BACK)) {<a name="line.1466"></a>
<span class="sourceLineNo">1467</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1467"></a>
<span class="sourceLineNo">1468</span>            assignments.put(value.variable(), value);<a name="line.1468"></a>
<span class="sourceLineNo">1469</span>            if (!isSatisfiedSeq(assignment, assignments, conflicts))<a name="line.1469"></a>
<span class="sourceLineNo">1470</span>                conflicts.add(value);<a name="line.1470"></a>
<span class="sourceLineNo">1471</span>        }<a name="line.1471"></a>
<span class="sourceLineNo">1472</span>        if (getType().is(Flag.MAX_HRS_DAY)) {<a name="line.1472"></a>
<span class="sourceLineNo">1473</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1473"></a>
<span class="sourceLineNo">1474</span>            assignments.put(value.variable(), value);<a name="line.1474"></a>
<span class="sourceLineNo">1475</span>            for (int dayCode: Constants.DAY_CODES) {<a name="line.1475"></a>
<span class="sourceLineNo">1476</span>                if (iMaxNHoursADayPrecideComputation) {<a name="line.1476"></a>
<span class="sourceLineNo">1477</span>                    for (IntEnumeration dates = value.getTimeLocation().getDates(iDayOfWeekOffset); dates.hasMoreElements(); ) {<a name="line.1477"></a>
<span class="sourceLineNo">1478</span>                        int date = dates.nextElement();<a name="line.1478"></a>
<span class="sourceLineNo">1479</span>                        if (nrSlotsADay(assignment, date, assignments, conflicts) &gt; getType().getMax()) {<a name="line.1479"></a>
<span class="sourceLineNo">1480</span>                            List&lt;Placement&gt; adepts = new ArrayList&lt;Placement&gt;();<a name="line.1480"></a>
<span class="sourceLineNo">1481</span>                            for (Lecture l: variables()) {<a name="line.1481"></a>
<span class="sourceLineNo">1482</span>                                if (l.equals(value.variable()) || l.isConstant()) continue;<a name="line.1482"></a>
<span class="sourceLineNo">1483</span>                                Placement p = assignment.getValue(l);<a name="line.1483"></a>
<span class="sourceLineNo">1484</span>                                if (p == null || conflicts.contains(p) || p.getTimeLocation() == null) continue;<a name="line.1484"></a>
<span class="sourceLineNo">1485</span>                                if (!p.getTimeLocation().hasDate(date, iDayOfWeekOffset)) continue;<a name="line.1485"></a>
<span class="sourceLineNo">1486</span>                                adepts.add(p);<a name="line.1486"></a>
<span class="sourceLineNo">1487</span>                            }<a name="line.1487"></a>
<span class="sourceLineNo">1488</span>                            do {<a name="line.1488"></a>
<span class="sourceLineNo">1489</span>                                if (adepts.isEmpty()) { conflicts.add(value); break; }<a name="line.1489"></a>
<span class="sourceLineNo">1490</span>                                Placement conflict = ToolBox.random(adepts);<a name="line.1490"></a>
<span class="sourceLineNo">1491</span>                                adepts.remove(conflict);<a name="line.1491"></a>
<span class="sourceLineNo">1492</span>                                conflicts.add(conflict);<a name="line.1492"></a>
<span class="sourceLineNo">1493</span>                            } while (nrSlotsADay(assignment, date, assignments, conflicts) &gt; getType().getMax());<a name="line.1493"></a>
<span class="sourceLineNo">1494</span>                        }<a name="line.1494"></a>
<span class="sourceLineNo">1495</span>                    }<a name="line.1495"></a>
<span class="sourceLineNo">1496</span>                } else if (iMaxNHoursADayConsiderDatePatterns) {<a name="line.1496"></a>
<span class="sourceLineNo">1497</span>                    for (BitSet week: ((TimetableModel)getModel()).getWeeks()) {<a name="line.1497"></a>
<span class="sourceLineNo">1498</span>                        if (!value.getTimeLocation().shareWeeks(week)) continue;<a name="line.1498"></a>
<span class="sourceLineNo">1499</span>                        if (nrSlotsADay(assignment, dayCode, week, assignments, conflicts) &gt; getType().getMax()) {<a name="line.1499"></a>
<span class="sourceLineNo">1500</span>                            List&lt;Placement&gt; adepts = new ArrayList&lt;Placement&gt;();<a name="line.1500"></a>
<span class="sourceLineNo">1501</span>                            for (Lecture l: variables()) {<a name="line.1501"></a>
<span class="sourceLineNo">1502</span>                                if (l.equals(value.variable()) || l.isConstant()) continue;<a name="line.1502"></a>
<span class="sourceLineNo">1503</span>                                Placement p = assignment.getValue(l);<a name="line.1503"></a>
<span class="sourceLineNo">1504</span>                                if (p == null || conflicts.contains(p) || p.getTimeLocation() == null) continue;<a name="line.1504"></a>
<span class="sourceLineNo">1505</span>                                if ((p.getTimeLocation().getDayCode() &amp; dayCode) == 0 || !p.getTimeLocation().shareWeeks(week)) continue;<a name="line.1505"></a>
<span class="sourceLineNo">1506</span>                                adepts.add(p);<a name="line.1506"></a>
<span class="sourceLineNo">1507</span>                            }<a name="line.1507"></a>
<span class="sourceLineNo">1508</span>                            do {<a name="line.1508"></a>
<span class="sourceLineNo">1509</span>                                if (adepts.isEmpty()) { conflicts.add(value); break; }<a name="line.1509"></a>
<span class="sourceLineNo">1510</span>                                Placement conflict = ToolBox.random(adepts);<a name="line.1510"></a>
<span class="sourceLineNo">1511</span>                                adepts.remove(conflict);<a name="line.1511"></a>
<span class="sourceLineNo">1512</span>                                conflicts.add(conflict);<a name="line.1512"></a>
<span class="sourceLineNo">1513</span>                            } while (nrSlotsADay(assignment, dayCode, week, assignments, conflicts) &gt; getType().getMax());<a name="line.1513"></a>
<span class="sourceLineNo">1514</span>                        }<a name="line.1514"></a>
<span class="sourceLineNo">1515</span>                    }<a name="line.1515"></a>
<span class="sourceLineNo">1516</span>                } else {<a name="line.1516"></a>
<span class="sourceLineNo">1517</span>                    if (nrSlotsADay(assignment, dayCode, null, assignments, conflicts) &gt; getType().getMax()) {<a name="line.1517"></a>
<span class="sourceLineNo">1518</span>                        List&lt;Placement&gt; adepts = new ArrayList&lt;Placement&gt;();<a name="line.1518"></a>
<span class="sourceLineNo">1519</span>                        for (Lecture l: variables()) {<a name="line.1519"></a>
<span class="sourceLineNo">1520</span>                            if (l.equals(value.variable()) || l.isConstant()) continue;<a name="line.1520"></a>
<span class="sourceLineNo">1521</span>                            Placement p = assignment.getValue(l);<a name="line.1521"></a>
<span class="sourceLineNo">1522</span>                            if (p == null || conflicts.contains(p) || p.getTimeLocation() == null) continue;<a name="line.1522"></a>
<span class="sourceLineNo">1523</span>                            if ((p.getTimeLocation().getDayCode() &amp; dayCode) == 0) continue;<a name="line.1523"></a>
<span class="sourceLineNo">1524</span>                            adepts.add(p);<a name="line.1524"></a>
<span class="sourceLineNo">1525</span>                        }<a name="line.1525"></a>
<span class="sourceLineNo">1526</span>                        do {<a name="line.1526"></a>
<span class="sourceLineNo">1527</span>                            if (adepts.isEmpty()) { conflicts.add(value); break; }<a name="line.1527"></a>
<span class="sourceLineNo">1528</span>                            Placement conflict = ToolBox.random(adepts);<a name="line.1528"></a>
<span class="sourceLineNo">1529</span>                            adepts.remove(conflict);<a name="line.1529"></a>
<span class="sourceLineNo">1530</span>                            conflicts.add(conflict);<a name="line.1530"></a>
<span class="sourceLineNo">1531</span>                        } while (nrSlotsADay(assignment, dayCode, null, assignments, conflicts) &gt; getType().getMax());<a name="line.1531"></a>
<span class="sourceLineNo">1532</span>                    }<a name="line.1532"></a>
<span class="sourceLineNo">1533</span>                }<a name="line.1533"></a>
<span class="sourceLineNo">1534</span>            }<a name="line.1534"></a>
<span class="sourceLineNo">1535</span>        }<a name="line.1535"></a>
<span class="sourceLineNo">1536</span>        <a name="line.1536"></a>
<span class="sourceLineNo">1537</span>        // Forward checking<a name="line.1537"></a>
<span class="sourceLineNo">1538</span>        if (fwdCheck) forwardCheck(assignment, value, conflicts, new HashSet&lt;GroupConstraint&gt;(), iForwardCheckMaxDepth - 1);<a name="line.1538"></a>
<span class="sourceLineNo">1539</span>    }<a name="line.1539"></a>
<span class="sourceLineNo">1540</span>    <a name="line.1540"></a>
<span class="sourceLineNo">1541</span>    public void forwardCheck(Assignment&lt;Lecture, Placement&gt; assignment, Placement value, Set&lt;Placement&gt; conflicts, Set&lt;GroupConstraint&gt; ignore, int depth) {<a name="line.1541"></a>
<span class="sourceLineNo">1542</span>        try {<a name="line.1542"></a>
<span class="sourceLineNo">1543</span>            if (depth &lt; 0) return;<a name="line.1543"></a>
<span class="sourceLineNo">1544</span>            ignore.add(this);<a name="line.1544"></a>
<span class="sourceLineNo">1545</span>            <a name="line.1545"></a>
<span class="sourceLineNo">1546</span>            List&lt;Placement&gt; neededSize = null;<a name="line.1546"></a>
<span class="sourceLineNo">1547</span>            <a name="line.1547"></a>
<span class="sourceLineNo">1548</span>            for (Lecture lecture: variables()) {<a name="line.1548"></a>
<span class="sourceLineNo">1549</span>                if (conflicts.contains(value)) break; // already conflicting<a name="line.1549"></a>
<span class="sourceLineNo">1550</span><a name="line.1550"></a>
<span class="sourceLineNo">1551</span>                if (lecture.equals(value.variable())) continue; // Skip this lecture<a name="line.1551"></a>
<span class="sourceLineNo">1552</span>                Placement current = assignment.getValue(lecture);<a name="line.1552"></a>
<span class="sourceLineNo">1553</span>                if (current != null) { // Has assignment, check whether it is conflicting<a name="line.1553"></a>
<span class="sourceLineNo">1554</span>                    if (isSatisfiedPair(assignment, value, current)) {<a name="line.1554"></a>
<span class="sourceLineNo">1555</span>                        // Increase needed size if the assignment is of the same room and overlapping in time<a name="line.1555"></a>
<span class="sourceLineNo">1556</span>                        if (canShareRoom() &amp;&amp; sameRoomAndOverlaps(value, current)) {<a name="line.1556"></a>
<span class="sourceLineNo">1557</span>                            if (neededSize == null) neededSize = new ArrayList&lt;Placement&gt;(); <a name="line.1557"></a>
<span class="sourceLineNo">1558</span>                            neededSize.add(current);<a name="line.1558"></a>
<span class="sourceLineNo">1559</span>                        }<a name="line.1559"></a>
<span class="sourceLineNo">1560</span>                        continue;<a name="line.1560"></a>
<span class="sourceLineNo">1561</span>                    }<a name="line.1561"></a>
<span class="sourceLineNo">1562</span>                    conflicts.add(current);<a name="line.1562"></a>
<span class="sourceLineNo">1563</span>                }<a name="line.1563"></a>
<span class="sourceLineNo">1564</span>                <a name="line.1564"></a>
<span class="sourceLineNo">1565</span>                // Look for supporting assignments assignment<a name="line.1565"></a>
<span class="sourceLineNo">1566</span>                boolean shareRoomAndOverlaps = canShareRoom();<a name="line.1566"></a>
<span class="sourceLineNo">1567</span>                Placement support = null;<a name="line.1567"></a>
<span class="sourceLineNo">1568</span>                int nrSupports = 0;<a name="line.1568"></a>
<span class="sourceLineNo">1569</span>                if (lecture.nrValues() &gt;= iForwardCheckMaxDomainSize) {<a name="line.1569"></a>
<span class="sourceLineNo">1570</span>                    // ignore variables with large domains<a name="line.1570"></a>
<span class="sourceLineNo">1571</span>                    return;<a name="line.1571"></a>
<span class="sourceLineNo">1572</span>                }<a name="line.1572"></a>
<span class="sourceLineNo">1573</span>                List&lt;Placement&gt; values = lecture.values(assignment);<a name="line.1573"></a>
<span class="sourceLineNo">1574</span>                if (values.isEmpty()) {<a name="line.1574"></a>
<span class="sourceLineNo">1575</span>                    // ignore variables with empty domain<a name="line.1575"></a>
<span class="sourceLineNo">1576</span>                    return;<a name="line.1576"></a>
<span class="sourceLineNo">1577</span>                }<a name="line.1577"></a>
<span class="sourceLineNo">1578</span>                for (Placement other: values) {<a name="line.1578"></a>
<span class="sourceLineNo">1579</span>                    if (nrSupports &lt; 2) {<a name="line.1579"></a>
<span class="sourceLineNo">1580</span>                        if (isSatisfiedPair(assignment, value, other)) {<a name="line.1580"></a>
<span class="sourceLineNo">1581</span>                            if (support == null) support = other;<a name="line.1581"></a>
<span class="sourceLineNo">1582</span>                            nrSupports ++;<a name="line.1582"></a>
<span class="sourceLineNo">1583</span>                            if (shareRoomAndOverlaps &amp;&amp; !sameRoomAndOverlaps(value, other))<a name="line.1583"></a>
<span class="sourceLineNo">1584</span>                                shareRoomAndOverlaps = false;<a name="line.1584"></a>
<span class="sourceLineNo">1585</span>                        }<a name="line.1585"></a>
<span class="sourceLineNo">1586</span>                    } else if (shareRoomAndOverlaps &amp;&amp; !sameRoomAndOverlaps(value, other) &amp;&amp; isSatisfiedPair(assignment, value, other)) {<a name="line.1586"></a>
<span class="sourceLineNo">1587</span>                        shareRoomAndOverlaps = false;<a name="line.1587"></a>
<span class="sourceLineNo">1588</span>                    }<a name="line.1588"></a>
<span class="sourceLineNo">1589</span>                    if (nrSupports &gt; 1 &amp;&amp; !shareRoomAndOverlaps)<a name="line.1589"></a>
<span class="sourceLineNo">1590</span>                        break;<a name="line.1590"></a>
<span class="sourceLineNo">1591</span>                }<a name="line.1591"></a>
<span class="sourceLineNo">1592</span>                <a name="line.1592"></a>
<span class="sourceLineNo">1593</span>                // No supporting assignment -&gt; fail<a name="line.1593"></a>
<span class="sourceLineNo">1594</span>                if (nrSupports == 0) {<a name="line.1594"></a>
<span class="sourceLineNo">1595</span>                    conflicts.add(value); // other class cannot be assigned with this value<a name="line.1595"></a>
<span class="sourceLineNo">1596</span>                    return;<a name="line.1596"></a>
<span class="sourceLineNo">1597</span>                }<a name="line.1597"></a>
<span class="sourceLineNo">1598</span>                // Increase needed size if all supporters are of the same room and in overlapping times<a name="line.1598"></a>
<span class="sourceLineNo">1599</span>                if (shareRoomAndOverlaps &amp;&amp; support != null) {<a name="line.1599"></a>
<span class="sourceLineNo">1600</span>                    if (neededSize == null) neededSize = new ArrayList&lt;Placement&gt;(); <a name="line.1600"></a>
<span class="sourceLineNo">1601</span>                    neededSize.add(support);<a name="line.1601"></a>
<span class="sourceLineNo">1602</span>                }<a name="line.1602"></a>
<span class="sourceLineNo">1603</span><a name="line.1603"></a>
<span class="sourceLineNo">1604</span>                // Only one supporter -&gt; propagate the new assignment over other hard constraints of the lecture<a name="line.1604"></a>
<span class="sourceLineNo">1605</span>                if (nrSupports == 1) {<a name="line.1605"></a>
<span class="sourceLineNo">1606</span>                    for (Constraint&lt;Lecture, Placement&gt; other: lecture.hardConstraints()) {<a name="line.1606"></a>
<span class="sourceLineNo">1607</span>                        if (other instanceof WeakeningConstraint) continue;<a name="line.1607"></a>
<span class="sourceLineNo">1608</span>                        if (other instanceof GroupConstraint) {<a name="line.1608"></a>
<span class="sourceLineNo">1609</span>                            GroupConstraint gc = (GroupConstraint)other;<a name="line.1609"></a>
<span class="sourceLineNo">1610</span>                            if (depth &gt; 0 &amp;&amp; !ignore.contains(gc))<a name="line.1610"></a>
<span class="sourceLineNo">1611</span>                                gc.forwardCheck(assignment, support, conflicts, ignore, depth - 1);<a name="line.1611"></a>
<span class="sourceLineNo">1612</span>                        } else {<a name="line.1612"></a>
<span class="sourceLineNo">1613</span>                            other.computeConflicts(assignment, support, conflicts);<a name="line.1613"></a>
<span class="sourceLineNo">1614</span>                        }<a name="line.1614"></a>
<span class="sourceLineNo">1615</span>                    }<a name="line.1615"></a>
<span class="sourceLineNo">1616</span>                    for (GlobalConstraint&lt;Lecture, Placement&gt; other: getModel().globalConstraints()) {<a name="line.1616"></a>
<span class="sourceLineNo">1617</span>                        if (other instanceof WeakeningConstraint) continue;<a name="line.1617"></a>
<span class="sourceLineNo">1618</span>                        other.computeConflicts(assignment, support, conflicts);<a name="line.1618"></a>
<span class="sourceLineNo">1619</span>                    }<a name="line.1619"></a>
<span class="sourceLineNo">1620</span><a name="line.1620"></a>
<span class="sourceLineNo">1621</span>                    if (conflicts.contains(support))<a name="line.1621"></a>
<span class="sourceLineNo">1622</span>                        conflicts.add(value);<a name="line.1622"></a>
<span class="sourceLineNo">1623</span>                }<a name="line.1623"></a>
<span class="sourceLineNo">1624</span>            }<a name="line.1624"></a>
<span class="sourceLineNo">1625</span>            <a name="line.1625"></a>
<span class="sourceLineNo">1626</span>            if (canShareRoom() &amp;&amp; neededSize != null) {<a name="line.1626"></a>
<span class="sourceLineNo">1627</span>                if (value.getRoomLocations() != null) {<a name="line.1627"></a>
<span class="sourceLineNo">1628</span>                    for (RoomLocation room: value.getRoomLocations())<a name="line.1628"></a>
<span class="sourceLineNo">1629</span>                        if (room.getRoomConstraint() != null &amp;&amp; !room.getRoomConstraint().checkRoomSize(value, neededSize)) {<a name="line.1629"></a>
<span class="sourceLineNo">1630</span>                            // room is too small to fit all meet with classes<a name="line.1630"></a>
<span class="sourceLineNo">1631</span>                            conflicts.add(value);<a name="line.1631"></a>
<span class="sourceLineNo">1632</span>                        }<a name="line.1632"></a>
<span class="sourceLineNo">1633</span>                } else if (value.getRoomLocation() != null) {<a name="line.1633"></a>
<span class="sourceLineNo">1634</span>                    RoomLocation room = value.getRoomLocation();<a name="line.1634"></a>
<span class="sourceLineNo">1635</span>                    if (room.getRoomConstraint() != null &amp;&amp; !room.getRoomConstraint().checkRoomSize(value, neededSize)) {<a name="line.1635"></a>
<span class="sourceLineNo">1636</span>                        // room is too small to fit all meet with classes<a name="line.1636"></a>
<span class="sourceLineNo">1637</span>                        conflicts.add(value);<a name="line.1637"></a>
<span class="sourceLineNo">1638</span>                    }<a name="line.1638"></a>
<span class="sourceLineNo">1639</span>                }<a name="line.1639"></a>
<span class="sourceLineNo">1640</span>            }<a name="line.1640"></a>
<span class="sourceLineNo">1641</span>        } finally {<a name="line.1641"></a>
<span class="sourceLineNo">1642</span>            ignore.remove(this);<a name="line.1642"></a>
<span class="sourceLineNo">1643</span>        }<a name="line.1643"></a>
<span class="sourceLineNo">1644</span>    }<a name="line.1644"></a>
<span class="sourceLineNo">1645</span><a name="line.1645"></a>
<span class="sourceLineNo">1646</span>    @Override<a name="line.1646"></a>
<span class="sourceLineNo">1647</span>    public boolean inConflict(Assignment&lt;Lecture, Placement&gt; assignment, Placement value) {<a name="line.1647"></a>
<span class="sourceLineNo">1648</span>        if (!isHard())<a name="line.1648"></a>
<span class="sourceLineNo">1649</span>            return false;<a name="line.1649"></a>
<span class="sourceLineNo">1650</span>        for (Lecture v : variables()) {<a name="line.1650"></a>
<span class="sourceLineNo">1651</span>            if (v.equals(value.variable()))<a name="line.1651"></a>
<span class="sourceLineNo">1652</span>                continue; // ignore this variable<a name="line.1652"></a>
<span class="sourceLineNo">1653</span>            Placement p = assignment.getValue(v);<a name="line.1653"></a>
<span class="sourceLineNo">1654</span>            if (p == null)<a name="line.1654"></a>
<span class="sourceLineNo">1655</span>                continue; // there is an unassigned variable -- great, still a chance to get violated<a name="line.1655"></a>
<span class="sourceLineNo">1656</span>            if (!isSatisfiedPair(assignment, p, value))<a name="line.1656"></a>
<span class="sourceLineNo">1657</span>                return true;<a name="line.1657"></a>
<span class="sourceLineNo">1658</span>        }<a name="line.1658"></a>
<span class="sourceLineNo">1659</span>        if (getType().is(Flag.BACK_TO_BACK)) {<a name="line.1659"></a>
<span class="sourceLineNo">1660</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1660"></a>
<span class="sourceLineNo">1661</span>            assignments.put(value.variable(), value);<a name="line.1661"></a>
<span class="sourceLineNo">1662</span>            if (!isSatisfiedSeq(assignment, assignments, null))<a name="line.1662"></a>
<span class="sourceLineNo">1663</span>                return true;<a name="line.1663"></a>
<span class="sourceLineNo">1664</span>        }<a name="line.1664"></a>
<span class="sourceLineNo">1665</span>        if (getType().is(Flag.MAX_HRS_DAY)) {<a name="line.1665"></a>
<span class="sourceLineNo">1666</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1666"></a>
<span class="sourceLineNo">1667</span>            assignments.put(value.variable(), value);<a name="line.1667"></a>
<span class="sourceLineNo">1668</span>            for (int dayCode: Constants.DAY_CODES) {<a name="line.1668"></a>
<span class="sourceLineNo">1669</span>                if (iMaxNHoursADayPrecideComputation) {<a name="line.1669"></a>
<span class="sourceLineNo">1670</span>                    for (IntEnumeration dates = value.getTimeLocation().getDates(iDayOfWeekOffset); dates.hasMoreElements(); ) {<a name="line.1670"></a>
<span class="sourceLineNo">1671</span>                        int date = dates.nextElement();<a name="line.1671"></a>
<span class="sourceLineNo">1672</span>                        if (nrSlotsADay(assignment,date, assignments, null) &gt; getType().getMax())<a name="line.1672"></a>
<span class="sourceLineNo">1673</span>                            return true;<a name="line.1673"></a>
<span class="sourceLineNo">1674</span>                    }<a name="line.1674"></a>
<span class="sourceLineNo">1675</span>                } else if (iMaxNHoursADayConsiderDatePatterns) {<a name="line.1675"></a>
<span class="sourceLineNo">1676</span>                    for (BitSet week: ((TimetableModel)getModel()).getWeeks()) {<a name="line.1676"></a>
<span class="sourceLineNo">1677</span>                        if (!value.getTimeLocation().shareWeeks(week)) continue;<a name="line.1677"></a>
<span class="sourceLineNo">1678</span>                        if (nrSlotsADay(assignment, dayCode, week, assignments, null) &gt; getType().getMax())<a name="line.1678"></a>
<span class="sourceLineNo">1679</span>                            return true;<a name="line.1679"></a>
<span class="sourceLineNo">1680</span>                    }<a name="line.1680"></a>
<span class="sourceLineNo">1681</span>                } else {<a name="line.1681"></a>
<span class="sourceLineNo">1682</span>                    if (nrSlotsADay(assignment, dayCode, null, assignments, null) &gt; getType().getMax()) return true;<a name="line.1682"></a>
<span class="sourceLineNo">1683</span>                }<a name="line.1683"></a>
<span class="sourceLineNo">1684</span>            }<a name="line.1684"></a>
<span class="sourceLineNo">1685</span>        }<a name="line.1685"></a>
<span class="sourceLineNo">1686</span>        <a name="line.1686"></a>
<span class="sourceLineNo">1687</span>        if (!forwardCheck(assignment, value, new HashSet&lt;GroupConstraint&gt;(), iForwardCheckMaxDepth - 1)) return true;<a name="line.1687"></a>
<span class="sourceLineNo">1688</span>        <a name="line.1688"></a>
<span class="sourceLineNo">1689</span>        return false;<a name="line.1689"></a>
<span class="sourceLineNo">1690</span>    }<a name="line.1690"></a>
<span class="sourceLineNo">1691</span>    <a name="line.1691"></a>
<span class="sourceLineNo">1692</span>    public boolean forwardCheck(Assignment&lt;Lecture, Placement&gt; assignment, Placement value, Set&lt;GroupConstraint&gt; ignore, int depth) {<a name="line.1692"></a>
<span class="sourceLineNo">1693</span>        try {<a name="line.1693"></a>
<span class="sourceLineNo">1694</span>            if (depth &lt; 0) return true;<a name="line.1694"></a>
<span class="sourceLineNo">1695</span>            ignore.add(this);<a name="line.1695"></a>
<span class="sourceLineNo">1696</span>            <a name="line.1696"></a>
<span class="sourceLineNo">1697</span>            int neededSize = value.variable().maxRoomUse();<a name="line.1697"></a>
<span class="sourceLineNo">1698</span>            <a name="line.1698"></a>
<span class="sourceLineNo">1699</span>            for (Lecture lecture: variables()) {<a name="line.1699"></a>
<span class="sourceLineNo">1700</span>                if (lecture.equals(value.variable())) continue; // Skip this lecture<a name="line.1700"></a>
<span class="sourceLineNo">1701</span>                Placement current = assignment.getValue(lecture);<a name="line.1701"></a>
<span class="sourceLineNo">1702</span>                if (current != null) { // Has assignment, check whether it is conflicting<a name="line.1702"></a>
<span class="sourceLineNo">1703</span>                    if (isSatisfiedPair(assignment, value, current)) {<a name="line.1703"></a>
<span class="sourceLineNo">1704</span>                        // Increase needed size if the assignment is of the same room and overlapping in time<a name="line.1704"></a>
<span class="sourceLineNo">1705</span>                        if (canShareRoom() &amp;&amp; sameRoomAndOverlaps(value, current)) {<a name="line.1705"></a>
<span class="sourceLineNo">1706</span>                            neededSize += lecture.maxRoomUse();<a name="line.1706"></a>
<span class="sourceLineNo">1707</span>                        }<a name="line.1707"></a>
<span class="sourceLineNo">1708</span>                        continue;<a name="line.1708"></a>
<span class="sourceLineNo">1709</span>                    }<a name="line.1709"></a>
<span class="sourceLineNo">1710</span>                    return false;<a name="line.1710"></a>
<span class="sourceLineNo">1711</span>                }<a name="line.1711"></a>
<span class="sourceLineNo">1712</span>                <a name="line.1712"></a>
<span class="sourceLineNo">1713</span>                // Look for supporting assignments assignment<a name="line.1713"></a>
<span class="sourceLineNo">1714</span>                boolean shareRoomAndOverlaps = canShareRoom();<a name="line.1714"></a>
<span class="sourceLineNo">1715</span>                Placement support = null;<a name="line.1715"></a>
<span class="sourceLineNo">1716</span>                int nrSupports = 0;<a name="line.1716"></a>
<span class="sourceLineNo">1717</span>                if (lecture.nrValues() &gt;= iForwardCheckMaxDomainSize) {<a name="line.1717"></a>
<span class="sourceLineNo">1718</span>                    // ignore variables with large domains<a name="line.1718"></a>
<span class="sourceLineNo">1719</span>                    return true;<a name="line.1719"></a>
<span class="sourceLineNo">1720</span>                }<a name="line.1720"></a>
<span class="sourceLineNo">1721</span>                List&lt;Placement&gt; values = lecture.values(assignment);<a name="line.1721"></a>
<span class="sourceLineNo">1722</span>                if (values.isEmpty()) {<a name="line.1722"></a>
<span class="sourceLineNo">1723</span>                    // ignore variables with empty domain<a name="line.1723"></a>
<span class="sourceLineNo">1724</span>                    return true;<a name="line.1724"></a>
<span class="sourceLineNo">1725</span>                }<a name="line.1725"></a>
<span class="sourceLineNo">1726</span>                for (Placement other: lecture.values(assignment)) {<a name="line.1726"></a>
<span class="sourceLineNo">1727</span>                    if (nrSupports &lt; 2) {<a name="line.1727"></a>
<span class="sourceLineNo">1728</span>                        if (isSatisfiedPair(assignment, value, other)) {<a name="line.1728"></a>
<span class="sourceLineNo">1729</span>                            if (support == null) support = other;<a name="line.1729"></a>
<span class="sourceLineNo">1730</span>                            nrSupports ++;<a name="line.1730"></a>
<span class="sourceLineNo">1731</span>                            if (shareRoomAndOverlaps &amp;&amp; !sameRoomAndOverlaps(value, other))<a name="line.1731"></a>
<span class="sourceLineNo">1732</span>                                shareRoomAndOverlaps = false;<a name="line.1732"></a>
<span class="sourceLineNo">1733</span>                        }<a name="line.1733"></a>
<span class="sourceLineNo">1734</span>                    } else if (shareRoomAndOverlaps &amp;&amp; !sameRoomAndOverlaps(value, other) &amp;&amp; isSatisfiedPair(assignment, value, other)) {<a name="line.1734"></a>
<span class="sourceLineNo">1735</span>                        shareRoomAndOverlaps = false;<a name="line.1735"></a>
<span class="sourceLineNo">1736</span>                    }<a name="line.1736"></a>
<span class="sourceLineNo">1737</span>                    if (nrSupports &gt; 1 &amp;&amp; !shareRoomAndOverlaps)<a name="line.1737"></a>
<span class="sourceLineNo">1738</span>                        break;<a name="line.1738"></a>
<span class="sourceLineNo">1739</span>                }<a name="line.1739"></a>
<span class="sourceLineNo">1740</span><a name="line.1740"></a>
<span class="sourceLineNo">1741</span>                // No supporting assignment -&gt; fail<a name="line.1741"></a>
<span class="sourceLineNo">1742</span>                if (nrSupports == 0) {<a name="line.1742"></a>
<span class="sourceLineNo">1743</span>                    return false; // other class cannot be assigned with this value<a name="line.1743"></a>
<span class="sourceLineNo">1744</span>                }<a name="line.1744"></a>
<span class="sourceLineNo">1745</span>                // Increase needed size if all supporters are of the same room and in overlapping times<a name="line.1745"></a>
<span class="sourceLineNo">1746</span>                if (shareRoomAndOverlaps) {<a name="line.1746"></a>
<span class="sourceLineNo">1747</span>                    neededSize += lecture.maxRoomUse();<a name="line.1747"></a>
<span class="sourceLineNo">1748</span>                }<a name="line.1748"></a>
<span class="sourceLineNo">1749</span><a name="line.1749"></a>
<span class="sourceLineNo">1750</span>                // Only one supporter -&gt; propagate the new assignment over other hard constraints of the lecture<a name="line.1750"></a>
<span class="sourceLineNo">1751</span>                if (nrSupports == 1) {<a name="line.1751"></a>
<span class="sourceLineNo">1752</span>                    for (Constraint&lt;Lecture, Placement&gt; other: lecture.hardConstraints()) {<a name="line.1752"></a>
<span class="sourceLineNo">1753</span>                        if (other instanceof WeakeningConstraint) continue;<a name="line.1753"></a>
<span class="sourceLineNo">1754</span>                        if (other instanceof GroupConstraint) {<a name="line.1754"></a>
<span class="sourceLineNo">1755</span>                            GroupConstraint gc = (GroupConstraint)other;<a name="line.1755"></a>
<span class="sourceLineNo">1756</span>                            if (depth &gt; 0 &amp;&amp; !ignore.contains(gc) &amp;&amp; !gc.forwardCheck(assignment, support, ignore, depth - 1)) return false;<a name="line.1756"></a>
<span class="sourceLineNo">1757</span>                        } else {<a name="line.1757"></a>
<span class="sourceLineNo">1758</span>                            if (other.inConflict(assignment, support)) return false;<a name="line.1758"></a>
<span class="sourceLineNo">1759</span>                        }<a name="line.1759"></a>
<span class="sourceLineNo">1760</span>                    }<a name="line.1760"></a>
<span class="sourceLineNo">1761</span>                    for (GlobalConstraint&lt;Lecture, Placement&gt; other: getModel().globalConstraints()) {<a name="line.1761"></a>
<span class="sourceLineNo">1762</span>                        if (other instanceof WeakeningConstraint) continue;<a name="line.1762"></a>
<span class="sourceLineNo">1763</span>                        if (other.inConflict(assignment, support)) return false;<a name="line.1763"></a>
<span class="sourceLineNo">1764</span>                    }<a name="line.1764"></a>
<span class="sourceLineNo">1765</span>                }<a name="line.1765"></a>
<span class="sourceLineNo">1766</span>            }<a name="line.1766"></a>
<span class="sourceLineNo">1767</span>            <a name="line.1767"></a>
<span class="sourceLineNo">1768</span>            if (canShareRoom() &amp;&amp; neededSize &gt; value.getRoomSize()) {<a name="line.1768"></a>
<span class="sourceLineNo">1769</span>                // room is too small to fit all meet with classes<a name="line.1769"></a>
<span class="sourceLineNo">1770</span>                return false;<a name="line.1770"></a>
<span class="sourceLineNo">1771</span>            }<a name="line.1771"></a>
<span class="sourceLineNo">1772</span>         <a name="line.1772"></a>
<span class="sourceLineNo">1773</span>            return true;<a name="line.1773"></a>
<span class="sourceLineNo">1774</span>        } finally {<a name="line.1774"></a>
<span class="sourceLineNo">1775</span>            ignore.remove(this);<a name="line.1775"></a>
<span class="sourceLineNo">1776</span>        }<a name="line.1776"></a>
<span class="sourceLineNo">1777</span>    }<a name="line.1777"></a>
<span class="sourceLineNo">1778</span><a name="line.1778"></a>
<span class="sourceLineNo">1779</span>    /** Constraint preference (0 if prohibited or required) <a name="line.1779"></a>
<span class="sourceLineNo">1780</span>     * @return constraint preference (if soft)<a name="line.1780"></a>
<span class="sourceLineNo">1781</span>     **/<a name="line.1781"></a>
<span class="sourceLineNo">1782</span>    public int getPreference() {<a name="line.1782"></a>
<span class="sourceLineNo">1783</span>        return iPreference;<a name="line.1783"></a>
<span class="sourceLineNo">1784</span>    }<a name="line.1784"></a>
<span class="sourceLineNo">1785</span><a name="line.1785"></a>
<span class="sourceLineNo">1786</span>    /**<a name="line.1786"></a>
<span class="sourceLineNo">1787</span>     * Current constraint preference (0 if prohibited or required, depends on<a name="line.1787"></a>
<span class="sourceLineNo">1788</span>     * current satisfaction of the constraint)<a name="line.1788"></a>
<span class="sourceLineNo">1789</span>     * @param assignment current assignment<a name="line.1789"></a>
<span class="sourceLineNo">1790</span>     * @return current preference<a name="line.1790"></a>
<span class="sourceLineNo">1791</span>     */<a name="line.1791"></a>
<span class="sourceLineNo">1792</span>    public int getCurrentPreference(Assignment&lt;Lecture, Placement&gt; assignment) {<a name="line.1792"></a>
<span class="sourceLineNo">1793</span>        if (isHard()) return 0; // no preference<a name="line.1793"></a>
<span class="sourceLineNo">1794</span>        if (countAssignedVariables(assignment) &lt; 2) return - Math.abs(iPreference); // not enough variable<a name="line.1794"></a>
<span class="sourceLineNo">1795</span>        if (getType().is(Flag.MAX_HRS_DAY)) { // max hours a day<a name="line.1795"></a>
<span class="sourceLineNo">1796</span>            int over = 0;<a name="line.1796"></a>
<span class="sourceLineNo">1797</span>            for (int dayCode: Constants.DAY_CODES) {<a name="line.1797"></a>
<span class="sourceLineNo">1798</span>                if (iMaxNHoursADayPrecideComputation) {<a name="line.1798"></a>
<span class="sourceLineNo">1799</span>                    Set&lt;Integer&gt; allDates = new HashSet&lt;Integer&gt;();<a name="line.1799"></a>
<span class="sourceLineNo">1800</span>                    for (Lecture v1 : variables()) {<a name="line.1800"></a>
<span class="sourceLineNo">1801</span>                        Placement p1 = assignment.getValue(v1);<a name="line.1801"></a>
<span class="sourceLineNo">1802</span>                        if (p1 == null) continue;<a name="line.1802"></a>
<span class="sourceLineNo">1803</span>                        for (IntEnumeration dates = p1.getTimeLocation().getDates(iDayOfWeekOffset); dates.hasMoreElements(); ) {<a name="line.1803"></a>
<span class="sourceLineNo">1804</span>                            int date = dates.nextElement();<a name="line.1804"></a>
<span class="sourceLineNo">1805</span>                            if (allDates.add(date))<a name="line.1805"></a>
<span class="sourceLineNo">1806</span>                                over += Math.max(0, nrSlotsADay(assignment, date, null, null) - getType().getMax());<a name="line.1806"></a>
<span class="sourceLineNo">1807</span>                        }<a name="line.1807"></a>
<span class="sourceLineNo">1808</span>                    }<a name="line.1808"></a>
<span class="sourceLineNo">1809</span>                } else if (iMaxNHoursADayConsiderDatePatterns) {<a name="line.1809"></a>
<span class="sourceLineNo">1810</span>                    for (BitSet week: ((TimetableModel)getModel()).getWeeks())<a name="line.1810"></a>
<span class="sourceLineNo">1811</span>                        over += Math.max(0, nrSlotsADay(assignment, dayCode, week, null, null) - getType().getMax());<a name="line.1811"></a>
<span class="sourceLineNo">1812</span>                } else {<a name="line.1812"></a>
<span class="sourceLineNo">1813</span>                    over += Math.max(0, nrSlotsADay(assignment, dayCode, null, null, null) - getType().getMax());<a name="line.1813"></a>
<span class="sourceLineNo">1814</span>                }<a name="line.1814"></a>
<span class="sourceLineNo">1815</span>            }<a name="line.1815"></a>
<span class="sourceLineNo">1816</span>            return (over &gt; 0 ? Math.abs(iPreference) * over / 12 : - Math.abs(iPreference));<a name="line.1816"></a>
<span class="sourceLineNo">1817</span>        }<a name="line.1817"></a>
<span class="sourceLineNo">1818</span>        int nrViolatedPairs = 0;<a name="line.1818"></a>
<span class="sourceLineNo">1819</span>        for (Lecture v1 : variables()) {<a name="line.1819"></a>
<span class="sourceLineNo">1820</span>            Placement p1 = assignment.getValue(v1);<a name="line.1820"></a>
<span class="sourceLineNo">1821</span>            if (p1 == null) continue;<a name="line.1821"></a>
<span class="sourceLineNo">1822</span>            for (Lecture v2 : variables()) {<a name="line.1822"></a>
<span class="sourceLineNo">1823</span>                Placement p2 = assignment.getValue(v2);<a name="line.1823"></a>
<span class="sourceLineNo">1824</span>                if (p2 == null || v1.getId() &gt;= v2.getId()) continue;<a name="line.1824"></a>
<span class="sourceLineNo">1825</span>                if (!isSatisfiedPair(assignment, p1, p2)) nrViolatedPairs++;<a name="line.1825"></a>
<span class="sourceLineNo">1826</span>            }<a name="line.1826"></a>
<span class="sourceLineNo">1827</span>        }<a name="line.1827"></a>
<span class="sourceLineNo">1828</span>        if (getType().is(Flag.BACK_TO_BACK)) {<a name="line.1828"></a>
<span class="sourceLineNo">1829</span>            Set&lt;Placement&gt; conflicts = new HashSet&lt;Placement&gt;();<a name="line.1829"></a>
<span class="sourceLineNo">1830</span>            if (isSatisfiedSeq(assignment, new HashMap&lt;Lecture, Placement&gt;(), conflicts))<a name="line.1830"></a>
<span class="sourceLineNo">1831</span>                nrViolatedPairs += conflicts.size();<a name="line.1831"></a>
<span class="sourceLineNo">1832</span>            else<a name="line.1832"></a>
<span class="sourceLineNo">1833</span>                nrViolatedPairs = variables().size();<a name="line.1833"></a>
<span class="sourceLineNo">1834</span>        }<a name="line.1834"></a>
<span class="sourceLineNo">1835</span>        return (nrViolatedPairs &gt; 0 ? Math.abs(iPreference) * nrViolatedPairs : - Math.abs(iPreference));<a name="line.1835"></a>
<span class="sourceLineNo">1836</span>    }<a name="line.1836"></a>
<span class="sourceLineNo">1837</span><a name="line.1837"></a>
<span class="sourceLineNo">1838</span>    /** Current constraint preference change (if given placement is assigned) <a name="line.1838"></a>
<span class="sourceLineNo">1839</span>     * @param assignment current assignment<a name="line.1839"></a>
<span class="sourceLineNo">1840</span>     * @param placement placement that is being considered<a name="line.1840"></a>
<span class="sourceLineNo">1841</span>     * @return change in the current preference, if assigned <a name="line.1841"></a>
<span class="sourceLineNo">1842</span>     **/<a name="line.1842"></a>
<span class="sourceLineNo">1843</span>    public int getCurrentPreference(Assignment&lt;Lecture, Placement&gt; assignment, Placement placement) {<a name="line.1843"></a>
<span class="sourceLineNo">1844</span>        if (isHard()) return 0; // no preference<a name="line.1844"></a>
<span class="sourceLineNo">1845</span>        if (countAssignedVariables(assignment) + (assignment.getValue(placement.variable()) == null ? 1 : 0) &lt; 2) return 0; // not enough variable<a name="line.1845"></a>
<span class="sourceLineNo">1846</span>        if (getType().is(Flag.MAX_HRS_DAY)) {<a name="line.1846"></a>
<span class="sourceLineNo">1847</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1847"></a>
<span class="sourceLineNo">1848</span>            assignments.put(placement.variable(), placement);<a name="line.1848"></a>
<span class="sourceLineNo">1849</span>            HashMap&lt;Lecture, Placement&gt; unassignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1849"></a>
<span class="sourceLineNo">1850</span>            unassignments.put(placement.variable(), null);<a name="line.1850"></a>
<span class="sourceLineNo">1851</span>            int after = 0;<a name="line.1851"></a>
<span class="sourceLineNo">1852</span>            int before = 0;<a name="line.1852"></a>
<span class="sourceLineNo">1853</span>            for (int dayCode: Constants.DAY_CODES) {<a name="line.1853"></a>
<span class="sourceLineNo">1854</span>                if (iMaxNHoursADayPrecideComputation) {<a name="line.1854"></a>
<span class="sourceLineNo">1855</span>                    for (IntEnumeration dates = placement.getTimeLocation().getDates(iDayOfWeekOffset); dates.hasMoreElements(); ) {<a name="line.1855"></a>
<span class="sourceLineNo">1856</span>                        int date = dates.nextElement();<a name="line.1856"></a>
<span class="sourceLineNo">1857</span>                        after += Math.max(0, nrSlotsADay(assignment, date, assignments, null) - getType().getMax());<a name="line.1857"></a>
<span class="sourceLineNo">1858</span>                        before += Math.max(0, nrSlotsADay(assignment, date, unassignments, null) - getType().getMax());<a name="line.1858"></a>
<span class="sourceLineNo">1859</span>                    }<a name="line.1859"></a>
<span class="sourceLineNo">1860</span>                } else if (iMaxNHoursADayConsiderDatePatterns) {<a name="line.1860"></a>
<span class="sourceLineNo">1861</span>                    for (BitSet week: ((TimetableModel)getModel()).getWeeks()) {<a name="line.1861"></a>
<span class="sourceLineNo">1862</span>                        after += Math.max(0, nrSlotsADay(assignment, dayCode, week, assignments, null) - getType().getMax());<a name="line.1862"></a>
<span class="sourceLineNo">1863</span>                        before += Math.max(0, nrSlotsADay(assignment, dayCode, week, unassignments, null) - getType().getMax());<a name="line.1863"></a>
<span class="sourceLineNo">1864</span>                    }<a name="line.1864"></a>
<span class="sourceLineNo">1865</span>                } else {<a name="line.1865"></a>
<span class="sourceLineNo">1866</span>                    after += Math.max(0, nrSlotsADay(assignment, dayCode, null, assignments, null) - getType().getMax());<a name="line.1866"></a>
<span class="sourceLineNo">1867</span>                    before += Math.max(0, nrSlotsADay(assignment, dayCode, null, unassignments, null) - getType().getMax());<a name="line.1867"></a>
<span class="sourceLineNo">1868</span>                }<a name="line.1868"></a>
<span class="sourceLineNo">1869</span>            }<a name="line.1869"></a>
<span class="sourceLineNo">1870</span>            return (after &gt; 0 ? Math.abs(iPreference) * after / 12 : - Math.abs(iPreference)) - (before &gt; 0 ? Math.abs(iPreference) * before / 12 : - Math.abs(iPreference));<a name="line.1870"></a>
<span class="sourceLineNo">1871</span>        }<a name="line.1871"></a>
<span class="sourceLineNo">1872</span>        <a name="line.1872"></a>
<span class="sourceLineNo">1873</span>        int nrViolatedPairsAfter = 0;<a name="line.1873"></a>
<span class="sourceLineNo">1874</span>        int nrViolatedPairsBefore = 0;<a name="line.1874"></a>
<span class="sourceLineNo">1875</span>        for (Lecture v1 : variables()) {<a name="line.1875"></a>
<span class="sourceLineNo">1876</span>            for (Lecture v2 : variables()) {<a name="line.1876"></a>
<span class="sourceLineNo">1877</span>                if (v1.getId() &gt;= v2.getId()) continue;<a name="line.1877"></a>
<span class="sourceLineNo">1878</span>                Placement p1 = (v1.equals(placement.variable()) ? null : assignment.getValue(v1));<a name="line.1878"></a>
<span class="sourceLineNo">1879</span>                Placement p2 = (v2.equals(placement.variable()) ? null : assignment.getValue(v2));<a name="line.1879"></a>
<span class="sourceLineNo">1880</span>                if (p1 != null &amp;&amp; p2 != null &amp;&amp; !isSatisfiedPair(assignment, p1, p2))<a name="line.1880"></a>
<span class="sourceLineNo">1881</span>                    nrViolatedPairsBefore ++;<a name="line.1881"></a>
<span class="sourceLineNo">1882</span>                if (v1.equals(placement.variable())) p1 = placement;<a name="line.1882"></a>
<span class="sourceLineNo">1883</span>                if (v2.equals(placement.variable())) p2 = placement;<a name="line.1883"></a>
<span class="sourceLineNo">1884</span>                if (p1 != null &amp;&amp; p2 != null &amp;&amp; !isSatisfiedPair(assignment, p1, p2))<a name="line.1884"></a>
<span class="sourceLineNo">1885</span>                    nrViolatedPairsAfter ++;<a name="line.1885"></a>
<span class="sourceLineNo">1886</span>            }<a name="line.1886"></a>
<span class="sourceLineNo">1887</span>        }<a name="line.1887"></a>
<span class="sourceLineNo">1888</span>        <a name="line.1888"></a>
<span class="sourceLineNo">1889</span>        if (getType().is(Flag.BACK_TO_BACK)) {<a name="line.1889"></a>
<span class="sourceLineNo">1890</span>            HashMap&lt;Lecture, Placement&gt; assignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1890"></a>
<span class="sourceLineNo">1891</span>            assignments.put(placement.variable(), placement);<a name="line.1891"></a>
<span class="sourceLineNo">1892</span>            Set&lt;Placement&gt; conflicts = new HashSet&lt;Placement&gt;();<a name="line.1892"></a>
<span class="sourceLineNo">1893</span>            if (isSatisfiedSeq(assignment, assignments, conflicts))<a name="line.1893"></a>
<span class="sourceLineNo">1894</span>                nrViolatedPairsAfter += conflicts.size();<a name="line.1894"></a>
<span class="sourceLineNo">1895</span>            else<a name="line.1895"></a>
<span class="sourceLineNo">1896</span>                nrViolatedPairsAfter = variables().size();<a name="line.1896"></a>
<span class="sourceLineNo">1897</span>            <a name="line.1897"></a>
<span class="sourceLineNo">1898</span>            HashMap&lt;Lecture, Placement&gt; unassignments = new HashMap&lt;Lecture, Placement&gt;();<a name="line.1898"></a>
<span class="sourceLineNo">1899</span>            unassignments.put(placement.variable(), null);<a name="line.1899"></a>
<span class="sourceLineNo">1900</span>            Set&lt;Placement&gt; previous = new HashSet&lt;Placement&gt;();<a name="line.1900"></a>
<span class="sourceLineNo">1901</span>            if (isSatisfiedSeq(assignment, unassignments, previous))<a name="line.1901"></a>
<span class="sourceLineNo">1902</span>                nrViolatedPairsBefore += previous.size();<a name="line.1902"></a>
<span class="sourceLineNo">1903</span>            else<a name="line.1903"></a>
<span class="sourceLineNo">1904</span>                nrViolatedPairsBefore = variables().size();<a name="line.1904"></a>
<span class="sourceLineNo">1905</span>        }<a name="line.1905"></a>
<span class="sourceLineNo">1906</span>        <a name="line.1906"></a>
<span class="sourceLineNo">1907</span>        return (nrViolatedPairsAfter &gt; 0 ? Math.abs(iPreference) * nrViolatedPairsAfter : - Math.abs(iPreference)) -<a name="line.1907"></a>
<span class="sourceLineNo">1908</span>                (nrViolatedPairsBefore &gt; 0 ? Math.abs(iPreference) * nrViolatedPairsBefore : - Math.abs(iPreference));<a name="line.1908"></a>
<span class="sourceLineNo">1909</span>    }<a name="line.1909"></a>
<span class="sourceLineNo">1910</span><a name="line.1910"></a>
<span class="sourceLineNo">1911</span>    @Override<a name="line.1911"></a>
<span class="sourceLineNo">1912</span>    public String toString() {<a name="line.1912"></a>
<span class="sourceLineNo">1913</span>        StringBuffer sb = new StringBuffer();<a name="line.1913"></a>
<span class="sourceLineNo">1914</span>        sb.append(getName());<a name="line.1914"></a>
<span class="sourceLineNo">1915</span>        sb.append(" between ");<a name="line.1915"></a>
<span class="sourceLineNo">1916</span>        for (Iterator&lt;Lecture&gt; e = variables().iterator(); e.hasNext();) {<a name="line.1916"></a>
<span class="sourceLineNo">1917</span>            Lecture v = e.next();<a name="line.1917"></a>
<span class="sourceLineNo">1918</span>            sb.append(v.getName());<a name="line.1918"></a>
<span class="sourceLineNo">1919</span>            if (e.hasNext())<a name="line.1919"></a>
<span class="sourceLineNo">1920</span>                sb.append(", ");<a name="line.1920"></a>
<span class="sourceLineNo">1921</span>        }<a name="line.1921"></a>
<span class="sourceLineNo">1922</span>        return sb.toString();<a name="line.1922"></a>
<span class="sourceLineNo">1923</span>    }<a name="line.1923"></a>
<span class="sourceLineNo">1924</span><a name="line.1924"></a>
<span class="sourceLineNo">1925</span>    @Override<a name="line.1925"></a>
<span class="sourceLineNo">1926</span>    public boolean isHard() {<a name="line.1926"></a>
<span class="sourceLineNo">1927</span>        return iIsRequired || iIsProhibited;<a name="line.1927"></a>
<span class="sourceLineNo">1928</span>    }<a name="line.1928"></a>
<span class="sourceLineNo">1929</span><a name="line.1929"></a>
<span class="sourceLineNo">1930</span>    @Override<a name="line.1930"></a>
<span class="sourceLineNo">1931</span>    public String getName() {<a name="line.1931"></a>
<span class="sourceLineNo">1932</span>        return getType().getName();<a name="line.1932"></a>
<span class="sourceLineNo">1933</span>    }<a name="line.1933"></a>
<span class="sourceLineNo">1934</span><a name="line.1934"></a>
<span class="sourceLineNo">1935</span><a name="line.1935"></a>
<span class="sourceLineNo">1936</span>    private boolean isPrecedence(Placement p1, Placement p2, boolean firstGoesFirst, boolean considerDatePatterns) {<a name="line.1936"></a>
<span class="sourceLineNo">1937</span>        int ord1 = variables().indexOf(p1.variable());<a name="line.1937"></a>
<span class="sourceLineNo">1938</span>        int ord2 = variables().indexOf(p2.variable());<a name="line.1938"></a>
<span class="sourceLineNo">1939</span>        TimeLocation t1 = null, t2 = null;<a name="line.1939"></a>
<span class="sourceLineNo">1940</span>        if (ord1 &lt; ord2) {<a name="line.1940"></a>
<span class="sourceLineNo">1941</span>            if (firstGoesFirst) {<a name="line.1941"></a>
<span class="sourceLineNo">1942</span>                t1 = p1.getTimeLocation();<a name="line.1942"></a>
<span class="sourceLineNo">1943</span>                t2 = p2.getTimeLocation();<a name="line.1943"></a>
<span class="sourceLineNo">1944</span>            } else {<a name="line.1944"></a>
<span class="sourceLineNo">1945</span>                t2 = p1.getTimeLocation();<a name="line.1945"></a>
<span class="sourceLineNo">1946</span>                t1 = p2.getTimeLocation();<a name="line.1946"></a>
<span class="sourceLineNo">1947</span>            }<a name="line.1947"></a>
<span class="sourceLineNo">1948</span>        } else {<a name="line.1948"></a>
<span class="sourceLineNo">1949</span>            if (!firstGoesFirst) {<a name="line.1949"></a>
<span class="sourceLineNo">1950</span>                t1 = p1.getTimeLocation();<a name="line.1950"></a>
<span class="sourceLineNo">1951</span>                t2 = p2.getTimeLocation();<a name="line.1951"></a>
<span class="sourceLineNo">1952</span>            } else {<a name="line.1952"></a>
<span class="sourceLineNo">1953</span>                t2 = p1.getTimeLocation();<a name="line.1953"></a>
<span class="sourceLineNo">1954</span>                t1 = p2.getTimeLocation();<a name="line.1954"></a>
<span class="sourceLineNo">1955</span>            }<a name="line.1955"></a>
<span class="sourceLineNo">1956</span>        }<a name="line.1956"></a>
<span class="sourceLineNo">1957</span>        if (considerDatePatterns &amp;&amp; iPrecedenceConsiderDatePatterns) {<a name="line.1957"></a>
<span class="sourceLineNo">1958</span>            if (iPrecedenceSkipSameDatePatternCheck) {<a name="line.1958"></a>
<span class="sourceLineNo">1959</span>                int m1 = t1.getFirstMeeting(iDayOfWeekOffset), m2 = t2.getFirstMeeting(iDayOfWeekOffset);<a name="line.1959"></a>
<span class="sourceLineNo">1960</span>                if (m1 != m2) return m1 &lt; m2;<a name="line.1960"></a>
<span class="sourceLineNo">1961</span>            } else {<a name="line.1961"></a>
<span class="sourceLineNo">1962</span>                boolean sameDatePattern = (t1.getDatePatternId() != null ? t1.getDatePatternId().equals(t2.getDatePatternId()) : t1.getWeekCode().equals(t2.getWeekCode()));<a name="line.1962"></a>
<span class="sourceLineNo">1963</span>                if (!sameDatePattern) {<a name="line.1963"></a>
<span class="sourceLineNo">1964</span>                    int m1 = t1.getFirstMeeting(iDayOfWeekOffset), m2 = t2.getFirstMeeting(iDayOfWeekOffset);<a name="line.1964"></a>
<span class="sourceLineNo">1965</span>                    if (m1 != m2) return m1 &lt; m2;<a name="line.1965"></a>
<span class="sourceLineNo">1966</span>                }<a name="line.1966"></a>
<span class="sourceLineNo">1967</span>            }<a name="line.1967"></a>
<span class="sourceLineNo">1968</span>        }<a name="line.1968"></a>
<span class="sourceLineNo">1969</span>        if (iFirstWorkDay != 0) {<a name="line.1969"></a>
<span class="sourceLineNo">1970</span>            for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.1970"></a>
<span class="sourceLineNo">1971</span>                int idx = (i + iFirstWorkDay) % 7;<a name="line.1971"></a>
<span class="sourceLineNo">1972</span>                boolean a = (t1.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0;<a name="line.1972"></a>
<span class="sourceLineNo">1973</span>                boolean b = (t2.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0;<a name="line.1973"></a>
<span class="sourceLineNo">1974</span>                if (b &amp;&amp; !a) return false; // second start first<a name="line.1974"></a>
<span class="sourceLineNo">1975</span>                if (a &amp;&amp; !b) return true;  // first start first<a name="line.1975"></a>
<span class="sourceLineNo">1976</span>                if (a &amp;&amp; b) return t1.getStartSlot() + t1.getLength() &lt;= t2.getStartSlot(); // same day: check times<a name="line.1976"></a>
<span class="sourceLineNo">1977</span>            }<a name="line.1977"></a>
<span class="sourceLineNo">1978</span>        }<a name="line.1978"></a>
<span class="sourceLineNo">1979</span>        return t1.getStartSlots().nextElement() + t1.getLength() &lt;= t2.getStartSlots().nextElement();<a name="line.1979"></a>
<span class="sourceLineNo">1980</span>    }<a name="line.1980"></a>
<span class="sourceLineNo">1981</span><a name="line.1981"></a>
<span class="sourceLineNo">1982</span>    private boolean isBackToBackDays(TimeLocation t1, TimeLocation t2) {<a name="line.1982"></a>
<span class="sourceLineNo">1983</span>        int f1 = -1, f2 = -1, e1 = -1, e2 = -1;<a name="line.1983"></a>
<span class="sourceLineNo">1984</span>        for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.1984"></a>
<span class="sourceLineNo">1985</span>            int idx = (i + iFirstWorkDay) % 7;<a name="line.1985"></a>
<span class="sourceLineNo">1986</span>            if ((t1.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.1986"></a>
<span class="sourceLineNo">1987</span>                if (f1 &lt; 0)<a name="line.1987"></a>
<span class="sourceLineNo">1988</span>                    f1 = i;<a name="line.1988"></a>
<span class="sourceLineNo">1989</span>                e1 = i;<a name="line.1989"></a>
<span class="sourceLineNo">1990</span>            }<a name="line.1990"></a>
<span class="sourceLineNo">1991</span>            if ((t2.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.1991"></a>
<span class="sourceLineNo">1992</span>                if (f2 &lt; 0)<a name="line.1992"></a>
<span class="sourceLineNo">1993</span>                    f2 = i;<a name="line.1993"></a>
<span class="sourceLineNo">1994</span>                e2 = i;<a name="line.1994"></a>
<span class="sourceLineNo">1995</span>            }<a name="line.1995"></a>
<span class="sourceLineNo">1996</span>        }<a name="line.1996"></a>
<span class="sourceLineNo">1997</span>        return (e1 + 1 == f2) || (e2 + 1 == f1);<a name="line.1997"></a>
<span class="sourceLineNo">1998</span>    }<a name="line.1998"></a>
<span class="sourceLineNo">1999</span>    <a name="line.1999"></a>
<span class="sourceLineNo">2000</span>    private boolean isNrDaysBetweenGreaterThanOne(TimeLocation t1, TimeLocation t2) {<a name="line.2000"></a>
<span class="sourceLineNo">2001</span>        int f1 = -1, f2 = -1, e1 = -1, e2 = -1;<a name="line.2001"></a>
<span class="sourceLineNo">2002</span>        for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.2002"></a>
<span class="sourceLineNo">2003</span>            int idx = (i + iFirstWorkDay) % 7;<a name="line.2003"></a>
<span class="sourceLineNo">2004</span>            if ((t1.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2004"></a>
<span class="sourceLineNo">2005</span>                if (f1 &lt; 0)<a name="line.2005"></a>
<span class="sourceLineNo">2006</span>                    f1 = i;<a name="line.2006"></a>
<span class="sourceLineNo">2007</span>                e1 = i;<a name="line.2007"></a>
<span class="sourceLineNo">2008</span>            }<a name="line.2008"></a>
<span class="sourceLineNo">2009</span>            if ((t2.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2009"></a>
<span class="sourceLineNo">2010</span>                if (f2 &lt; 0)<a name="line.2010"></a>
<span class="sourceLineNo">2011</span>                    f2 = i;<a name="line.2011"></a>
<span class="sourceLineNo">2012</span>                e2 = i;<a name="line.2012"></a>
<span class="sourceLineNo">2013</span>            }<a name="line.2013"></a>
<span class="sourceLineNo">2014</span>        }<a name="line.2014"></a>
<span class="sourceLineNo">2015</span>        return (e1 - f2 &gt; 2) || (e2 - f1 &gt; 2);<a name="line.2015"></a>
<span class="sourceLineNo">2016</span>    }<a name="line.2016"></a>
<span class="sourceLineNo">2017</span><a name="line.2017"></a>
<span class="sourceLineNo">2018</span>    private boolean isFollowingDay(Placement p1, Placement p2, boolean firstGoesFirst) {<a name="line.2018"></a>
<span class="sourceLineNo">2019</span>        int ord1 = variables().indexOf(p1.variable());<a name="line.2019"></a>
<span class="sourceLineNo">2020</span>        int ord2 = variables().indexOf(p2.variable());<a name="line.2020"></a>
<span class="sourceLineNo">2021</span>        TimeLocation t1 = null, t2 = null;<a name="line.2021"></a>
<span class="sourceLineNo">2022</span>        if (ord1 &lt; ord2) {<a name="line.2022"></a>
<span class="sourceLineNo">2023</span>            if (firstGoesFirst) {<a name="line.2023"></a>
<span class="sourceLineNo">2024</span>                t1 = p1.getTimeLocation();<a name="line.2024"></a>
<span class="sourceLineNo">2025</span>                t2 = p2.getTimeLocation();<a name="line.2025"></a>
<span class="sourceLineNo">2026</span>            } else {<a name="line.2026"></a>
<span class="sourceLineNo">2027</span>                t2 = p1.getTimeLocation();<a name="line.2027"></a>
<span class="sourceLineNo">2028</span>                t1 = p2.getTimeLocation();<a name="line.2028"></a>
<span class="sourceLineNo">2029</span>            }<a name="line.2029"></a>
<span class="sourceLineNo">2030</span>        } else {<a name="line.2030"></a>
<span class="sourceLineNo">2031</span>            if (!firstGoesFirst) {<a name="line.2031"></a>
<span class="sourceLineNo">2032</span>                t1 = p1.getTimeLocation();<a name="line.2032"></a>
<span class="sourceLineNo">2033</span>                t2 = p2.getTimeLocation();<a name="line.2033"></a>
<span class="sourceLineNo">2034</span>            } else {<a name="line.2034"></a>
<span class="sourceLineNo">2035</span>                t2 = p1.getTimeLocation();<a name="line.2035"></a>
<span class="sourceLineNo">2036</span>                t1 = p2.getTimeLocation();<a name="line.2036"></a>
<span class="sourceLineNo">2037</span>            }<a name="line.2037"></a>
<span class="sourceLineNo">2038</span>        }<a name="line.2038"></a>
<span class="sourceLineNo">2039</span>        int f1 = -1, f2 = -1, e1 = -1;<a name="line.2039"></a>
<span class="sourceLineNo">2040</span>        for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.2040"></a>
<span class="sourceLineNo">2041</span>            int idx = (i + iFirstWorkDay) % 7;<a name="line.2041"></a>
<span class="sourceLineNo">2042</span>            if ((t1.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2042"></a>
<span class="sourceLineNo">2043</span>                if (f1 &lt; 0)<a name="line.2043"></a>
<span class="sourceLineNo">2044</span>                    f1 = i;<a name="line.2044"></a>
<span class="sourceLineNo">2045</span>                e1 = i;<a name="line.2045"></a>
<span class="sourceLineNo">2046</span>            }<a name="line.2046"></a>
<span class="sourceLineNo">2047</span>            if ((t2.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2047"></a>
<span class="sourceLineNo">2048</span>                if (f2 &lt; 0)<a name="line.2048"></a>
<span class="sourceLineNo">2049</span>                    f2 = i;<a name="line.2049"></a>
<span class="sourceLineNo">2050</span>            }<a name="line.2050"></a>
<span class="sourceLineNo">2051</span>        }<a name="line.2051"></a>
<span class="sourceLineNo">2052</span>        return ((e1 + 1) % iNrWorkDays == f2);<a name="line.2052"></a>
<span class="sourceLineNo">2053</span>    }<a name="line.2053"></a>
<span class="sourceLineNo">2054</span>    <a name="line.2054"></a>
<span class="sourceLineNo">2055</span>    private boolean isNextDay(TimeLocation t1, TimeLocation t2) {<a name="line.2055"></a>
<span class="sourceLineNo">2056</span>        if (iPrecedenceConsiderDatePatterns) {<a name="line.2056"></a>
<span class="sourceLineNo">2057</span>            for (Enumeration&lt;Integer&gt; e = t1.getDates(iDayOfWeekOffset); e.hasMoreElements(); ) {<a name="line.2057"></a>
<span class="sourceLineNo">2058</span>                Integer date = e.nextElement();<a name="line.2058"></a>
<span class="sourceLineNo">2059</span>                if (t2.hasDate(date + 1, iDayOfWeekOffset)) return true;<a name="line.2059"></a>
<span class="sourceLineNo">2060</span>            }<a name="line.2060"></a>
<span class="sourceLineNo">2061</span>            return false;<a name="line.2061"></a>
<span class="sourceLineNo">2062</span>        }<a name="line.2062"></a>
<span class="sourceLineNo">2063</span>        for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.2063"></a>
<span class="sourceLineNo">2064</span>            int i1 = (i + iFirstWorkDay) % 7;<a name="line.2064"></a>
<span class="sourceLineNo">2065</span>            int i2 = (1 + i1) % 7;<a name="line.2065"></a>
<span class="sourceLineNo">2066</span>            boolean a = (t1.getDayCode() &amp; Constants.DAY_CODES[i1]) != 0;<a name="line.2066"></a>
<span class="sourceLineNo">2067</span>            boolean b = (t2.getDayCode() &amp; Constants.DAY_CODES[i2]) != 0;<a name="line.2067"></a>
<span class="sourceLineNo">2068</span>            if (a &amp;&amp; b) return true;<a name="line.2068"></a>
<span class="sourceLineNo">2069</span>        }<a name="line.2069"></a>
<span class="sourceLineNo">2070</span>        return false;<a name="line.2070"></a>
<span class="sourceLineNo">2071</span>    }<a name="line.2071"></a>
<span class="sourceLineNo">2072</span><a name="line.2072"></a>
<span class="sourceLineNo">2073</span>    private boolean isEveryOtherDay(Placement p1, Placement p2, boolean firstGoesFirst) {<a name="line.2073"></a>
<span class="sourceLineNo">2074</span>        int ord1 = variables().indexOf(p1.variable());<a name="line.2074"></a>
<span class="sourceLineNo">2075</span>        int ord2 = variables().indexOf(p2.variable());<a name="line.2075"></a>
<span class="sourceLineNo">2076</span>        TimeLocation t1 = null, t2 = null;<a name="line.2076"></a>
<span class="sourceLineNo">2077</span>        if (ord1 &lt; ord2) {<a name="line.2077"></a>
<span class="sourceLineNo">2078</span>            if (firstGoesFirst) {<a name="line.2078"></a>
<span class="sourceLineNo">2079</span>                t1 = p1.getTimeLocation();<a name="line.2079"></a>
<span class="sourceLineNo">2080</span>                t2 = p2.getTimeLocation();<a name="line.2080"></a>
<span class="sourceLineNo">2081</span>            } else {<a name="line.2081"></a>
<span class="sourceLineNo">2082</span>                t2 = p1.getTimeLocation();<a name="line.2082"></a>
<span class="sourceLineNo">2083</span>                t1 = p2.getTimeLocation();<a name="line.2083"></a>
<span class="sourceLineNo">2084</span>            }<a name="line.2084"></a>
<span class="sourceLineNo">2085</span>        } else {<a name="line.2085"></a>
<span class="sourceLineNo">2086</span>            if (!firstGoesFirst) {<a name="line.2086"></a>
<span class="sourceLineNo">2087</span>                t1 = p1.getTimeLocation();<a name="line.2087"></a>
<span class="sourceLineNo">2088</span>                t2 = p2.getTimeLocation();<a name="line.2088"></a>
<span class="sourceLineNo">2089</span>            } else {<a name="line.2089"></a>
<span class="sourceLineNo">2090</span>                t2 = p1.getTimeLocation();<a name="line.2090"></a>
<span class="sourceLineNo">2091</span>                t1 = p2.getTimeLocation();<a name="line.2091"></a>
<span class="sourceLineNo">2092</span>            }<a name="line.2092"></a>
<span class="sourceLineNo">2093</span>        }<a name="line.2093"></a>
<span class="sourceLineNo">2094</span>        int f1 = -1, f2 = -1, e1 = -1;<a name="line.2094"></a>
<span class="sourceLineNo">2095</span>        for (int i = 0; i &lt; Constants.DAY_CODES.length; i++) {<a name="line.2095"></a>
<span class="sourceLineNo">2096</span>            int idx = (i + iFirstWorkDay) % 7;<a name="line.2096"></a>
<span class="sourceLineNo">2097</span>            if ((t1.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2097"></a>
<span class="sourceLineNo">2098</span>                if (f1 &lt; 0)<a name="line.2098"></a>
<span class="sourceLineNo">2099</span>                    f1 = i;<a name="line.2099"></a>
<span class="sourceLineNo">2100</span>                e1 = i;<a name="line.2100"></a>
<span class="sourceLineNo">2101</span>            }<a name="line.2101"></a>
<span class="sourceLineNo">2102</span>            if ((t2.getDayCode() &amp; Constants.DAY_CODES[idx]) != 0) {<a name="line.2102"></a>
<span class="sourceLineNo">2103</span>                if (f2 &lt; 0)<a name="line.2103"></a>
<span class="sourceLineNo">2104</span>                    f2 = i;<a name="line.2104"></a>
<span class="sourceLineNo">2105</span>            }<a name="line.2105"></a>
<span class="sourceLineNo">2106</span>        }<a name="line.2106"></a>
<span class="sourceLineNo">2107</span>        return ((e1 + 2) % iNrWorkDays == f2);<a name="line.2107"></a>
<span class="sourceLineNo">2108</span>    }<a name="line.2108"></a>
<span class="sourceLineNo">2109</span><a name="line.2109"></a>
<span class="sourceLineNo">2110</span>    private static boolean sameDays(int[] days1, int[] days2) {<a name="line.2110"></a>
<span class="sourceLineNo">2111</span>        if (days2.length &lt; days1.length)<a name="line.2111"></a>
<span class="sourceLineNo">2112</span>            return sameDays(days2, days1);<a name="line.2112"></a>
<span class="sourceLineNo">2113</span>        int i2 = 0;<a name="line.2113"></a>
<span class="sourceLineNo">2114</span>        for (int i1 = 0; i1 &lt; days1.length; i1++) {<a name="line.2114"></a>
<span class="sourceLineNo">2115</span>            int d1 = days1[i1];<a name="line.2115"></a>
<span class="sourceLineNo">2116</span>            while (true) {<a name="line.2116"></a>
<span class="sourceLineNo">2117</span>                if (i2 == days2.length)<a name="line.2117"></a>
<span class="sourceLineNo">2118</span>                    return false;<a name="line.2118"></a>
<span class="sourceLineNo">2119</span>                int d2 = days2[i2];<a name="line.2119"></a>
<span class="sourceLineNo">2120</span>                if (d1 == d2)<a name="line.2120"></a>
<span class="sourceLineNo">2121</span>                    break;<a name="line.2121"></a>
<span class="sourceLineNo">2122</span>                i2++;<a name="line.2122"></a>
<span class="sourceLineNo">2123</span>                if (i2 == days2.length)<a name="line.2123"></a>
<span class="sourceLineNo">2124</span>                    return false;<a name="line.2124"></a>
<span class="sourceLineNo">2125</span>            }<a name="line.2125"></a>
<span class="sourceLineNo">2126</span>            i2++;<a name="line.2126"></a>
<span class="sourceLineNo">2127</span>        }<a name="line.2127"></a>
<span class="sourceLineNo">2128</span>        return true;<a name="line.2128"></a>
<span class="sourceLineNo">2129</span>    }<a name="line.2129"></a>
<span class="sourceLineNo">2130</span>    <a name="line.2130"></a>
<span class="sourceLineNo">2131</span>    private static boolean sameRoomAndOverlaps(Placement p1, Placement p2) {<a name="line.2131"></a>
<span class="sourceLineNo">2132</span>        return p1.shareRooms(p2) &amp;&amp; p1.getTimeLocation() != null &amp;&amp; p2.getTimeLocation() != null &amp;&amp; p1.getTimeLocation().hasIntersection(p2.getTimeLocation());<a name="line.2132"></a>
<span class="sourceLineNo">2133</span>    }<a name="line.2133"></a>
<span class="sourceLineNo">2134</span><a name="line.2134"></a>
<span class="sourceLineNo">2135</span>    private static boolean sameHours(int start1, int len1, int start2, int len2) {<a name="line.2135"></a>
<span class="sourceLineNo">2136</span>        if (len1 &gt; len2)<a name="line.2136"></a>
<span class="sourceLineNo">2137</span>            return sameHours(start2, len2, start1, len1);<a name="line.2137"></a>
<span class="sourceLineNo">2138</span>        start1 %= Constants.SLOTS_PER_DAY;<a name="line.2138"></a>
<span class="sourceLineNo">2139</span>        start2 %= Constants.SLOTS_PER_DAY;<a name="line.2139"></a>
<span class="sourceLineNo">2140</span>        return (start1 &gt;= start2 &amp;&amp; start1 + len1 &lt;= start2 + len2);<a name="line.2140"></a>
<span class="sourceLineNo">2141</span>    }<a name="line.2141"></a>
<span class="sourceLineNo">2142</span>    <a name="line.2142"></a>
<span class="sourceLineNo">2143</span>    private static boolean canFill(int totalGap, int gapMin, int gapMax, List&lt;Set&lt;Integer&gt;&gt; lengths) {<a name="line.2143"></a>
<span class="sourceLineNo">2144</span>        if (gapMin &lt;= totalGap &amp;&amp; totalGap &lt;= gapMax)<a name="line.2144"></a>
<span class="sourceLineNo">2145</span>            return true;<a name="line.2145"></a>
<span class="sourceLineNo">2146</span>        if (totalGap &lt; 2 * gapMin)<a name="line.2146"></a>
<span class="sourceLineNo">2147</span>            return false;<a name="line.2147"></a>
<span class="sourceLineNo">2148</span>        for (int i = 0; i &lt; lengths.size(); i++) {<a name="line.2148"></a>
<span class="sourceLineNo">2149</span>            Set&lt;Integer&gt; length = lengths.get(i);<a name="line.2149"></a>
<span class="sourceLineNo">2150</span>            lengths.remove(i);<a name="line.2150"></a>
<span class="sourceLineNo">2151</span>            for (int gap = gapMin; gap &lt;= gapMax; gap++)<a name="line.2151"></a>
<span class="sourceLineNo">2152</span>                for (Integer l: length)<a name="line.2152"></a>
<span class="sourceLineNo">2153</span>                    if (canFill(totalGap - gap - l, gapMin, gapMax, lengths))<a name="line.2153"></a>
<span class="sourceLineNo">2154</span>                        return true;<a name="line.2154"></a>
<span class="sourceLineNo">2155</span>            lengths.add(i, length);<a name="line.2155"></a>
<span class="sourceLineNo">2156</span>        }<a name="line.2156"></a>
<span class="sourceLineNo">2157</span>        return false;<a name="line.2157"></a>
<span class="sourceLineNo">2158</span>    }<a name="line.2158"></a>
<span class="sourceLineNo">2159</span><a name="line.2159"></a>
<span class="sourceLineNo">2160</span>    private boolean isSatisfiedSeq(Assignment&lt;Lecture, Placement&gt; assignment, HashMap&lt;Lecture, Placement&gt; assignments, Set&lt;Placement&gt; conflicts) {<a name="line.2160"></a>
<span class="sourceLineNo">2161</span>        if (conflicts == null)<a name="line.2161"></a>
<span class="sourceLineNo">2162</span>            return isSatisfiedSeqCheck(assignment, assignments, conflicts);<a name="line.2162"></a>
<span class="sourceLineNo">2163</span>        else {<a name="line.2163"></a>
<span class="sourceLineNo">2164</span>            Set&lt;Placement&gt; bestConflicts = isSatisfiedRecursive(assignment, 0, assignments, conflicts,<a name="line.2164"></a>
<span class="sourceLineNo">2165</span>                    new HashSet&lt;Placement&gt;(), null);<a name="line.2165"></a>
<span class="sourceLineNo">2166</span>            if (bestConflicts == null)<a name="line.2166"></a>
<span class="sourceLineNo">2167</span>                return false;<a name="line.2167"></a>
<span class="sourceLineNo">2168</span>            conflicts.addAll(bestConflicts);<a name="line.2168"></a>
<span class="sourceLineNo">2169</span>            return true;<a name="line.2169"></a>
<span class="sourceLineNo">2170</span>        }<a name="line.2170"></a>
<span class="sourceLineNo">2171</span>    }<a name="line.2171"></a>
<span class="sourceLineNo">2172</span><a name="line.2172"></a>
<span class="sourceLineNo">2173</span>    private Set&lt;Placement&gt; isSatisfiedRecursive(Assignment&lt;Lecture, Placement&gt; assignment, int idx, HashMap&lt;Lecture, Placement&gt; assignments,<a name="line.2173"></a>
<span class="sourceLineNo">2174</span>            Set&lt;Placement&gt; conflicts, Set&lt;Placement&gt; newConflicts, Set&lt;Placement&gt; bestConflicts) {<a name="line.2174"></a>
<span class="sourceLineNo">2175</span>        if (idx == variables().size() &amp;&amp; newConflicts.isEmpty())<a name="line.2175"></a>
<span class="sourceLineNo">2176</span>            return bestConflicts;<a name="line.2176"></a>
<span class="sourceLineNo">2177</span>        if (isSatisfiedSeqCheck(assignment, assignments, conflicts)) {<a name="line.2177"></a>
<span class="sourceLineNo">2178</span>            if (bestConflicts == null) {<a name="line.2178"></a>
<span class="sourceLineNo">2179</span>                return new HashSet&lt;Placement&gt;(newConflicts);<a name="line.2179"></a>
<span class="sourceLineNo">2180</span>            } else {<a name="line.2180"></a>
<span class="sourceLineNo">2181</span>                int b = 0, n = 0;<a name="line.2181"></a>
<span class="sourceLineNo">2182</span>                for (Placement value: assignments.values()) {<a name="line.2182"></a>
<span class="sourceLineNo">2183</span>                    if (value != null &amp;&amp; bestConflicts.contains(value)) b++;<a name="line.2183"></a>
<span class="sourceLineNo">2184</span>                    if (value != null &amp;&amp; newConflicts.contains(value)) n++;<a name="line.2184"></a>
<span class="sourceLineNo">2185</span>                }<a name="line.2185"></a>
<span class="sourceLineNo">2186</span>                if (n &lt; b || (n == b &amp;&amp; newConflicts.size() &lt; bestConflicts.size()))<a name="line.2186"></a>
<span class="sourceLineNo">2187</span>                    return new HashSet&lt;Placement&gt;(newConflicts);<a name="line.2187"></a>
<span class="sourceLineNo">2188</span>            }<a name="line.2188"></a>
<span class="sourceLineNo">2189</span>            return bestConflicts;<a name="line.2189"></a>
<span class="sourceLineNo">2190</span>        }<a name="line.2190"></a>
<span class="sourceLineNo">2191</span>        if (idx == variables().size())<a name="line.2191"></a>
<span class="sourceLineNo">2192</span>            return bestConflicts;<a name="line.2192"></a>
<span class="sourceLineNo">2193</span>        bestConflicts = isSatisfiedRecursive(assignment, idx + 1, assignments, conflicts, newConflicts,<a name="line.2193"></a>
<span class="sourceLineNo">2194</span>                bestConflicts);<a name="line.2194"></a>
<span class="sourceLineNo">2195</span>        Lecture lecture = variables().get(idx);<a name="line.2195"></a>
<span class="sourceLineNo">2196</span>        //if (assignments != null &amp;&amp; assignments.containsKey(lecture))<a name="line.2196"></a>
<span class="sourceLineNo">2197</span>        //    return bestConflicts;<a name="line.2197"></a>
<span class="sourceLineNo">2198</span>        Placement placement = null;<a name="line.2198"></a>
<span class="sourceLineNo">2199</span>        if (assignments != null &amp;&amp; assignments.containsKey(lecture))<a name="line.2199"></a>
<span class="sourceLineNo">2200</span>            placement = assignments.get(lecture);<a name="line.2200"></a>
<span class="sourceLineNo">2201</span>        else if (assignment != null)<a name="line.2201"></a>
<span class="sourceLineNo">2202</span>            placement = assignment.getValue(lecture);<a name="line.2202"></a>
<span class="sourceLineNo">2203</span>        if (placement == null)<a name="line.2203"></a>
<span class="sourceLineNo">2204</span>            return bestConflicts;<a name="line.2204"></a>
<span class="sourceLineNo">2205</span>        if (conflicts != null &amp;&amp; conflicts.contains(placement))<a name="line.2205"></a>
<span class="sourceLineNo">2206</span>            return bestConflicts;<a name="line.2206"></a>
<span class="sourceLineNo">2207</span>        conflicts.add(placement);<a name="line.2207"></a>
<span class="sourceLineNo">2208</span>        newConflicts.add(placement);<a name="line.2208"></a>
<span class="sourceLineNo">2209</span>        bestConflicts = isSatisfiedRecursive(assignment, idx + 1, assignments, conflicts, newConflicts, bestConflicts);<a name="line.2209"></a>
<span class="sourceLineNo">2210</span>        newConflicts.remove(placement);<a name="line.2210"></a>
<span class="sourceLineNo">2211</span>        conflicts.remove(placement);<a name="line.2211"></a>
<span class="sourceLineNo">2212</span>        return bestConflicts;<a name="line.2212"></a>
<span class="sourceLineNo">2213</span>    }<a name="line.2213"></a>
<span class="sourceLineNo">2214</span><a name="line.2214"></a>
<span class="sourceLineNo">2215</span>    private boolean isSatisfiedSeqCheck(Assignment&lt;Lecture, Placement&gt; assignment, HashMap&lt;Lecture, Placement&gt; assignments, Set&lt;Placement&gt; conflicts) {<a name="line.2215"></a>
<span class="sourceLineNo">2216</span>        if (!getType().is(Flag.BACK_TO_BACK)) return true;<a name="line.2216"></a>
<span class="sourceLineNo">2217</span>        int gapMin = getType().getMin();<a name="line.2217"></a>
<span class="sourceLineNo">2218</span>        int gapMax = getType().getMax();<a name="line.2218"></a>
<span class="sourceLineNo">2219</span><a name="line.2219"></a>
<span class="sourceLineNo">2220</span>        List&lt;Set&lt;Integer&gt;&gt; lengths = new ArrayList&lt;Set&lt;Integer&gt;&gt;();<a name="line.2220"></a>
<span class="sourceLineNo">2221</span><a name="line.2221"></a>
<span class="sourceLineNo">2222</span>        Placement[] res = new Placement[Constants.SLOTS_PER_DAY];<a name="line.2222"></a>
<span class="sourceLineNo">2223</span>        for (int i = 0; i &lt; Constants.SLOTS_PER_DAY; i++)<a name="line.2223"></a>
<span class="sourceLineNo">2224</span>            res[i] = null;<a name="line.2224"></a>
<span class="sourceLineNo">2225</span><a name="line.2225"></a>
<span class="sourceLineNo">2226</span>        int nrLectures = 0;<a name="line.2226"></a>
<span class="sourceLineNo">2227</span><a name="line.2227"></a>
<span class="sourceLineNo">2228</span>        for (Lecture lecture : variables()) {<a name="line.2228"></a>
<span class="sourceLineNo">2229</span>            Placement placement = null;<a name="line.2229"></a>
<span class="sourceLineNo">2230</span>            if (assignments != null &amp;&amp; assignments.containsKey(lecture))<a name="line.2230"></a>
<span class="sourceLineNo">2231</span>                placement = assignments.get(lecture);<a name="line.2231"></a>
<span class="sourceLineNo">2232</span>            else if (assignment != null)<a name="line.2232"></a>
<span class="sourceLineNo">2233</span>                placement = assignment.getValue(lecture);<a name="line.2233"></a>
<span class="sourceLineNo">2234</span>            if (placement == null) {<a name="line.2234"></a>
<span class="sourceLineNo">2235</span>                if (!lecture.timeLocations().isEmpty()) {<a name="line.2235"></a>
<span class="sourceLineNo">2236</span>                    Set&lt;Integer&gt; l = new HashSet&lt;Integer&gt;();<a name="line.2236"></a>
<span class="sourceLineNo">2237</span>                    for (TimeLocation time: lecture.timeLocations())<a name="line.2237"></a>
<span class="sourceLineNo">2238</span>                        l.add(time.getLength());<a name="line.2238"></a>
<span class="sourceLineNo">2239</span>                    lengths.add(l);<a name="line.2239"></a>
<span class="sourceLineNo">2240</span>                }<a name="line.2240"></a>
<span class="sourceLineNo">2241</span>            } else if (conflicts != null &amp;&amp; conflicts.contains(placement)) {<a name="line.2241"></a>
<span class="sourceLineNo">2242</span>                if (!lecture.timeLocations().isEmpty()) {<a name="line.2242"></a>
<span class="sourceLineNo">2243</span>                    Set&lt;Integer&gt; l = new HashSet&lt;Integer&gt;();<a name="line.2243"></a>
<span class="sourceLineNo">2244</span>                    for (TimeLocation time: lecture.timeLocations())<a name="line.2244"></a>
<span class="sourceLineNo">2245</span>                        l.add(time.getLength());<a name="line.2245"></a>
<span class="sourceLineNo">2246</span>                    lengths.add(l);<a name="line.2246"></a>
<span class="sourceLineNo">2247</span>                }<a name="line.2247"></a>
<span class="sourceLineNo">2248</span>            } else {<a name="line.2248"></a>
<span class="sourceLineNo">2249</span>                int pos = placement.getTimeLocation().getStartSlot();<a name="line.2249"></a>
<span class="sourceLineNo">2250</span>                int length = placement.getTimeLocation().getLength();<a name="line.2250"></a>
<span class="sourceLineNo">2251</span>                for (int j = pos; j &lt; pos + length; j++) {<a name="line.2251"></a>
<span class="sourceLineNo">2252</span>                    if (res[j] != null) {<a name="line.2252"></a>
<span class="sourceLineNo">2253</span>                        if (conflicts == null)<a name="line.2253"></a>
<span class="sourceLineNo">2254</span>                            return false;<a name="line.2254"></a>
<span class="sourceLineNo">2255</span>                        if (!assignments.containsKey(lecture))<a name="line.2255"></a>
<span class="sourceLineNo">2256</span>                            conflicts.add(placement);<a name="line.2256"></a>
<span class="sourceLineNo">2257</span>                        else if (!assignments.containsKey(res[j].variable()))<a name="line.2257"></a>
<span class="sourceLineNo">2258</span>                            conflicts.add(res[j]);<a name="line.2258"></a>
<span class="sourceLineNo">2259</span>                    }<a name="line.2259"></a>
<span class="sourceLineNo">2260</span>                }<a name="line.2260"></a>
<span class="sourceLineNo">2261</span>                for (int j = pos; j &lt; pos + length; j++)<a name="line.2261"></a>
<span class="sourceLineNo">2262</span>                    res[j] = placement;<a name="line.2262"></a>
<span class="sourceLineNo">2263</span>                nrLectures++;<a name="line.2263"></a>
<span class="sourceLineNo">2264</span>            }<a name="line.2264"></a>
<span class="sourceLineNo">2265</span>        }<a name="line.2265"></a>
<span class="sourceLineNo">2266</span>        if (nrLectures &lt;= 1)<a name="line.2266"></a>
<span class="sourceLineNo">2267</span>            return true;<a name="line.2267"></a>
<span class="sourceLineNo">2268</span><a name="line.2268"></a>
<span class="sourceLineNo">2269</span>        if (iIsRequired || (!iIsProhibited &amp;&amp; iPreference &lt; 0)) {<a name="line.2269"></a>
<span class="sourceLineNo">2270</span>            int i = 0;<a name="line.2270"></a>
<span class="sourceLineNo">2271</span>            Placement p = res[i];<a name="line.2271"></a>
<span class="sourceLineNo">2272</span>            while (p == null)<a name="line.2272"></a>
<span class="sourceLineNo">2273</span>                p = res[++i];<a name="line.2273"></a>
<span class="sourceLineNo">2274</span>            i = res[i].getTimeLocation().getStartSlot() + res[i].getTimeLocation().getLength();<a name="line.2274"></a>
<span class="sourceLineNo">2275</span>            nrLectures--;<a name="line.2275"></a>
<span class="sourceLineNo">2276</span>            while (nrLectures &gt; 0) {<a name="line.2276"></a>
<span class="sourceLineNo">2277</span>                int gap = 0;<a name="line.2277"></a>
<span class="sourceLineNo">2278</span>                while (i &lt; Constants.SLOTS_PER_DAY &amp;&amp; res[i] == null) {<a name="line.2278"></a>
<span class="sourceLineNo">2279</span>                    gap++;<a name="line.2279"></a>
<span class="sourceLineNo">2280</span>                    i++;<a name="line.2280"></a>
<span class="sourceLineNo">2281</span>                }<a name="line.2281"></a>
<span class="sourceLineNo">2282</span>                if (i == Constants.SLOTS_PER_DAY)<a name="line.2282"></a>
<span class="sourceLineNo">2283</span>                    break;<a name="line.2283"></a>
<span class="sourceLineNo">2284</span>                if (!canFill(gap, gapMin, gapMax, lengths))<a name="line.2284"></a>
<span class="sourceLineNo">2285</span>                    return false;<a name="line.2285"></a>
<span class="sourceLineNo">2286</span>                p = res[i];<a name="line.2286"></a>
<span class="sourceLineNo">2287</span>                i = res[i].getTimeLocation().getStartSlot() + res[i].getTimeLocation().getLength();<a name="line.2287"></a>
<span class="sourceLineNo">2288</span>                nrLectures--;<a name="line.2288"></a>
<span class="sourceLineNo">2289</span>            }<a name="line.2289"></a>
<span class="sourceLineNo">2290</span>        } else if (iIsProhibited || (!iIsRequired &amp;&amp; iPreference &gt; 0)) {<a name="line.2290"></a>
<span class="sourceLineNo">2291</span>            int i = 0;<a name="line.2291"></a>
<span class="sourceLineNo">2292</span>            Placement p = res[i];<a name="line.2292"></a>
<span class="sourceLineNo">2293</span>            while (p == null)<a name="line.2293"></a>
<span class="sourceLineNo">2294</span>                p = res[++i];<a name="line.2294"></a>
<span class="sourceLineNo">2295</span>            i = res[i].getTimeLocation().getStartSlot() + res[i].getTimeLocation().getLength();<a name="line.2295"></a>
<span class="sourceLineNo">2296</span>            nrLectures--;<a name="line.2296"></a>
<span class="sourceLineNo">2297</span>            while (nrLectures &gt; 0) {<a name="line.2297"></a>
<span class="sourceLineNo">2298</span>                int gap = 0;<a name="line.2298"></a>
<span class="sourceLineNo">2299</span>                while (i &lt; Constants.SLOTS_PER_DAY &amp;&amp; res[i] == null) {<a name="line.2299"></a>
<span class="sourceLineNo">2300</span>                    gap++;<a name="line.2300"></a>
<span class="sourceLineNo">2301</span>                    i++;<a name="line.2301"></a>
<span class="sourceLineNo">2302</span>                }<a name="line.2302"></a>
<span class="sourceLineNo">2303</span>                if (i == Constants.SLOTS_PER_DAY)<a name="line.2303"></a>
<span class="sourceLineNo">2304</span>                    break;<a name="line.2304"></a>
<span class="sourceLineNo">2305</span>                if ((gapMin == 0 || !canFill(gap, 0, gapMin - 1, lengths))<a name="line.2305"></a>
<span class="sourceLineNo">2306</span>                        &amp;&amp; (gapMax &gt;= Constants.SLOTS_PER_DAY || !canFill(gap, gapMax + 1, Constants.SLOTS_PER_DAY,<a name="line.2306"></a>
<span class="sourceLineNo">2307</span>                                lengths))) {<a name="line.2307"></a>
<span class="sourceLineNo">2308</span>                    return false;<a name="line.2308"></a>
<span class="sourceLineNo">2309</span>                }<a name="line.2309"></a>
<span class="sourceLineNo">2310</span>                p = res[i];<a name="line.2310"></a>
<span class="sourceLineNo">2311</span>                i = res[i].getTimeLocation().getStartSlot() + res[i].getTimeLocation().getLength();<a name="line.2311"></a>
<span class="sourceLineNo">2312</span>                nrLectures--;<a name="line.2312"></a>
<span class="sourceLineNo">2313</span>            }<a name="line.2313"></a>
<span class="sourceLineNo">2314</span>        }<a name="line.2314"></a>
<span class="sourceLineNo">2315</span>        return true;<a name="line.2315"></a>
<span class="sourceLineNo">2316</span>    }<a name="line.2316"></a>
<span class="sourceLineNo">2317</span><a name="line.2317"></a>
<span class="sourceLineNo">2318</span>    public boolean isSatisfied(Assignment&lt;Lecture, Placement&gt; assignment) {<a name="line.2318"></a>
<span class="sourceLineNo">2319</span>        if (isHard()) return true;<a name="line.2319"></a>
<span class="sourceLineNo">2320</span>        if (countAssignedVariables(assignment) &lt; 2) return true;<a name="line.2320"></a>
<span class="sourceLineNo">2321</span>        if (getPreference() == 0) return true;<a name="line.2321"></a>
<span class="sourceLineNo">2322</span>        return isHard() || countAssignedVariables(assignment) &lt; 2 || getPreference() == 0 || getCurrentPreference(assignment) &lt; 0;<a name="line.2322"></a>
<span class="sourceLineNo">2323</span>    }<a name="line.2323"></a>
<span class="sourceLineNo">2324</span><a name="line.2324"></a>
<span class="sourceLineNo">2325</span>    public boolean isChildrenNotOverlap(Assignment&lt;Lecture, Placement&gt; assignment, Lecture lec1, Placement plc1, Lecture lec2, Placement plc2) {<a name="line.2325"></a>
<span class="sourceLineNo">2326</span>        if (lec1.getSchedulingSubpartId().equals(lec2.getSchedulingSubpartId())) {<a name="line.2326"></a>
<span class="sourceLineNo">2327</span>            // same subpart<a name="line.2327"></a>
<span class="sourceLineNo">2328</span>            boolean overlap = plc1.getTimeLocation().hasIntersection(plc2.getTimeLocation());<a name="line.2328"></a>
<span class="sourceLineNo">2329</span><a name="line.2329"></a>
<span class="sourceLineNo">2330</span>            if (overlap &amp;&amp; lec1.getParent() != null &amp;&amp; variables().contains(lec1.getParent())<a name="line.2330"></a>
<span class="sourceLineNo">2331</span>                    &amp;&amp; lec2.getParent() != null &amp;&amp; variables().contains(lec2.getParent())) {<a name="line.2331"></a>
<span class="sourceLineNo">2332</span>                // children overlaps<a name="line.2332"></a>
<span class="sourceLineNo">2333</span>                Placement p1 = assignment.getValue(lec1.getParent());<a name="line.2333"></a>
<span class="sourceLineNo">2334</span>                Placement p2 = assignment.getValue(lec2.getParent());<a name="line.2334"></a>
<span class="sourceLineNo">2335</span>                // parents not overlap, but children do<a name="line.2335"></a>
<span class="sourceLineNo">2336</span>                if (p1 != null &amp;&amp; p2 != null &amp;&amp; !p1.getTimeLocation().hasIntersection(p2.getTimeLocation()))<a name="line.2336"></a>
<span class="sourceLineNo">2337</span>                    return false;<a name="line.2337"></a>
<span class="sourceLineNo">2338</span>            }<a name="line.2338"></a>
<span class="sourceLineNo">2339</span><a name="line.2339"></a>
<span class="sourceLineNo">2340</span>            if (!overlap &amp;&amp; lec1.getChildrenSubpartIds() != null &amp;&amp; lec2.getChildrenSubpartIds() != null) {<a name="line.2340"></a>
<span class="sourceLineNo">2341</span>                // parents not overlap<a name="line.2341"></a>
<span class="sourceLineNo">2342</span>                for (Long subpartId: lec1.getChildrenSubpartIds()) {<a name="line.2342"></a>
<span class="sourceLineNo">2343</span>                    for (Lecture c1 : lec1.getChildren(subpartId)) {<a name="line.2343"></a>
<span class="sourceLineNo">2344</span>                        Placement p1 = assignment.getValue(c1);<a name="line.2344"></a>
<span class="sourceLineNo">2345</span>                        if (p1 == null) continue;<a name="line.2345"></a>
<span class="sourceLineNo">2346</span>                        for (Lecture c2 : lec2.getChildren(subpartId)) {<a name="line.2346"></a>
<span class="sourceLineNo">2347</span>                            Placement p2 = assignment.getValue(c2);<a name="line.2347"></a>
<span class="sourceLineNo">2348</span>                            if (p2 == null) continue;<a name="line.2348"></a>
<span class="sourceLineNo">2349</span>                            if (!c1.getSchedulingSubpartId().equals(c2.getSchedulingSubpartId())) continue;<a name="line.2349"></a>
<span class="sourceLineNo">2350</span>                            // parents not overlap, but children do<a name="line.2350"></a>
<span class="sourceLineNo">2351</span>                            if (p1.getTimeLocation().hasIntersection(p2.getTimeLocation()))<a name="line.2351"></a>
<span class="sourceLineNo">2352</span>                                return false;<a name="line.2352"></a>
<span class="sourceLineNo">2353</span>                        }<a name="line.2353"></a>
<span class="sourceLineNo">2354</span>                    }<a name="line.2354"></a>
<span class="sourceLineNo">2355</span>                }<a name="line.2355"></a>
<span class="sourceLineNo">2356</span>            }<a name="line.2356"></a>
<span class="sourceLineNo">2357</span>        } else {<a name="line.2357"></a>
<span class="sourceLineNo">2358</span>            // different subpart<a name="line.2358"></a>
<span class="sourceLineNo">2359</span>        }<a name="line.2359"></a>
<span class="sourceLineNo">2360</span>        return true;<a name="line.2360"></a>
<span class="sourceLineNo">2361</span>    }<a name="line.2361"></a>
<span class="sourceLineNo">2362</span><a name="line.2362"></a>
<span class="sourceLineNo">2363</span>    public boolean isSatisfiedPair(Assignment&lt;Lecture, Placement&gt; assignment, Placement plc1, Placement plc2) {<a name="line.2363"></a>
<span class="sourceLineNo">2364</span>        if (iIsRequired || (!iIsProhibited &amp;&amp; iPreference &lt;= 0))<a name="line.2364"></a>
<span class="sourceLineNo">2365</span>            return getType().isSatisfied(assignment, this, plc1, plc2);<a name="line.2365"></a>
<span class="sourceLineNo">2366</span>        else if (iIsProhibited || (!iIsRequired &amp;&amp; iPreference &gt; 0))<a name="line.2366"></a>
<span class="sourceLineNo">2367</span>            return getType().isViolated(assignment, this, plc1, plc2);<a name="line.2367"></a>
<span class="sourceLineNo">2368</span>        return true;<a name="line.2368"></a>
<span class="sourceLineNo">2369</span>    }<a name="line.2369"></a>
<span class="sourceLineNo">2370</span>    <a name="line.2370"></a>
<span class="sourceLineNo">2371</span>    public boolean canShareRoom() {<a name="line.2371"></a>
<span class="sourceLineNo">2372</span>        return getType().is(Flag.CAN_SHARE_ROOM);<a name="line.2372"></a>
<span class="sourceLineNo">2373</span>    }<a name="line.2373"></a>
<span class="sourceLineNo">2374</span>    <a name="line.2374"></a>
<span class="sourceLineNo">2375</span>    protected int nrSlotsADay(Assignment&lt;Lecture, Placement&gt; assignment, int dayCode, BitSet week, HashMap&lt;Lecture, Placement&gt; assignments, Set&lt;Placement&gt; conflicts) {<a name="line.2375"></a>
<span class="sourceLineNo">2376</span>        Set&lt;Integer&gt; slots = new HashSet&lt;Integer&gt;();<a name="line.2376"></a>
<span class="sourceLineNo">2377</span>        for (Lecture lecture: variables()) {<a name="line.2377"></a>
<span class="sourceLineNo">2378</span>            Placement placement = null;<a name="line.2378"></a>
<span class="sourceLineNo">2379</span>            if (assignments != null &amp;&amp; assignments.containsKey(lecture))<a name="line.2379"></a>
<span class="sourceLineNo">2380</span>                placement = assignments.get(lecture);<a name="line.2380"></a>
<span class="sourceLineNo">2381</span>            else if (assignment != null)<a name="line.2381"></a>
<span class="sourceLineNo">2382</span>                placement = assignment.getValue(lecture);<a name="line.2382"></a>
<span class="sourceLineNo">2383</span>            if (placement == null || placement.getTimeLocation() == null) continue;<a name="line.2383"></a>
<span class="sourceLineNo">2384</span>            if (conflicts != null &amp;&amp; conflicts.contains(placement)) continue;<a name="line.2384"></a>
<span class="sourceLineNo">2385</span>            TimeLocation t = placement.getTimeLocation();<a name="line.2385"></a>
<span class="sourceLineNo">2386</span>            if (t == null || (t.getDayCode() &amp; dayCode) == 0 || (week != null &amp;&amp; !t.shareWeeks(week))) continue;<a name="line.2386"></a>
<span class="sourceLineNo">2387</span>            for (int i = 0; i &lt; t.getLength(); i++)<a name="line.2387"></a>
<span class="sourceLineNo">2388</span>                slots.add(i + t.getStartSlot());<a name="line.2388"></a>
<span class="sourceLineNo">2389</span>        }<a name="line.2389"></a>
<span class="sourceLineNo">2390</span>        return slots.size();<a name="line.2390"></a>
<span class="sourceLineNo">2391</span>    }<a name="line.2391"></a>
<span class="sourceLineNo">2392</span>    <a name="line.2392"></a>
<span class="sourceLineNo">2393</span>    protected int nrSlotsADay(Assignment&lt;Lecture, Placement&gt; assignment, int date, HashMap&lt;Lecture, Placement&gt; assignments, Set&lt;Placement&gt; conflicts) {<a name="line.2393"></a>
<span class="sourceLineNo">2394</span>        Set&lt;Integer&gt; slots = new HashSet&lt;Integer&gt;();<a name="line.2394"></a>
<span class="sourceLineNo">2395</span>        for (Lecture lecture: variables()) {<a name="line.2395"></a>
<span class="sourceLineNo">2396</span>            Placement placement = null;<a name="line.2396"></a>
<span class="sourceLineNo">2397</span>            if (assignments != null &amp;&amp; assignments.containsKey(lecture))<a name="line.2397"></a>
<span class="sourceLineNo">2398</span>                placement = assignments.get(lecture);<a name="line.2398"></a>
<span class="sourceLineNo">2399</span>            else if (assignment != null)<a name="line.2399"></a>
<span class="sourceLineNo">2400</span>                placement = assignment.getValue(lecture);<a name="line.2400"></a>
<span class="sourceLineNo">2401</span>            if (placement == null || placement.getTimeLocation() == null) continue;<a name="line.2401"></a>
<span class="sourceLineNo">2402</span>            if (conflicts != null &amp;&amp; conflicts.contains(placement)) continue;<a name="line.2402"></a>
<span class="sourceLineNo">2403</span>            TimeLocation t = placement.getTimeLocation();<a name="line.2403"></a>
<span class="sourceLineNo">2404</span>            if (t == null || !t.hasDate(date, iDayOfWeekOffset)) continue;<a name="line.2404"></a>
<span class="sourceLineNo">2405</span>            for (int i = 0; i &lt; t.getLength(); i++)<a name="line.2405"></a>
<span class="sourceLineNo">2406</span>                slots.add(i + t.getStartSlot());<a name="line.2406"></a>
<span class="sourceLineNo">2407</span>        }<a name="line.2407"></a>
<span class="sourceLineNo">2408</span>        return slots.size();<a name="line.2408"></a>
<span class="sourceLineNo">2409</span>    }<a name="line.2409"></a>
<span class="sourceLineNo">2410</span><a name="line.2410"></a>
<span class="sourceLineNo">2411</span>    @Override<a name="line.2411"></a>
<span class="sourceLineNo">2412</span>    public boolean equals(Object o) {<a name="line.2412"></a>
<span class="sourceLineNo">2413</span>        if (o == null || !(o instanceof GroupConstraint)) return false;<a name="line.2413"></a>
<span class="sourceLineNo">2414</span>        return getGeneratedId() == ((GroupConstraint) o).getGeneratedId();<a name="line.2414"></a>
<span class="sourceLineNo">2415</span>    }<a name="line.2415"></a>
<span class="sourceLineNo">2416</span>    <a name="line.2416"></a>
<span class="sourceLineNo">2417</span>    @Override<a name="line.2417"></a>
<span class="sourceLineNo">2418</span>    public GroupConstraintContext createAssignmentContext(Assignment&lt;Lecture, Placement&gt; assignment) {<a name="line.2418"></a>
<span class="sourceLineNo">2419</span>        return new GroupConstraintContext(assignment);<a name="line.2419"></a>
<span class="sourceLineNo">2420</span>    }<a name="line.2420"></a>
<span class="sourceLineNo">2421</span><a name="line.2421"></a>
<span class="sourceLineNo">2422</span>    public class GroupConstraintContext implements AssignmentConstraintContext&lt;Lecture, Placement&gt; {<a name="line.2422"></a>
<span class="sourceLineNo">2423</span>        protected int iLastPreference = 0;<a name="line.2423"></a>
<span class="sourceLineNo">2424</span>        <a name="line.2424"></a>
<span class="sourceLineNo">2425</span>        public GroupConstraintContext(Assignment&lt;Lecture, Placement&gt; assignment) {<a name="line.2425"></a>
<span class="sourceLineNo">2426</span>            updateCriterion(assignment);<a name="line.2426"></a>
<span class="sourceLineNo">2427</span>        }<a name="line.2427"></a>
<span class="sourceLineNo">2428</span><a name="line.2428"></a>
<span class="sourceLineNo">2429</span>        @Override<a name="line.2429"></a>
<span class="sourceLineNo">2430</span>        public void assigned(Assignment&lt;Lecture, Placement&gt; assignment, Placement value) {<a name="line.2430"></a>
<span class="sourceLineNo">2431</span>            updateCriterion(assignment);<a name="line.2431"></a>
<span class="sourceLineNo">2432</span>        }<a name="line.2432"></a>
<span class="sourceLineNo">2433</span><a name="line.2433"></a>
<span class="sourceLineNo">2434</span>        @Override<a name="line.2434"></a>
<span class="sourceLineNo">2435</span>        public void unassigned(Assignment&lt;Lecture, Placement&gt; assignment, Placement value) {<a name="line.2435"></a>
<span class="sourceLineNo">2436</span>            updateCriterion(assignment);<a name="line.2436"></a>
<span class="sourceLineNo">2437</span>        }<a name="line.2437"></a>
<span class="sourceLineNo">2438</span>        <a name="line.2438"></a>
<span class="sourceLineNo">2439</span>        protected void updateCriterion(Assignment&lt;Lecture, Placement&gt; assignment) {<a name="line.2439"></a>
<span class="sourceLineNo">2440</span>            if (!isHard()) {<a name="line.2440"></a>
<span class="sourceLineNo">2441</span>                getModel().getCriterion(DistributionPreferences.class).inc(assignment, -iLastPreference);<a name="line.2441"></a>
<span class="sourceLineNo">2442</span>                iLastPreference = getCurrentPreference(assignment) + Math.abs(iPreference);<a name="line.2442"></a>
<span class="sourceLineNo">2443</span>                getModel().getCriterion(DistributionPreferences.class).inc(assignment, iLastPreference);<a name="line.2443"></a>
<span class="sourceLineNo">2444</span>            }<a name="line.2444"></a>
<span class="sourceLineNo">2445</span>        }<a name="line.2445"></a>
<span class="sourceLineNo">2446</span>        <a name="line.2446"></a>
<span class="sourceLineNo">2447</span>        public int getPreference() { return iLastPreference; }<a name="line.2447"></a>
<span class="sourceLineNo">2448</span>    }<a name="line.2448"></a>
<span class="sourceLineNo">2449</span>    <a name="line.2449"></a>
<span class="sourceLineNo">2450</span>    private boolean isBackToBackWeeks(TimeLocation t1, TimeLocation t2) {<a name="line.2450"></a>
<span class="sourceLineNo">2451</span>        if (t1.shareWeeks(t2)) return false;<a name="line.2451"></a>
<span class="sourceLineNo">2452</span>        int f1 = t1.getWeekCode().nextSetBit(0);<a name="line.2452"></a>
<span class="sourceLineNo">2453</span>        int e1 = t1.getWeekCode().previousSetBit(t1.getWeekCode().size());<a name="line.2453"></a>
<span class="sourceLineNo">2454</span>        int f2 = t2.getWeekCode().nextSetBit(0);<a name="line.2454"></a>
<span class="sourceLineNo">2455</span>        int e2 = t2.getWeekCode().previousSetBit(t2.getWeekCode().size());<a name="line.2455"></a>
<span class="sourceLineNo">2456</span>        if (e1 &lt; f2) {<a name="line.2456"></a>
<span class="sourceLineNo">2457</span>            return (f2 - e1) &lt; 7;<a name="line.2457"></a>
<span class="sourceLineNo">2458</span>        } else if (e2 &lt; f1) {<a name="line.2458"></a>
<span class="sourceLineNo">2459</span>            return (f1 - e2) &lt; 7;<a name="line.2459"></a>
<span class="sourceLineNo">2460</span>        }<a name="line.2460"></a>
<span class="sourceLineNo">2461</span>        return false;<a name="line.2461"></a>
<span class="sourceLineNo">2462</span>    }<a name="line.2462"></a>
<span class="sourceLineNo">2463</span>    <a name="line.2463"></a>
<span class="sourceLineNo">2464</span>    private boolean isMaxWeekSpan(TimeLocation t1, TimeLocation t2, int nrWeeks) {<a name="line.2464"></a>
<span class="sourceLineNo">2465</span>        if (t1.shareWeeks(t2)) return false;<a name="line.2465"></a>
<span class="sourceLineNo">2466</span>        if (isBackToBackWeeks(t1, t2)) return true;<a name="line.2466"></a>
<span class="sourceLineNo">2467</span>        <a name="line.2467"></a>
<span class="sourceLineNo">2468</span>        int f1 = t1.getWeekCode().nextSetBit(0);<a name="line.2468"></a>
<span class="sourceLineNo">2469</span>        int e1 = t1.getWeekCode().previousSetBit(t1.getWeekCode().size());<a name="line.2469"></a>
<span class="sourceLineNo">2470</span>        int f2 = t2.getWeekCode().nextSetBit(0);<a name="line.2470"></a>
<span class="sourceLineNo">2471</span>        int e2 = t2.getWeekCode().previousSetBit(t2.getWeekCode().size());<a name="line.2471"></a>
<span class="sourceLineNo">2472</span>        if (e1 &lt; f2) {<a name="line.2472"></a>
<span class="sourceLineNo">2473</span>            return (3 + e2 - f1) / 7 &lt;= nrWeeks;<a name="line.2473"></a>
<span class="sourceLineNo">2474</span>        } else if (e2 &lt; f1) {<a name="line.2474"></a>
<span class="sourceLineNo">2475</span>            return (3 + e1 - f2) / 7 &lt;= nrWeeks;<a name="line.2475"></a>
<span class="sourceLineNo">2476</span>        }<a name="line.2476"></a>
<span class="sourceLineNo">2477</span>        return false;<a name="line.2477"></a>
<span class="sourceLineNo">2478</span>    }<a name="line.2478"></a>
<span class="sourceLineNo">2479</span>    <a name="line.2479"></a>
<span class="sourceLineNo">2480</span>    private boolean isNotBackToBackWeeks(TimeLocation t1, TimeLocation t2) {<a name="line.2480"></a>
<span class="sourceLineNo">2481</span>        if (t1.shareWeeks(t2)) return false;<a name="line.2481"></a>
<span class="sourceLineNo">2482</span>        int f1 = t1.getWeekCode().nextSetBit(0);<a name="line.2482"></a>
<span class="sourceLineNo">2483</span>        int e1 = t1.getWeekCode().previousSetBit(t1.getWeekCode().size());<a name="line.2483"></a>
<span class="sourceLineNo">2484</span>        int f2 = t2.getWeekCode().nextSetBit(0);<a name="line.2484"></a>
<span class="sourceLineNo">2485</span>        int e2 = t2.getWeekCode().previousSetBit(t2.getWeekCode().size());<a name="line.2485"></a>
<span class="sourceLineNo">2486</span>        if (e1 &lt; f2) {<a name="line.2486"></a>
<span class="sourceLineNo">2487</span>            return (f2 - e1) &gt;= 7;<a name="line.2487"></a>
<span class="sourceLineNo">2488</span>        } else if (e2 &lt; f1) {<a name="line.2488"></a>
<span class="sourceLineNo">2489</span>            return (f1 - e2) &gt;= 7;<a name="line.2489"></a>
<span class="sourceLineNo">2490</span>        }<a name="line.2490"></a>
<span class="sourceLineNo">2491</span>        return false;<a name="line.2491"></a>
<span class="sourceLineNo">2492</span>    }<a name="line.2492"></a>
<span class="sourceLineNo">2493</span>    <a name="line.2493"></a>
<span class="sourceLineNo">2494</span>    private boolean isFollowingWeeksBTB(Placement p1, Placement p2, boolean btb) {<a name="line.2494"></a>
<span class="sourceLineNo">2495</span>        int ord1 = variables().indexOf(p1.variable());<a name="line.2495"></a>
<span class="sourceLineNo">2496</span>        int ord2 = variables().indexOf(p2.variable());<a name="line.2496"></a>
<span class="sourceLineNo">2497</span>        TimeLocation t1, t2;<a name="line.2497"></a>
<span class="sourceLineNo">2498</span>        boolean following = false;<a name="line.2498"></a>
<span class="sourceLineNo">2499</span>        if (ord1 &lt; ord2) {<a name="line.2499"></a>
<span class="sourceLineNo">2500</span>            t1 = p1.getTimeLocation();<a name="line.2500"></a>
<span class="sourceLineNo">2501</span>            t2 = p2.getTimeLocation();<a name="line.2501"></a>
<span class="sourceLineNo">2502</span>            if (ord1 + 1 == ord2) following = true;<a name="line.2502"></a>
<span class="sourceLineNo">2503</span>        } else {<a name="line.2503"></a>
<span class="sourceLineNo">2504</span>            t2 = p1.getTimeLocation();<a name="line.2504"></a>
<span class="sourceLineNo">2505</span>            t1 = p2.getTimeLocation();<a name="line.2505"></a>
<span class="sourceLineNo">2506</span>            if (ord2 + 1 == ord1) following = true;<a name="line.2506"></a>
<span class="sourceLineNo">2507</span>        }<a name="line.2507"></a>
<span class="sourceLineNo">2508</span>        if (t1.shareWeeks(t2)) return false;<a name="line.2508"></a>
<span class="sourceLineNo">2509</span>        int e1 = t1.getWeekCode().previousSetBit(t1.getWeekCode().size());<a name="line.2509"></a>
<span class="sourceLineNo">2510</span>        int s2 = t2.getWeekCode().nextSetBit(0);<a name="line.2510"></a>
<span class="sourceLineNo">2511</span>        if (e1 &gt;= s2) return false;<a name="line.2511"></a>
<span class="sourceLineNo">2512</span>        if (!btb) // not back-to-back: any two classes must be at least a week apart<a name="line.2512"></a>
<span class="sourceLineNo">2513</span>            return (s2 - e1) &gt;= 7;<a name="line.2513"></a>
<span class="sourceLineNo">2514</span>        else if (following) // back-to-back and following classes: must be within a week<a name="line.2514"></a>
<span class="sourceLineNo">2515</span>            return (s2 - e1) &lt; 7;<a name="line.2515"></a>
<span class="sourceLineNo">2516</span>        else // back-to-back and not following: just the order<a name="line.2516"></a>
<span class="sourceLineNo">2517</span>            return true;<a name="line.2517"></a>
<span class="sourceLineNo">2518</span>    }<a name="line.2518"></a>
<span class="sourceLineNo">2519</span>    <a name="line.2519"></a>
<span class="sourceLineNo">2520</span>    private boolean isDifferentDates(TimeLocation t1, TimeLocation t2) {<a name="line.2520"></a>
<span class="sourceLineNo">2521</span>        if (!t1.shareDays(t2) || !t1.shareWeeks(t2)) return true;<a name="line.2521"></a>
<span class="sourceLineNo">2522</span>        for (Enumeration&lt;Integer&gt; e = t1.getDates(iDayOfWeekOffset); e.hasMoreElements(); ) {<a name="line.2522"></a>
<span class="sourceLineNo">2523</span>            Integer date = e.nextElement();<a name="line.2523"></a>
<span class="sourceLineNo">2524</span>            if (t2.hasDate(date, iDayOfWeekOffset)) return false;<a name="line.2524"></a>
<span class="sourceLineNo">2525</span>        }<a name="line.2525"></a>
<span class="sourceLineNo">2526</span>        return true;<a name="line.2526"></a>
<span class="sourceLineNo">2527</span>    }<a name="line.2527"></a>
<span class="sourceLineNo">2528</span>    <a name="line.2528"></a>
<span class="sourceLineNo">2529</span>    private boolean isSameDates(TimeLocation t1, TimeLocation t2) {<a name="line.2529"></a>
<span class="sourceLineNo">2530</span>        if (!t1.shareDays(t2) || !t1.shareWeeks(t2)) return false;<a name="line.2530"></a>
<span class="sourceLineNo">2531</span>        // t1 is meets less often<a name="line.2531"></a>
<span class="sourceLineNo">2532</span>        if (t1.countDates(iDayOfWeekOffset) &gt; t2.countDates(iDayOfWeekOffset)) {<a name="line.2532"></a>
<span class="sourceLineNo">2533</span>            TimeLocation t = t1; t1 = t2; t2 = t;<a name="line.2533"></a>
<span class="sourceLineNo">2534</span>        }<a name="line.2534"></a>
<span class="sourceLineNo">2535</span>        for (Enumeration&lt;Integer&gt; e = t1.getDates(iDayOfWeekOffset); e.hasMoreElements(); ) {<a name="line.2535"></a>
<span class="sourceLineNo">2536</span>            Integer date = e.nextElement();<a name="line.2536"></a>
<span class="sourceLineNo">2537</span>            if (!t2.hasDate(date, iDayOfWeekOffset)) return false;<a name="line.2537"></a>
<span class="sourceLineNo">2538</span>        }<a name="line.2538"></a>
<span class="sourceLineNo">2539</span>        return true;<a name="line.2539"></a>
<span class="sourceLineNo">2540</span>    }<a name="line.2540"></a>
<span class="sourceLineNo">2541</span>    <a name="line.2541"></a>
<span class="sourceLineNo">2542</span>    private int nextDate(BitSet weekCode, int dayCode, int nextDate) {<a name="line.2542"></a>
<span class="sourceLineNo">2543</span>        while (true) {<a name="line.2543"></a>
<span class="sourceLineNo">2544</span>            nextDate = weekCode.nextSetBit(1 + nextDate);<a name="line.2544"></a>
<span class="sourceLineNo">2545</span>            if (nextDate &lt; 0) return -1;<a name="line.2545"></a>
<span class="sourceLineNo">2546</span>            int dow = (nextDate + iDayOfWeekOffset) % 7;<a name="line.2546"></a>
<span class="sourceLineNo">2547</span>            if ((dayCode &amp; Constants.DAY_CODES[dow]) != 0) return nextDate;<a name="line.2547"></a>
<span class="sourceLineNo">2548</span>        }<a name="line.2548"></a>
<span class="sourceLineNo">2549</span>    }<a name="line.2549"></a>
<span class="sourceLineNo">2550</span>    <a name="line.2550"></a>
<span class="sourceLineNo">2551</span>    private boolean isFollowingDates(Placement p1, Placement p2, boolean btb) {<a name="line.2551"></a>
<span class="sourceLineNo">2552</span>        int ord1 = variables().indexOf(p1.variable());<a name="line.2552"></a>
<span class="sourceLineNo">2553</span>        int ord2 = variables().indexOf(p2.variable());<a name="line.2553"></a>
<span class="sourceLineNo">2554</span>        TimeLocation t1, t2;<a name="line.2554"></a>
<span class="sourceLineNo">2555</span>        boolean following = false;<a name="line.2555"></a>
<span class="sourceLineNo">2556</span>        if (ord1 &lt; ord2) {<a name="line.2556"></a>
<span class="sourceLineNo">2557</span>            t1 = p1.getTimeLocation();<a name="line.2557"></a>
<span class="sourceLineNo">2558</span>            t2 = p2.getTimeLocation();<a name="line.2558"></a>
<span class="sourceLineNo">2559</span>            if (ord1 + 1 == ord2) following = true;<a name="line.2559"></a>
<span class="sourceLineNo">2560</span>        } else {<a name="line.2560"></a>
<span class="sourceLineNo">2561</span>            t2 = p1.getTimeLocation();<a name="line.2561"></a>
<span class="sourceLineNo">2562</span>            t1 = p2.getTimeLocation();<a name="line.2562"></a>
<span class="sourceLineNo">2563</span>            if (ord2 + 1 == ord1) following = true;<a name="line.2563"></a>
<span class="sourceLineNo">2564</span>        }<a name="line.2564"></a>
<span class="sourceLineNo">2565</span>        int d1 = nextDate(t1.getWeekCode(), t1.getDayCode(), -1);<a name="line.2565"></a>
<span class="sourceLineNo">2566</span>        int d2 = nextDate(t2.getWeekCode(), t2.getDayCode(), -1);<a name="line.2566"></a>
<span class="sourceLineNo">2567</span>        while (d1 &gt;= 0) {<a name="line.2567"></a>
<span class="sourceLineNo">2568</span>            int d1next = nextDate(t1.getWeekCode(), t1.getDayCode(), d1);<a name="line.2568"></a>
<span class="sourceLineNo">2569</span>            int d2next = nextDate(t2.getWeekCode(), t2.getDayCode(), d2);<a name="line.2569"></a>
<span class="sourceLineNo">2570</span>            if (d1 &gt;= d2) return false; // next date of p2 is before or on d1 (or there is no next date)<a name="line.2570"></a>
<span class="sourceLineNo">2571</span>            // d1 &lt; d2 (d1 before d2)<a name="line.2571"></a>
<span class="sourceLineNo">2572</span>            if (d1next &gt;= 0 &amp;&amp; d2 &gt;= d1next) return false; // p1 has a next date, but p2 date is not before that date<a name="line.2572"></a>
<span class="sourceLineNo">2573</span>            // d1next &lt; 0 || d2 &lt; d1next (no next d1, or d2 before next d2<a name="line.2573"></a>
<span class="sourceLineNo">2574</span>            if (!btb &amp;&amp; d1 + 1 == d2) return false; // p2 is on a following day of p1<a name="line.2574"></a>
<span class="sourceLineNo">2575</span>            // btb || d1 + 1 &lt; d2 (back-to-back or at least one day gap in between)<a name="line.2575"></a>
<span class="sourceLineNo">2576</span>            if (btb &amp;&amp; following &amp;&amp; d1 + 1 != d2) return false; // d2 is not on the next date from d1<a name="line.2576"></a>
<span class="sourceLineNo">2577</span>            // !following || d1 + 1 == d2 (not following or on the next day)<a name="line.2577"></a>
<span class="sourceLineNo">2578</span>            d1 = d1next; d2 = d2next;<a name="line.2578"></a>
<span class="sourceLineNo">2579</span>        }<a name="line.2579"></a>
<span class="sourceLineNo">2580</span>        // d1 &lt; 0 (no next d1), check that there is also no d2<a name="line.2580"></a>
<span class="sourceLineNo">2581</span>        return (d2 &lt; 0); // both patterns have ended<a name="line.2581"></a>
<span class="sourceLineNo">2582</span>    }<a name="line.2582"></a>
<span class="sourceLineNo">2583</span>    <a name="line.2583"></a>
<span class="sourceLineNo">2584</span>    protected boolean isOnline(Placement p) {<a name="line.2584"></a>
<span class="sourceLineNo">2585</span>        // no room -- StudentConflict.OnlineRoom must allow for a blank string<a name="line.2585"></a>
<span class="sourceLineNo">2586</span>        if (p.getNrRooms() == 0)<a name="line.2586"></a>
<span class="sourceLineNo">2587</span>            return "".matches(iOnlineRoom);<a name="line.2587"></a>
<span class="sourceLineNo">2588</span>        // one room -- room name must match StudentConflict.OnlineRoom<a name="line.2588"></a>
<span class="sourceLineNo">2589</span>        if (p.getNrRooms() == 1)<a name="line.2589"></a>
<span class="sourceLineNo">2590</span>            return (p.getRoomLocation().getName() != null &amp;&amp; p.getRoomLocation().getName().matches(iOnlineRoom));<a name="line.2590"></a>
<span class="sourceLineNo">2591</span>        // multiple rooms -- all rooms must match StudentConflict.OnlineRoom<a name="line.2591"></a>
<span class="sourceLineNo">2592</span>        for (RoomLocation r: p.getRoomLocations())<a name="line.2592"></a>
<span class="sourceLineNo">2593</span>            if (r.getName() == null || !r.getName().matches(iOnlineRoom)) return false;<a name="line.2593"></a>
<span class="sourceLineNo">2594</span>        return true;<a name="line.2594"></a>
<span class="sourceLineNo">2595</span>    }<a name="line.2595"></a>
<span class="sourceLineNo">2596</span>}<a name="line.2596"></a>




























































</pre>
</div>
</body>
</html>
