<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>package org.cpsolver.ifs.algorithms;<a name="line.1"></a>
<span class="sourceLineNo">002</span><a name="line.2"></a>
<span class="sourceLineNo">003</span>import java.text.DecimalFormat;<a name="line.3"></a>
<span class="sourceLineNo">004</span><a name="line.4"></a>
<span class="sourceLineNo">005</span>import org.cpsolver.ifs.assignment.Assignment;<a name="line.5"></a>
<span class="sourceLineNo">006</span>import org.cpsolver.ifs.heuristics.NeighbourSelection;<a name="line.6"></a>
<span class="sourceLineNo">007</span>import org.cpsolver.ifs.model.Model;<a name="line.7"></a>
<span class="sourceLineNo">008</span>import org.cpsolver.ifs.model.Neighbour;<a name="line.8"></a>
<span class="sourceLineNo">009</span>import org.cpsolver.ifs.model.Value;<a name="line.9"></a>
<span class="sourceLineNo">010</span>import org.cpsolver.ifs.model.Variable;<a name="line.10"></a>
<span class="sourceLineNo">011</span>import org.cpsolver.ifs.solution.Solution;<a name="line.11"></a>
<span class="sourceLineNo">012</span>import org.cpsolver.ifs.util.DataProperties;<a name="line.12"></a>
<span class="sourceLineNo">013</span>import org.cpsolver.ifs.util.JProf;<a name="line.13"></a>
<span class="sourceLineNo">014</span>import org.cpsolver.ifs.util.ToolBox;<a name="line.14"></a>
<span class="sourceLineNo">015</span><a name="line.15"></a>
<span class="sourceLineNo">016</span><a name="line.16"></a>
<span class="sourceLineNo">017</span>/**<a name="line.17"></a>
<span class="sourceLineNo">018</span> * Simulated annealing. In each iteration, one of the given neighbourhoods is selected first,<a name="line.18"></a>
<span class="sourceLineNo">019</span> * then a neighbour is generated and it is accepted with probability<a name="line.19"></a>
<span class="sourceLineNo">020</span> * {@link SimulatedAnnealingContext#prob(double)}. The search is guided by the<a name="line.20"></a>
<span class="sourceLineNo">021</span> * temperature, which starts at &lt;i&gt;SimulatedAnnealing.InitialTemperature&lt;/i&gt;.<a name="line.21"></a>
<span class="sourceLineNo">022</span> * After each &lt;i&gt;SimulatedAnnealing.TemperatureLength&lt;/i&gt; iterations, the<a name="line.22"></a>
<span class="sourceLineNo">023</span> * temperature is reduced by &lt;i&gt;SimulatedAnnealing.CoolingRate&lt;/i&gt;. If there was<a name="line.23"></a>
<span class="sourceLineNo">024</span> * no improvement in the past &lt;i&gt;SimulatedAnnealing.ReheatLengthCoef *<a name="line.24"></a>
<span class="sourceLineNo">025</span> * SimulatedAnnealing.TemperatureLength&lt;/i&gt; iterations, the temperature is<a name="line.25"></a>
<span class="sourceLineNo">026</span> * increased by &lt;i&gt;SimulatedAnnealing.ReheatRate&lt;/i&gt;. If there was no<a name="line.26"></a>
<span class="sourceLineNo">027</span> * improvement in the past &lt;i&gt;SimulatedAnnealing.RestoreBestLengthCoef *<a name="line.27"></a>
<span class="sourceLineNo">028</span> * SimulatedAnnealing.TemperatureLength&lt;/i&gt; iterations, the best ever found<a name="line.28"></a>
<span class="sourceLineNo">029</span> * solution is restored. &lt;br&gt;<a name="line.29"></a>
<span class="sourceLineNo">030</span> * &lt;br&gt;<a name="line.30"></a>
<span class="sourceLineNo">031</span> * If &lt;i&gt;SimulatedAnnealing.StochasticHC&lt;/i&gt; is true, the acceptance probability<a name="line.31"></a>
<span class="sourceLineNo">032</span> * is computed using stochastic hill climbing criterion, i.e.,<a name="line.32"></a>
<span class="sourceLineNo">033</span> * &lt;code&gt;1.0 / (1.0 + Math.exp(value/temperature))&lt;/code&gt;, otherwise it is<a name="line.33"></a>
<span class="sourceLineNo">034</span> * cumputed using simlated annealing criterion, i.e.,<a name="line.34"></a>
<span class="sourceLineNo">035</span> * &lt;code&gt;(value&amp;lt;=0.0?1.0:Math.exp(-value/temperature))&lt;/code&gt;. If<a name="line.35"></a>
<span class="sourceLineNo">036</span> * &lt;i&gt;SimulatedAnnealing.RelativeAcceptance&lt;/i&gt; neighbour value<a name="line.36"></a>
<span class="sourceLineNo">037</span> * {@link Neighbour#value(Assignment)} is taken as the value of the selected<a name="line.37"></a>
<span class="sourceLineNo">038</span> * neighbour (difference between the new and the current solution, if the<a name="line.38"></a>
<span class="sourceLineNo">039</span> * neighbour is accepted), otherwise the value is computed as the difference<a name="line.39"></a>
<span class="sourceLineNo">040</span> * between the value of the current solution if the neighbour is accepted and<a name="line.40"></a>
<span class="sourceLineNo">041</span> * the best ever found solution. &lt;br&gt;<a name="line.41"></a>
<span class="sourceLineNo">042</span> * &lt;br&gt;<a name="line.42"></a>
<span class="sourceLineNo">043</span> * Custom neighbours can be set using SimulatedAnnealing.Neighbours property that should<a name="line.43"></a>
<span class="sourceLineNo">044</span> * contain semicolon separated list of {@link NeighbourSelection}. By default, <a name="line.44"></a>
<span class="sourceLineNo">045</span> * each neighbour selection is selected with the same probability (each has 1 point in<a name="line.45"></a>
<span class="sourceLineNo">046</span> * a roulette wheel selection). It can be changed by adding &amp;nbsp;@n at the end<a name="line.46"></a>
<span class="sourceLineNo">047</span> * of the name of the class, for example:<a name="line.47"></a>
<span class="sourceLineNo">048</span> * &lt;pre&gt;&lt;code&gt;<a name="line.48"></a>
<span class="sourceLineNo">049</span> * SimulatedAnnealing.Neighbours=org.cpsolver.ifs.algorithms.neighbourhoods.RandomMove;org.cpsolver.ifs.algorithms.neighbourhoods.RandomSwapMove@0.1<a name="line.49"></a>
<span class="sourceLineNo">050</span> * &lt;/code&gt;&lt;/pre&gt;<a name="line.50"></a>
<span class="sourceLineNo">051</span> * Selector RandomSwapMove is 10&amp;times; less probable to be selected than other selectors.<a name="line.51"></a>
<span class="sourceLineNo">052</span> * When SimulatedAnnealing.Random is true, all selectors are selected with the same probability, ignoring these weights.<a name="line.52"></a>
<span class="sourceLineNo">053</span> * &lt;br&gt;&lt;br&gt;<a name="line.53"></a>
<span class="sourceLineNo">054</span> * When SimulatedAnnealing.Update is true, {@link NeighbourSelector#update(Assignment, Neighbour, long)} is called <a name="line.54"></a>
<span class="sourceLineNo">055</span> * after each iteration (on the selector that was used) and roulette wheel selection <a name="line.55"></a>
<span class="sourceLineNo">056</span> * that is using {@link NeighbourSelector#getPoints()} is used to pick a selector in each iteration. <a name="line.56"></a>
<span class="sourceLineNo">057</span> * See {@link NeighbourSelector} for more details. <a name="line.57"></a>
<span class="sourceLineNo">058</span> * &lt;br&gt;<a name="line.58"></a>
<span class="sourceLineNo">059</span> * <a name="line.59"></a>
<span class="sourceLineNo">060</span> * @author  Tom&#225;&#353; M&#252;ller<a name="line.60"></a>
<span class="sourceLineNo">061</span> * @version IFS 1.3 (Iterative Forward Search)&lt;br&gt;<a name="line.61"></a>
<span class="sourceLineNo">062</span> *          Copyright (C) 2014 Tom&#225;&#353; M&#252;ller&lt;br&gt;<a name="line.62"></a>
<span class="sourceLineNo">063</span> *          &lt;a href="mailto:muller@unitime.org"&gt;muller@unitime.org&lt;/a&gt;&lt;br&gt;<a name="line.63"></a>
<span class="sourceLineNo">064</span> *          &lt;a href="http://muller.unitime.org"&gt;http://muller.unitime.org&lt;/a&gt;&lt;br&gt;<a name="line.64"></a>
<span class="sourceLineNo">065</span> * &lt;br&gt;<a name="line.65"></a>
<span class="sourceLineNo">066</span> *          This library is free software; you can redistribute it and/or modify<a name="line.66"></a>
<span class="sourceLineNo">067</span> *          it under the terms of the GNU Lesser General Public License as<a name="line.67"></a>
<span class="sourceLineNo">068</span> *          published by the Free Software Foundation; either version 3 of the<a name="line.68"></a>
<span class="sourceLineNo">069</span> *          License, or (at your option) any later version. &lt;br&gt;<a name="line.69"></a>
<span class="sourceLineNo">070</span> * &lt;br&gt;<a name="line.70"></a>
<span class="sourceLineNo">071</span> *          This library is distributed in the hope that it will be useful, but<a name="line.71"></a>
<span class="sourceLineNo">072</span> *          WITHOUT ANY WARRANTY; without even the implied warranty of<a name="line.72"></a>
<span class="sourceLineNo">073</span> *          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU<a name="line.73"></a>
<span class="sourceLineNo">074</span> *          Lesser General Public License for more details. &lt;br&gt;<a name="line.74"></a>
<span class="sourceLineNo">075</span> * &lt;br&gt;<a name="line.75"></a>
<span class="sourceLineNo">076</span> *          You should have received a copy of the GNU Lesser General Public<a name="line.76"></a>
<span class="sourceLineNo">077</span> *          License along with this library; if not see<a name="line.77"></a>
<span class="sourceLineNo">078</span> *          &lt;a href='http://www.gnu.org/licenses/'&gt;http://www.gnu.org/licenses/&lt;/a&gt;.<a name="line.78"></a>
<span class="sourceLineNo">079</span> * @param &lt;V&gt; Variable<a name="line.79"></a>
<span class="sourceLineNo">080</span> * @param &lt;T&gt; Value<a name="line.80"></a>
<span class="sourceLineNo">081</span> */<a name="line.81"></a>
<span class="sourceLineNo">082</span>public class SimulatedAnnealing&lt;V extends Variable&lt;V, T&gt;, T extends Value&lt;V, T&gt;&gt; extends NeighbourSearch&lt;V,T&gt; {<a name="line.82"></a>
<span class="sourceLineNo">083</span>    private DecimalFormat iDF5 = new DecimalFormat("0.00000");<a name="line.83"></a>
<span class="sourceLineNo">084</span>    private DecimalFormat iDF10 = new DecimalFormat("0.0000000000");<a name="line.84"></a>
<span class="sourceLineNo">085</span>    private double iInitialTemperature = -1;<a name="line.85"></a>
<span class="sourceLineNo">086</span>    private double iMaximalTemperature = 1.5;<a name="line.86"></a>
<span class="sourceLineNo">087</span>    private double iMinimalTemperature = 0.001;<a name="line.87"></a>
<span class="sourceLineNo">088</span>    private double iCoolingRate = 0.95;<a name="line.88"></a>
<span class="sourceLineNo">089</span>    private double iReheatRate = -1;<a name="line.89"></a>
<span class="sourceLineNo">090</span>    private long iTemperatureLength = 25000;<a name="line.90"></a>
<span class="sourceLineNo">091</span>    private double iReheatLengthCoef = 5.0;<a name="line.91"></a>
<span class="sourceLineNo">092</span>    private double iRestoreBestLengthCoef = -1;<a name="line.92"></a>
<span class="sourceLineNo">093</span>    private boolean iStochasticHC = false;<a name="line.93"></a>
<span class="sourceLineNo">094</span>    private boolean iRelativeAcceptance = true;<a name="line.94"></a>
<span class="sourceLineNo">095</span>    private Double[] iCoolingRateAdjusts = null;<a name="line.95"></a>
<span class="sourceLineNo">096</span>    private int iTrainingValues = 10000;<a name="line.96"></a>
<span class="sourceLineNo">097</span>    private double iTrainingProbability = 0.00001;<a name="line.97"></a>
<span class="sourceLineNo">098</span>    private double iTimeBetweenCooldowns = 10.0;<a name="line.98"></a>
<span class="sourceLineNo">099</span><a name="line.99"></a>
<span class="sourceLineNo">100</span>    /**<a name="line.100"></a>
<span class="sourceLineNo">101</span>     * Constructor. Following problem properties are considered:<a name="line.101"></a>
<span class="sourceLineNo">102</span>     * &lt;ul&gt;<a name="line.102"></a>
<span class="sourceLineNo">103</span>     * &lt;li&gt;SimulatedAnnealing.InitialTemperature ... initial temperature (default 1.5)<a name="line.103"></a>
<span class="sourceLineNo">104</span>     * &lt;li&gt;SimulatedAnnealing.TemperatureLength ... temperature length (number of iterations between temperature decrements, default 25000)<a name="line.104"></a>
<span class="sourceLineNo">105</span>     * &lt;li&gt;SimulatedAnnealing.CoolingRate ... temperature cooling rate (default 0.95)<a name="line.105"></a>
<span class="sourceLineNo">106</span>     * &lt;li&gt;SimulatedAnnealing.ReheatLengthCoef ... temperature re-heat length coefficient (multiple of temperature length, default 5)<a name="line.106"></a>
<span class="sourceLineNo">107</span>     * &lt;li&gt;SimulatedAnnealing.ReheatRate ... temperature re-heating rate (default (1/coolingRate)^(reheatLengthCoef*1.7))<a name="line.107"></a>
<span class="sourceLineNo">108</span>     * &lt;li&gt;SimulatedAnnealing.RestoreBestLengthCoef ... restore best length coefficient (multiple of re-heat length, default reheatLengthCoef^2)<a name="line.108"></a>
<span class="sourceLineNo">109</span>     * &lt;li&gt;SimulatedAnnealing.StochasticHC ... true for stochastic search acceptance criterion, false for simulated annealing acceptance (default false)<a name="line.109"></a>
<span class="sourceLineNo">110</span>     * &lt;li&gt;SimulatedAnnealing.RelativeAcceptance ... true for relative acceptance (different between the new and the current solutions, if the neighbour is accepted), false for absolute acceptance (difference between the new and the best solutions, if the neighbour is accepted)<a name="line.110"></a>
<span class="sourceLineNo">111</span>     * &lt;li&gt;SimulatedAnnealing.Neighbours ... semicolon separated list of classes implementing {@link NeighbourSelection}<a name="line.111"></a>
<span class="sourceLineNo">112</span>     * &lt;li&gt;SimulatedAnnealing.AdditionalNeighbours ... semicolon separated list of classes implementing {@link NeighbourSelection}<a name="line.112"></a>
<span class="sourceLineNo">113</span>     * &lt;li&gt;SimulatedAnnealing.Random ... when true, a neighbour selector is selected randomly<a name="line.113"></a>
<span class="sourceLineNo">114</span>     * &lt;li&gt;SimulatedAnnealing.Update ... when true, a neighbour selector is selected using {@link NeighbourSelector#getPoints()} weights (roulette wheel selection)<a name="line.114"></a>
<span class="sourceLineNo">115</span>     * &lt;/ul&gt;<a name="line.115"></a>
<span class="sourceLineNo">116</span>     * <a name="line.116"></a>
<span class="sourceLineNo">117</span>     * @param properties<a name="line.117"></a>
<span class="sourceLineNo">118</span>     *            problem properties<a name="line.118"></a>
<span class="sourceLineNo">119</span>     */<a name="line.119"></a>
<span class="sourceLineNo">120</span>    public SimulatedAnnealing(DataProperties properties) {<a name="line.120"></a>
<span class="sourceLineNo">121</span>        super(properties);<a name="line.121"></a>
<span class="sourceLineNo">122</span>        iInitialTemperature = properties.getPropertyDouble(getParameterBaseName() + ".InitialTemperature", iInitialTemperature);<a name="line.122"></a>
<span class="sourceLineNo">123</span>        iMaximalTemperature = properties.getPropertyDouble(getParameterBaseName() + ".MaximalTemperature", (iInitialTemperature &lt;= 0.0 ? -1.0 : iMaximalTemperature));<a name="line.123"></a>
<span class="sourceLineNo">124</span>        iMinimalTemperature = properties.getPropertyDouble(getParameterBaseName() + ".MinimalTemperature", (iInitialTemperature &lt;= 0.0 ? -1.0 : 0.0));<a name="line.124"></a>
<span class="sourceLineNo">125</span>        iReheatRate = properties.getPropertyDouble(getParameterBaseName() + ".ReheatRate", iReheatRate);<a name="line.125"></a>
<span class="sourceLineNo">126</span>        iCoolingRate = properties.getPropertyDouble(getParameterBaseName() + ".CoolingRate", iCoolingRate);<a name="line.126"></a>
<span class="sourceLineNo">127</span>        iRelativeAcceptance = properties.getPropertyBoolean(getParameterBaseName() + ".RelativeAcceptance", iRelativeAcceptance);<a name="line.127"></a>
<span class="sourceLineNo">128</span>        iStochasticHC = properties.getPropertyBoolean(getParameterBaseName() + ".StochasticHC", iStochasticHC);<a name="line.128"></a>
<span class="sourceLineNo">129</span>        iTemperatureLength = properties.getPropertyLong(getParameterBaseName() + ".TemperatureLength", iTemperatureLength);<a name="line.129"></a>
<span class="sourceLineNo">130</span>        iReheatLengthCoef = properties.getPropertyDouble(getParameterBaseName() + ".ReheatLengthCoef", iReheatLengthCoef);<a name="line.130"></a>
<span class="sourceLineNo">131</span>        iRestoreBestLengthCoef = properties.getPropertyDouble(getParameterBaseName() + ".RestoreBestLengthCoef", iRestoreBestLengthCoef);<a name="line.131"></a>
<span class="sourceLineNo">132</span>        iCoolingRateAdjusts = properties.getPropertyDoubleArry(getParameterBaseName() + ".CoolingRateAdjustments", null);<a name="line.132"></a>
<span class="sourceLineNo">133</span>        iTrainingValues = properties.getPropertyInt(getParameterBaseName() + ".TrainingValues", iTrainingValues);<a name="line.133"></a>
<span class="sourceLineNo">134</span>        iTrainingProbability = properties.getPropertyDouble(getParameterBaseName() + ".TrainingProbability", iTrainingProbability);<a name="line.134"></a>
<span class="sourceLineNo">135</span>        iTimeBetweenCooldowns = properties.getPropertyDouble(getParameterBaseName() + ".TimeBetweenCooldowns", iTimeBetweenCooldowns);<a name="line.135"></a>
<span class="sourceLineNo">136</span>        if (iReheatRate &lt; 0)<a name="line.136"></a>
<span class="sourceLineNo">137</span>            iReheatRate = Math.pow(1 / iCoolingRate, iReheatLengthCoef * 1.7);<a name="line.137"></a>
<span class="sourceLineNo">138</span>        if (iRestoreBestLengthCoef &lt; 0)<a name="line.138"></a>
<span class="sourceLineNo">139</span>            iRestoreBestLengthCoef = iReheatLengthCoef * iReheatLengthCoef;<a name="line.139"></a>
<span class="sourceLineNo">140</span>    }<a name="line.140"></a>
<span class="sourceLineNo">141</span>    <a name="line.141"></a>
<span class="sourceLineNo">142</span>    @Override<a name="line.142"></a>
<span class="sourceLineNo">143</span>    public String getParameterBaseName() { return "SimulatedAnnealing"; }<a name="line.143"></a>
<span class="sourceLineNo">144</span>    <a name="line.144"></a>
<span class="sourceLineNo">145</span>    @Override<a name="line.145"></a>
<span class="sourceLineNo">146</span>    public NeighbourSearchContext createAssignmentContext(Assignment&lt;V, T&gt; assignment) {<a name="line.146"></a>
<span class="sourceLineNo">147</span>        return new SimulatedAnnealingContext();<a name="line.147"></a>
<span class="sourceLineNo">148</span>    }<a name="line.148"></a>
<span class="sourceLineNo">149</span>    <a name="line.149"></a>
<span class="sourceLineNo">150</span>    public class SimulatedAnnealingContext extends NeighbourSearchContext {<a name="line.150"></a>
<span class="sourceLineNo">151</span>        private double iTemperature = 0.0;<a name="line.151"></a>
<span class="sourceLineNo">152</span>        private int iMoves = 0;<a name="line.152"></a>
<span class="sourceLineNo">153</span>        private double iAbsValue = 0;<a name="line.153"></a>
<span class="sourceLineNo">154</span>        private double iBestValue = 0;<a name="line.154"></a>
<span class="sourceLineNo">155</span>        private long iLastImprovingIter = -1;<a name="line.155"></a>
<span class="sourceLineNo">156</span>        private long iLastBestIter = -1;<a name="line.156"></a>
<span class="sourceLineNo">157</span>        private long iLastReheatIter = 0;<a name="line.157"></a>
<span class="sourceLineNo">158</span>        private long iLastCoolingIter = 0;<a name="line.158"></a>
<span class="sourceLineNo">159</span>        private int iAcceptIter[] = new int[] { 0, 0, 0 };<a name="line.159"></a>
<span class="sourceLineNo">160</span>        private long iReheatLength = 0;<a name="line.160"></a>
<span class="sourceLineNo">161</span>        private long iRestoreBestLength = 0;<a name="line.161"></a>
<span class="sourceLineNo">162</span>        private int iTrainingIterations = 0;<a name="line.162"></a>
<span class="sourceLineNo">163</span>        private double iTrainingTotal = 0.0;<a name="line.163"></a>
<span class="sourceLineNo">164</span><a name="line.164"></a>
<span class="sourceLineNo">165</span>        /** Setup the temperature */<a name="line.165"></a>
<span class="sourceLineNo">166</span>        @Override<a name="line.166"></a>
<span class="sourceLineNo">167</span>        protected void activate(Solution&lt;V, T&gt; solution) {<a name="line.167"></a>
<span class="sourceLineNo">168</span>            super.activate(solution);<a name="line.168"></a>
<span class="sourceLineNo">169</span>            iTrainingTotal = 0.0; iTrainingIterations = 0;<a name="line.169"></a>
<span class="sourceLineNo">170</span>            iTemperature = iInitialTemperature;<a name="line.170"></a>
<span class="sourceLineNo">171</span>            iReheatLength = Math.round(iReheatLengthCoef * iTemperatureLength);<a name="line.171"></a>
<span class="sourceLineNo">172</span>            iRestoreBestLength = Math.round(iRestoreBestLengthCoef * iTemperatureLength);<a name="line.172"></a>
<span class="sourceLineNo">173</span>            iLastImprovingIter = -1;<a name="line.173"></a>
<span class="sourceLineNo">174</span>            iLastBestIter = -1;<a name="line.174"></a>
<span class="sourceLineNo">175</span>        }<a name="line.175"></a>
<span class="sourceLineNo">176</span>        <a name="line.176"></a>
<span class="sourceLineNo">177</span>        protected double getCoolingRate(int idx) {<a name="line.177"></a>
<span class="sourceLineNo">178</span>            if (idx &lt; 0 || iCoolingRateAdjusts == null || idx &gt;= iCoolingRateAdjusts.length || iCoolingRateAdjusts[idx] == null) return iCoolingRate;<a name="line.178"></a>
<span class="sourceLineNo">179</span>            return iCoolingRate * iCoolingRateAdjusts[idx];<a name="line.179"></a>
<span class="sourceLineNo">180</span>        }<a name="line.180"></a>
<span class="sourceLineNo">181</span>        <a name="line.181"></a>
<span class="sourceLineNo">182</span>        /**<a name="line.182"></a>
<span class="sourceLineNo">183</span>         * Set initial temperature based on the training period<a name="line.183"></a>
<span class="sourceLineNo">184</span>         * @param solution current solution<a name="line.184"></a>
<span class="sourceLineNo">185</span>         */<a name="line.185"></a>
<span class="sourceLineNo">186</span>        protected void train(Solution&lt;V, T&gt; solution) {<a name="line.186"></a>
<span class="sourceLineNo">187</span>            double value = iTrainingTotal / iTrainingIterations;<a name="line.187"></a>
<span class="sourceLineNo">188</span>            if (iStochasticHC) {<a name="line.188"></a>
<span class="sourceLineNo">189</span>                iInitialTemperature = value / Math.log(1.0 / 0.01 * iTrainingProbability - 1.0);<a name="line.189"></a>
<span class="sourceLineNo">190</span>                if (iMaximalTemperature &lt;= 0.0)<a name="line.190"></a>
<span class="sourceLineNo">191</span>                    iMaximalTemperature = value / Math.log(1.0 / iTrainingProbability - 1.0);<a name="line.191"></a>
<span class="sourceLineNo">192</span>                if (iMinimalTemperature &lt; 0.0)<a name="line.192"></a>
<span class="sourceLineNo">193</span>                    iMinimalTemperature = 0.1 / Math.log(1.0 / iTrainingProbability - 1.0);<a name="line.193"></a>
<span class="sourceLineNo">194</span>            } else {<a name="line.194"></a>
<span class="sourceLineNo">195</span>                iInitialTemperature = - value / Math.log(0.01 * iTrainingProbability);<a name="line.195"></a>
<span class="sourceLineNo">196</span>                if (iMaximalTemperature &lt;= 0.0)<a name="line.196"></a>
<span class="sourceLineNo">197</span>                    iMaximalTemperature = - value / Math.log(iTrainingProbability);<a name="line.197"></a>
<span class="sourceLineNo">198</span>                if (iMinimalTemperature &lt; 0.0)<a name="line.198"></a>
<span class="sourceLineNo">199</span>                    iMinimalTemperature = - 0.1 / Math.log(iTrainingProbability);<a name="line.199"></a>
<span class="sourceLineNo">200</span>            }<a name="line.200"></a>
<span class="sourceLineNo">201</span>            iTemperature = iInitialTemperature;<a name="line.201"></a>
<span class="sourceLineNo">202</span>            info("Iter=" + iIter / 1000 + (iLastImprovingIter &lt; 0 ? "" : "k, NonImpIter=" + iDF2.format((iIter - iLastImprovingIter) / 1000.0))<a name="line.202"></a>
<span class="sourceLineNo">203</span>                    + "k, Speed=" + iDF2.format(1000.0 * iIter / (JProf.currentTimeMillis() - iT0)) + " it/s, " +<a name="line.203"></a>
<span class="sourceLineNo">204</span>                    "Value=" + iDF2.format(solution.getModel().getTotalValue(solution.getAssignment())) +<a name="line.204"></a>
<span class="sourceLineNo">205</span>                    ", Best=" + iDF2.format(solution.getBestValue()) +<a name="line.205"></a>
<span class="sourceLineNo">206</span>                    " (" + iDF2.format(100.0 * solution.getModel().getTotalValue(solution.getAssignment()) / solution.getBestValue()) + " %)");<a name="line.206"></a>
<span class="sourceLineNo">207</span>            info("Temperature set to " + iDF5.format(iTemperature) + " " + "(" + <a name="line.207"></a>
<span class="sourceLineNo">208</span>                    "p(+0.1)=" + iDF2.format(100.0 * prob(0.1)) + "%, " +<a name="line.208"></a>
<span class="sourceLineNo">209</span>                    "p(+1)=" + iDF2.format(100.0 * prob(1)) + "%, " +<a name="line.209"></a>
<span class="sourceLineNo">210</span>                    "p(+10)=" + iDF5.format(100.0 * prob(10)) + "%, " +<a name="line.210"></a>
<span class="sourceLineNo">211</span>                    "p(+" + iDF2.format(value) + ")=" + iDF5.format(100.0 * prob(value)) + "%)");<a name="line.211"></a>
<span class="sourceLineNo">212</span>            info("Maximal temperature set to " + iDF5.format(iMaximalTemperature) + " " + "(" + <a name="line.212"></a>
<span class="sourceLineNo">213</span>                    "p(+0.1)=" + iDF2.format(100.0 * prob(0.1, iMaximalTemperature)) + "%, " +<a name="line.213"></a>
<span class="sourceLineNo">214</span>                    "p(+1)=" + iDF2.format(100.0 * prob(1, iMaximalTemperature)) + "%, " +<a name="line.214"></a>
<span class="sourceLineNo">215</span>                    "p(+10)=" + iDF5.format(100.0 * prob(10, iMaximalTemperature)) + "%, " +<a name="line.215"></a>
<span class="sourceLineNo">216</span>                    "p(+" + iDF2.format(value) + ")=" + iDF5.format(100.0 * prob(value, iMaximalTemperature)) + "%)");<a name="line.216"></a>
<span class="sourceLineNo">217</span>            info("Minimal temperature set to " + iDF5.format(iMinimalTemperature) + " " + "(" + <a name="line.217"></a>
<span class="sourceLineNo">218</span>                    "p(+0.001)=" + iDF2.format(100.0 * prob(0.001, iMinimalTemperature)) + "%, " +<a name="line.218"></a>
<span class="sourceLineNo">219</span>                    "p(+0.01)=" + iDF2.format(100.0 * prob(0.01, iMinimalTemperature)) + "%, " +<a name="line.219"></a>
<span class="sourceLineNo">220</span>                    "p(+0.1)=" + iDF5.format(100.0 * prob(0.1, iMinimalTemperature)) + "%)");<a name="line.220"></a>
<span class="sourceLineNo">221</span>            logNeibourStatus();<a name="line.221"></a>
<span class="sourceLineNo">222</span>            double speed = ((double)iIter) / (JProf.currentTimeMillis() - iT0); // iterations per ms<a name="line.222"></a>
<span class="sourceLineNo">223</span>            iTemperatureLength = Math.round(speed * iTimeBetweenCooldowns * 1000.0);<a name="line.223"></a>
<span class="sourceLineNo">224</span>            iReheatLength = Math.round(iReheatLengthCoef * iTemperatureLength);<a name="line.224"></a>
<span class="sourceLineNo">225</span>            iRestoreBestLength = Math.round(iRestoreBestLengthCoef * iTemperatureLength);<a name="line.225"></a>
<span class="sourceLineNo">226</span>            info("Training speed was " + iDF2.format(1000.0 * speed) + " it/s, temperature length adjusted to " + iTemperatureLength + ".");<a name="line.226"></a>
<span class="sourceLineNo">227</span>            iIter = 0; iT0 = JProf.currentTimeMillis();<a name="line.227"></a>
<span class="sourceLineNo">228</span>            iLastImprovingIter = -1; iLastBestIter = 0; iBestValue = solution.getBestValue();<a name="line.228"></a>
<span class="sourceLineNo">229</span>            iAcceptIter = new int[] { 0, 0, 0 };<a name="line.229"></a>
<span class="sourceLineNo">230</span>            iMoves = 0;<a name="line.230"></a>
<span class="sourceLineNo">231</span>            iAbsValue = 0;<a name="line.231"></a>
<span class="sourceLineNo">232</span>        }<a name="line.232"></a>
<span class="sourceLineNo">233</span><a name="line.233"></a>
<span class="sourceLineNo">234</span>        /**<a name="line.234"></a>
<span class="sourceLineNo">235</span>         * Cool temperature<a name="line.235"></a>
<span class="sourceLineNo">236</span>         * @param solution current solution<a name="line.236"></a>
<span class="sourceLineNo">237</span>         */<a name="line.237"></a>
<span class="sourceLineNo">238</span>        protected void cool(Solution&lt;V, T&gt; solution) {<a name="line.238"></a>
<span class="sourceLineNo">239</span>            info("Iter=" + iIter / 1000 + (iLastImprovingIter &lt; 0 ? "" : "k, NonImpIter=" + iDF2.format((iIter - iLastImprovingIter) / 1000.0))<a name="line.239"></a>
<span class="sourceLineNo">240</span>                    + "k, Speed=" + iDF2.format(1000.0 * iIter / (JProf.currentTimeMillis() - iT0)) + " it/s, " +<a name="line.240"></a>
<span class="sourceLineNo">241</span>                    "Value=" + iDF2.format(solution.getModel().getTotalValue(solution.getAssignment())) +<a name="line.241"></a>
<span class="sourceLineNo">242</span>                    ", Best=" + iDF2.format(solution.getBestValue()) +<a name="line.242"></a>
<span class="sourceLineNo">243</span>                    " (" + iDF2.format(100.0 * solution.getModel().getTotalValue(solution.getAssignment()) / solution.getBestValue()) + " %), " +<a name="line.243"></a>
<span class="sourceLineNo">244</span>                    "Step=" + iDF2.format(1.0 * (iIter - Math.max(iLastReheatIter, iLastImprovingIter)) / iTemperatureLength));<a name="line.244"></a>
<span class="sourceLineNo">245</span>            if (iLastImprovingIter &lt; 0 || iIter &gt; iLastImprovingIter + iTemperatureLength) {<a name="line.245"></a>
<span class="sourceLineNo">246</span>                // Do not update the temperature when solution was improved recently <a name="line.246"></a>
<span class="sourceLineNo">247</span>                iTemperature *= getCoolingRate(solution.getAssignment().getIndex() - 1);<a name="line.247"></a>
<span class="sourceLineNo">248</span>                info("Temperature decreased to " + iDF5.format(iTemperature) + " " + "(#moves=" + iMoves + ", rms(value)="<a name="line.248"></a>
<span class="sourceLineNo">249</span>                        + iDF2.format(Math.sqrt(iAbsValue / iMoves)) + ", " + "accept=-"<a name="line.249"></a>
<span class="sourceLineNo">250</span>                        + iDF2.format(100.0 * iAcceptIter[0] / iMoves) + "/"<a name="line.250"></a>
<span class="sourceLineNo">251</span>                        + iDF2.format(100.0 * iAcceptIter[1] / iMoves) + "/+"<a name="line.251"></a>
<span class="sourceLineNo">252</span>                        + iDF2.format(100.0 * iAcceptIter[2] / iMoves) + "%, "<a name="line.252"></a>
<span class="sourceLineNo">253</span>                        + (prob(-1) &lt; 1.0 ? "p(-1)=" + iDF2.format(100.0 * prob(-1)) + "%, " : "") + <a name="line.253"></a>
<span class="sourceLineNo">254</span>                        "p(+0.1)=" + iDF2.format(100.0 * prob(0.1)) + "%, " +<a name="line.254"></a>
<span class="sourceLineNo">255</span>                        "p(+1)=" + iDF5.format(100.0 * prob(1)) + "%, " +<a name="line.255"></a>
<span class="sourceLineNo">256</span>                        "p(+10)=" + iDF10.format(100.0 * prob(10)) + "%)");<a name="line.256"></a>
<span class="sourceLineNo">257</span>                iAbsValue = 0;<a name="line.257"></a>
<span class="sourceLineNo">258</span>                iAcceptIter = new int[] { 0, 0, 0 };<a name="line.258"></a>
<span class="sourceLineNo">259</span>                iMoves = 0;<a name="line.259"></a>
<span class="sourceLineNo">260</span>            }<a name="line.260"></a>
<span class="sourceLineNo">261</span>            logNeibourStatus();<a name="line.261"></a>
<span class="sourceLineNo">262</span>            iLastCoolingIter = iIter;<a name="line.262"></a>
<span class="sourceLineNo">263</span>        }<a name="line.263"></a>
<span class="sourceLineNo">264</span><a name="line.264"></a>
<span class="sourceLineNo">265</span>        /**<a name="line.265"></a>
<span class="sourceLineNo">266</span>         * Reheat temperature<a name="line.266"></a>
<span class="sourceLineNo">267</span>         * @param solution current solution<a name="line.267"></a>
<span class="sourceLineNo">268</span>         */<a name="line.268"></a>
<span class="sourceLineNo">269</span>        protected void reheat(Solution&lt;V, T&gt; solution) {<a name="line.269"></a>
<span class="sourceLineNo">270</span>            iTemperature *= iReheatRate;<a name="line.270"></a>
<span class="sourceLineNo">271</span>            info("Iter=" + iIter / 1000 + (iLastImprovingIter &lt; 0 ? "" : "k, NonImpIter=" + iDF2.format((iIter - iLastImprovingIter) / 1000.0))<a name="line.271"></a>
<span class="sourceLineNo">272</span>                    + "k, Speed=" + iDF2.format(1000.0 * iIter / (JProf.currentTimeMillis() - iT0)) + " it/s, " +<a name="line.272"></a>
<span class="sourceLineNo">273</span>                    "Value=" + iDF2.format(solution.getModel().getTotalValue(solution.getAssignment())) +<a name="line.273"></a>
<span class="sourceLineNo">274</span>                    ", Best=" + iDF2.format(solution.getBestValue()) +<a name="line.274"></a>
<span class="sourceLineNo">275</span>                    " (" + iDF2.format(100.0 * solution.getModel().getTotalValue(solution.getAssignment()) / solution.getBestValue()) + " %)");<a name="line.275"></a>
<span class="sourceLineNo">276</span>            info("Temperature increased to " + iDF5.format(iTemperature) + " "<a name="line.276"></a>
<span class="sourceLineNo">277</span>                    + (prob(-1) &lt; 1.0 ? "p(-1)=" + iDF2.format(100.0 * prob(-1)) + "%, " : "") + "p(+0.1)="<a name="line.277"></a>
<span class="sourceLineNo">278</span>                    + iDF2.format(100.0 * prob(0.1)) + "%, " + "p(+1)=" + iDF5.format(10.0 * prob(1)) + "%, " + "p(+10)="<a name="line.278"></a>
<span class="sourceLineNo">279</span>                    + iDF10.format(100.0 * prob(10)) + "%)");<a name="line.279"></a>
<span class="sourceLineNo">280</span>            logNeibourStatus();<a name="line.280"></a>
<span class="sourceLineNo">281</span>            iLastReheatIter = iIter;<a name="line.281"></a>
<span class="sourceLineNo">282</span>            if (iTemperature &gt; iMaximalTemperature) {<a name="line.282"></a>
<span class="sourceLineNo">283</span>                // Max temperature reached -&gt; restore best solution and stop re-heating<a name="line.283"></a>
<span class="sourceLineNo">284</span>                restoreBest(solution);<a name="line.284"></a>
<span class="sourceLineNo">285</span>                iLastImprovingIter = -1;<a name="line.285"></a>
<span class="sourceLineNo">286</span>            }<a name="line.286"></a>
<span class="sourceLineNo">287</span>            iBestValue = solution.getBestValue();<a name="line.287"></a>
<span class="sourceLineNo">288</span>            setProgressPhase("Simulated Annealing [" + iDF5.format(iTemperature) + "]...");<a name="line.288"></a>
<span class="sourceLineNo">289</span>        }<a name="line.289"></a>
<span class="sourceLineNo">290</span><a name="line.290"></a>
<span class="sourceLineNo">291</span>        /**<a name="line.291"></a>
<span class="sourceLineNo">292</span>         * restore best ever found solution<a name="line.292"></a>
<span class="sourceLineNo">293</span>         * @param solution current solution<a name="line.293"></a>
<span class="sourceLineNo">294</span>         */<a name="line.294"></a>
<span class="sourceLineNo">295</span>        protected void restoreBest(Solution&lt;V, T&gt; solution) {<a name="line.295"></a>
<span class="sourceLineNo">296</span>            info("Best solution restored.");<a name="line.296"></a>
<span class="sourceLineNo">297</span>            solution.restoreBest();<a name="line.297"></a>
<span class="sourceLineNo">298</span>            iLastBestIter = iIter;<a name="line.298"></a>
<span class="sourceLineNo">299</span>        }<a name="line.299"></a>
<span class="sourceLineNo">300</span><a name="line.300"></a>
<span class="sourceLineNo">301</span>        /**<a name="line.301"></a>
<span class="sourceLineNo">302</span>         * Neighbour acceptance probability<a name="line.302"></a>
<span class="sourceLineNo">303</span>         * <a name="line.303"></a>
<span class="sourceLineNo">304</span>         * @param value<a name="line.304"></a>
<span class="sourceLineNo">305</span>         *            absolute or relative value of the proposed change (neighbour)<a name="line.305"></a>
<span class="sourceLineNo">306</span>         * @return probability of acceptance of a change (neighbour)<a name="line.306"></a>
<span class="sourceLineNo">307</span>         */<a name="line.307"></a>
<span class="sourceLineNo">308</span>        protected double prob(double value) {<a name="line.308"></a>
<span class="sourceLineNo">309</span>            return prob(value, iTemperature);<a name="line.309"></a>
<span class="sourceLineNo">310</span>        }<a name="line.310"></a>
<span class="sourceLineNo">311</span>        <a name="line.311"></a>
<span class="sourceLineNo">312</span>        /**<a name="line.312"></a>
<span class="sourceLineNo">313</span>         * Neighbour acceptance probability<a name="line.313"></a>
<span class="sourceLineNo">314</span>         * <a name="line.314"></a>
<span class="sourceLineNo">315</span>         * @param value<a name="line.315"></a>
<span class="sourceLineNo">316</span>         *            absolute or relative value of the proposed change (neighbour)<a name="line.316"></a>
<span class="sourceLineNo">317</span>         * @param temp<a name="line.317"></a>
<span class="sourceLineNo">318</span>         *      current temperature<a name="line.318"></a>
<span class="sourceLineNo">319</span>         * @return probability of acceptance of a change (neighbour)<a name="line.319"></a>
<span class="sourceLineNo">320</span>         */<a name="line.320"></a>
<span class="sourceLineNo">321</span>        protected double prob(double value, double temp) {<a name="line.321"></a>
<span class="sourceLineNo">322</span>            if (iStochasticHC)<a name="line.322"></a>
<span class="sourceLineNo">323</span>                return 1.0 / (1.0 + Math.exp(value / temp));<a name="line.323"></a>
<span class="sourceLineNo">324</span>            else<a name="line.324"></a>
<span class="sourceLineNo">325</span>                return (value &lt;= 0.0 ? 1.0 : Math.exp(-value / temp));<a name="line.325"></a>
<span class="sourceLineNo">326</span>        }<a name="line.326"></a>
<span class="sourceLineNo">327</span><a name="line.327"></a>
<span class="sourceLineNo">328</span>        /**<a name="line.328"></a>
<span class="sourceLineNo">329</span>         * True if the given neighbour is to be be accepted<a name="line.329"></a>
<span class="sourceLineNo">330</span>         * <a name="line.330"></a>
<span class="sourceLineNo">331</span>         * @param assignment<a name="line.331"></a>
<span class="sourceLineNo">332</span>         *            current assignment<a name="line.332"></a>
<span class="sourceLineNo">333</span>         * @param neighbour<a name="line.333"></a>
<span class="sourceLineNo">334</span>         *            proposed move<a name="line.334"></a>
<span class="sourceLineNo">335</span>         * @return true if generated random number is below the generated probability<a name="line.335"></a>
<span class="sourceLineNo">336</span>         */<a name="line.336"></a>
<span class="sourceLineNo">337</span>        @Override<a name="line.337"></a>
<span class="sourceLineNo">338</span>        protected boolean accept(Assignment&lt;V, T&gt; assignment, Model&lt;V, T&gt; model, Neighbour&lt;V, T&gt; neighbour, double value, boolean lazy) {<a name="line.338"></a>
<span class="sourceLineNo">339</span>            iMoves ++;<a name="line.339"></a>
<span class="sourceLineNo">340</span>            iAbsValue += value * value;<a name="line.340"></a>
<span class="sourceLineNo">341</span>            double v = (iRelativeAcceptance ? value : (lazy ? model.getTotalValue(assignment) : value + model.getTotalValue(assignment)) - iBestValue);<a name="line.341"></a>
<span class="sourceLineNo">342</span>            if (iTrainingIterations &lt; iTrainingValues) {<a name="line.342"></a>
<span class="sourceLineNo">343</span>                if (v &lt;= 0.0) {<a name="line.343"></a>
<span class="sourceLineNo">344</span>                    iAcceptIter[value &lt; 0.0 ? 0 : value &gt; 0.0 ? 2 : 1]++;<a name="line.344"></a>
<span class="sourceLineNo">345</span>                    return true;<a name="line.345"></a>
<span class="sourceLineNo">346</span>                } else {<a name="line.346"></a>
<span class="sourceLineNo">347</span>                    iTrainingIterations ++; iTrainingTotal += v;<a name="line.347"></a>
<span class="sourceLineNo">348</span>                }<a name="line.348"></a>
<span class="sourceLineNo">349</span>                return false;<a name="line.349"></a>
<span class="sourceLineNo">350</span>            }<a name="line.350"></a>
<span class="sourceLineNo">351</span>            double prob = prob(v);<a name="line.351"></a>
<span class="sourceLineNo">352</span>            if (v &gt; 0) {<a name="line.352"></a>
<span class="sourceLineNo">353</span>                iTrainingIterations ++; iTrainingTotal += v;<a name="line.353"></a>
<span class="sourceLineNo">354</span>            }<a name="line.354"></a>
<span class="sourceLineNo">355</span>            if (prob &gt;= 1.0 || ToolBox.random() &lt; prob) {<a name="line.355"></a>
<span class="sourceLineNo">356</span>                iAcceptIter[value &lt; 0.0 ? 0 : value &gt; 0.0 ? 2 : 1]++;<a name="line.356"></a>
<span class="sourceLineNo">357</span>                return true;<a name="line.357"></a>
<span class="sourceLineNo">358</span>            }<a name="line.358"></a>
<span class="sourceLineNo">359</span>            return false;<a name="line.359"></a>
<span class="sourceLineNo">360</span>        }<a name="line.360"></a>
<span class="sourceLineNo">361</span><a name="line.361"></a>
<span class="sourceLineNo">362</span>        /**<a name="line.362"></a>
<span class="sourceLineNo">363</span>         * Increment iteration counter, cool/reheat/restoreBest if necessary<a name="line.363"></a>
<span class="sourceLineNo">364</span>         */<a name="line.364"></a>
<span class="sourceLineNo">365</span>        @Override<a name="line.365"></a>
<span class="sourceLineNo">366</span>        protected void incIteration(Solution&lt;V, T&gt; solution) {<a name="line.366"></a>
<span class="sourceLineNo">367</span>            super.incIteration(solution);<a name="line.367"></a>
<span class="sourceLineNo">368</span>            iIter++;<a name="line.368"></a>
<span class="sourceLineNo">369</span>            if (isMaster(solution)) {<a name="line.369"></a>
<span class="sourceLineNo">370</span>                if (iInitialTemperature &lt;= 0.0) {<a name="line.370"></a>
<span class="sourceLineNo">371</span>                    if (iTrainingIterations &lt; iTrainingValues) {<a name="line.371"></a>
<span class="sourceLineNo">372</span>                        setProgress(Math.round(100.0 * iTrainingIterations / iTrainingValues));<a name="line.372"></a>
<span class="sourceLineNo">373</span>                        return;<a name="line.373"></a>
<span class="sourceLineNo">374</span>                    } else {<a name="line.374"></a>
<span class="sourceLineNo">375</span>                        train(solution);<a name="line.375"></a>
<span class="sourceLineNo">376</span>                    }<a name="line.376"></a>
<span class="sourceLineNo">377</span>                }<a name="line.377"></a>
<span class="sourceLineNo">378</span>                if (iLastBestIter &gt;= 0 &amp;&amp; iIter &gt; iLastBestIter + iRestoreBestLength)<a name="line.378"></a>
<span class="sourceLineNo">379</span>                    restoreBest(solution);<a name="line.379"></a>
<span class="sourceLineNo">380</span>                if (iTemperature &lt; iMinimalTemperature) { // Minimal temperature reached, start going up again<a name="line.380"></a>
<span class="sourceLineNo">381</span>                    // If the current solution is more than 0.1% worse, restore best<a name="line.381"></a>
<span class="sourceLineNo">382</span>                    if ((solution.getModel().getTotalValue(solution.getAssignment()) - solution.getBestValue()) / Math.abs(solution.getBestValue()) &gt;= 0.001)<a name="line.382"></a>
<span class="sourceLineNo">383</span>                        restoreBest(solution);<a name="line.383"></a>
<span class="sourceLineNo">384</span>                    // Set last improving iteration so that the re-heating would continue<a name="line.384"></a>
<span class="sourceLineNo">385</span>                    iLastImprovingIter = iIter;<a name="line.385"></a>
<span class="sourceLineNo">386</span>                    // Do the first reheat<a name="line.386"></a>
<span class="sourceLineNo">387</span>                    reheat(solution);<a name="line.387"></a>
<span class="sourceLineNo">388</span>                } else if (iLastImprovingIter &gt;= 0 &amp;&amp; iIter &gt; Math.max(iLastReheatIter, iLastImprovingIter) + iReheatLength) {<a name="line.388"></a>
<span class="sourceLineNo">389</span>                    reheat(solution);<a name="line.389"></a>
<span class="sourceLineNo">390</span>                } else if (iIter &gt; iLastCoolingIter + iTemperatureLength) {<a name="line.390"></a>
<span class="sourceLineNo">391</span>                    cool(solution);<a name="line.391"></a>
<span class="sourceLineNo">392</span>                }<a name="line.392"></a>
<span class="sourceLineNo">393</span>                setProgress(Math.round(100.0 * (iIter - Math.max(iLastReheatIter, iLastImprovingIter)) / iReheatLength));<a name="line.393"></a>
<span class="sourceLineNo">394</span>            }<a name="line.394"></a>
<span class="sourceLineNo">395</span>        }<a name="line.395"></a>
<span class="sourceLineNo">396</span><a name="line.396"></a>
<span class="sourceLineNo">397</span>        /**<a name="line.397"></a>
<span class="sourceLineNo">398</span>         * Memorize the iteration when the last best solution was found.<a name="line.398"></a>
<span class="sourceLineNo">399</span>         */<a name="line.399"></a>
<span class="sourceLineNo">400</span>        @Override<a name="line.400"></a>
<span class="sourceLineNo">401</span>        public void bestSaved(Solution&lt;V, T&gt; solution) {<a name="line.401"></a>
<span class="sourceLineNo">402</span>            super.bestSaved(solution);<a name="line.402"></a>
<span class="sourceLineNo">403</span>            if (iLastImprovingIter &lt; 0 || Math.abs(iBestValue - solution.getBestValue()) / Math.max(Math.abs(iBestValue), Math.abs(solution.getBestValue())) &gt;= 0.0001) {<a name="line.403"></a>
<span class="sourceLineNo">404</span>                iLastImprovingIter = iIter;<a name="line.404"></a>
<span class="sourceLineNo">405</span>                iLastBestIter = iIter;<a name="line.405"></a>
<span class="sourceLineNo">406</span>                iBestValue = solution.getBestValue();<a name="line.406"></a>
<span class="sourceLineNo">407</span>            }<a name="line.407"></a>
<span class="sourceLineNo">408</span>        }<a name="line.408"></a>
<span class="sourceLineNo">409</span>    }<a name="line.409"></a>
<span class="sourceLineNo">410</span><a name="line.410"></a>
<span class="sourceLineNo">411</span>}<a name="line.411"></a>




























































</pre>
</div>
</body>
</html>
